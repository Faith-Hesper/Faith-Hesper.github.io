---
title: 数组方法
mathjax: true
date: 2022-09-15 15:15:18
tags:
categories:
description:
---

## 数组方法

### 添加、移除数组元素

+ `arr.push()`：从尾端添加元素
+ `arr.pop()`：从尾端删除元素
+ `arr.shift()`：从首端删除元素
+ `arr.unshift()`：从首端添加元素

### splice

`arr.splice`方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。

语法是

```js
arr.splice(start[deleteCount,elem1,...,elemN])
```

`start`：开始修改的索引位置

`deleteCount`：删除格式

`elem1`：要插入的数

```js
let arr = ["I", "study", "JavaScript", "right", "now"];

// 删除数组的前三项，并使用其他内容代替它们
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // 现在 ["Let's", "dance", "right", "now"]
```

**`splice`会改变原数组，返回的是被删除的数**

### slice

`arr.slice`方法，将从索引 `start` 到 `end`（不包括 `end`）的数组项复制到一个新的数组。语法：

```js
arr.slice([start], [end])
```

`slice`不会改变原数组，通常用于获取副本

```js
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）

alert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）
```

### concat

`arr.concat`，创建一个新数组，连接其他数组或值

语法：

```js
arr.concat(arg1,arg2...)
```

参数可以是数组或值

```js
let arr = [1, 2];
alert( arr.concat([3, 4]) ); // 1,2,3,4

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,3,4,[object Object]
```

### indexOf/lastIndexOf和includes

+ `arr.indexOf(item,from)`：从索引`from`开始搜索`item`，如果找到则返回索引，**否则返回`-1`**
+ `arr.lastindexOf(item,from)`与indexof相同，不同的是从右往左查找
+ `arr.includes(item, from)`：从索引 `from` 开始搜索 `item`，如果找到则返回 `true`，如果没找到，则返回 `false`

```js
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

`indexOf` 和 `includes` 使用严格相等 `===` 进行比较。所以，如果我们搜索 `false`，它会准确找到 `false` 而不是数字 `0`

特别地

```js
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1（错，应该为 0）
alert( arr.includes(NaN) );// true（正确）
```



## 数组遍历方法

**1.for循环**

使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。

```js
for(j = 0,len=arr.length; j < len; j++) { }
```

 

**2.foreach循环**

遍历数组中的每一项，没有返回值，对原数组没有影响，不支持IE

```js
//1 没有返回值
arr.forEach((item,index,array)=>{//执行代码})
//参数：value数组中的当前项, index当前项的索引, array原始数组；
//数组中有几项，那么传递进去的匿名回调函数就需要执行几次；
```

 

**3.map循环**

有返回值，可以return出来

map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；

```js
arr.map(function(value,index,array){
    //do something
    return  XXX})
var ary = [12,23,24,42,1]; 
var res = ary.map(function (item,index,ary ) {
    return item*10; 
}) 
console.log(res);
//-->[120,230,240,420,10]; 原数组拷贝了一份，并进行了修改
console.log(ary);
//-->[12,23,24,42,1]； 原数组并未发生变化
```

　

**4.forof遍历**

可以正确响应break、continue和return语句

```js
for(var value of myArray) { 
console.log(value);
}
```

　　

**5.filter遍历**

不会改变原始数组,返回新数组

```js
var arr = [{ 
	id: 1, text: 'aa', done: true},
	{ id: 2, text: 'bb', done: false}]
	console.log(arr.filter(item => item.done))
```

转为ES5

```js
arr.filter(function(item) {
return item.done;
});
var arr = [73,84,56, 22,100]
var newArr = arr.filter(item => item>80)  
//得到新数组 [84, 100] 
console.log(newArr,arr)
```

　　

**6.every遍历**

every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。

```js
var arr = [ 1, 2, 3, 4, 5, 6 ]; 
console.log( arr.every(function( item, index, array ){
return item > 3; })); // false
```

　

**7.some遍历**

some()是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。

```js
var arr = [ 1, 2, 3, 4, 5, 6 ];
console.log( arr.some(functio( item, index, array ){
 returnitem > 3;})); 
 //true
```

　　

**8.reduce**

`reduce() `方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。

```js
var total = [0,1,2,3,4].reduce((a, b)=>a + b); //10
```

`reduce`接受一个函数，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组

```js
[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array){
return previousValue + currentValue;});
```

![img](https://images2018.cnblogs.com/blog/1403464/201807/1403464-20180713112335425-223204218.png)

`reduce`还有第二个参数，我们可以把这个参数作为第一次调用`callback`时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为5，那么结果就是这样的：

```js
[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array){
return  previousValue + currentValue;},5);
```

　![img](https://images2018.cnblogs.com/blog/1403464/201807/1403464-20180713112406091-1932166695.png)

第一次调用的`previousValue`的值就用传入的第二个参数代替，

**9.reduceRight**

`reduceRight()`方法的功能和`reduce()`功能是一样的，不同的是`reduceRight()`从数组的末尾向前将数组中的数组项做累加。

`reduceRight()`首次调用回调函数`callbackfn`时，`prevValue` 和 `curValue` 可以是两个值之一。如果调用 `reduceRight()` 时提供了 `initialValue` 参数，则 `prevValue` 等于 `initialValue`，`curValue` 等于数组中的最后一个值。如果没有提供 `initialValue` 参数，则 `prevValue` 等于数组最后一个值， `curValue` 等于数组中倒数第二个值。

```js
var arr = [0,1,2,3,4];
arr.reduceRight(function(preValue,curValue,index,array) {
return preValue + curValue;
}); // 10
```

回调将会被调用四次，每次调用的参数及返回值如下：

![img](https://images2018.cnblogs.com/blog/1403464/201807/1403464-20180713112700747-845347728.png)

如果提供一个初始值`initialValue`为`5`:

```js
var arr = [0,1,2,3,4];
arr.reduceRight(function(preValue,curValue,index,array) {
    return preValue + curValue;
}, 5); // 15
```

回调将会被调用五次，每次调用的参数及返回的值如下：

![img](https://images2018.cnblogs.com/blog/1403464/201807/1403464-20180713112743338-1377666579.png)

同样的，可以对一个数组求和，也可以使用`reduceRight()`方法:

```js
var arr = [1,2,3,4,5,6];
console.time("ruduceRight");
Array.prototype.ruduceRightSum = function(){
	for(var i = 0; i < 10000; i++) {
	return this.reduceRight (function(preValue, curValue) {
	return preValue + curValue;
	});
}}
arr.ruduceRightSum();
console.log('最终的值：'+ arr.ruduceSum()); 
// 21
console.timeEnd("ruduceRight"); // 5.725ms
```

**10.find**

find()方法返回数组中符合测试函数条件的第一个元素。否则返回undefined 

```js
var stu = [{name: '张三',gender:'男',age: 20},{name: '王小毛',gender:'男',age: 20},{name: '李四',gender: '男',age: 20}]
function getStu(element){
    return element.name == '李四'
}
stu.find(getStu) //返回结果为{name: "李四", gender: "男", age: 20}
```

ES6方法

```js
stu.find((element) => (element.name == '李四'))
```

 

**11.findIndex**

对于数组中的每个元素，**findIndex** 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 **true**。只要有一个元素返回 true，**findIndex** 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 **findIndex** 返回 -1。

**findIndex** 不会改变数组对象。

```js
[1,2,3].findIndex(function(x) { x == 2; }); // Returns an index value of 1.
[1,2,3].findIndex(x => x == 4); // Returns an index value of -1. 
```

**12.keys，values，entries**

 ES6 提供三个新的方法 —— entries()，keys()和values() ——  用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历

```js
for(let index of ['a','b'].keys()) {
    console.log(index);
}
// 0 
// 1
for(let elem of ['a', 'b'].values()) {
    console.log(elem);
}// 'a'
// 'b'
for(let[index, elem] of ['a', 'b'].entries()) {
    console.log(index, elem);
}
// 0 "a"
// 1 "b"
```
