---
title: 计算机网络
mathjax: true
date: 2022-08-31 15:26:19
tags: [前端]
categories:
description: 计算机网络
---

## 计算机网络

### <span id="status">HTTP状态码</span>

常用状态码及其使用场景：

+ 1xx：表示目前是协议的中间状态，还需要后续请求
+ 2xx：表示请求成功
+ 3xx：表示重定向状态，需要重新请求
+ 4xx：表示请求报文错误
+ 5xx：服务器端错误

常用状态码：

+ 101 切换请求协议，从 HTTP 切换到 WebSocket
+ 200 请求成功，有响应体
+ 204 No Content 请求成功执行，但没有内容，常用于测试服务器性能(options方法)
+ 301 永久重定向：会缓存(cdn)
+ 302 临时重定向：不会缓存
+ 304 协商缓存命中
+ 400 Bad Request 请求错误
+ 401 Unauthorized 用户认证失败
+ 403 Forbidden 服务器禁止访问
+ 404 Not Found 资源未找到
+ 500 Internal Server Error 服务器端错误
+ 502 Bad Gateway 网关错误
+ 503 Service Unavailable 服务器繁忙

302表示临时重定向，资源只是暂时不能被访问了，常用于网站资源需要权限时，会重定向到登陆页面，登陆后才可继续访问

301表示永久重定向,cdn

### HTTP请求方法

+ `GET`：获取资源
+ `POST`：传输实体信息
+ `OPOTIONS`：询问支持的方法，`OPTIONS`方法用来查询针对请求URL指定的资源支持的方法
+ `CONNECT`：
+ 要求用隧道协议连接代理，CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 `SSL（Secure Sockets Layer，安全套接层）`和 TLS`（Transport Layer Security，传输层安全）`协议把通信内容加 密后经网络隧道传输
+ `TRACE`：追踪路径，`TRACE`方法是让Web服务器端将之前的请求通信返回给客户端
+ `PUT`：传输文件。但是由于自身不带验证机制，任何人都可以上传文件，存在安全性问题，一般不用该方法
+ `HEAD`：获取响应首部，`HEAD`方法和`GET`方法一样，只是不返回报文主体部分，用于确定`URL`的有效性及资源更新的日期时间等
+ `DELTELE`：删除文件，是与`PUT`相反的方法

HTTP请求URL

`http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument`

+ `http://`：代表请求协议

+ `www.example.com`：代表域名

+ `:80`：端口

+ `/path/to/myfile.html`：请求资源路径

+ `?key1=value1&key2=value2`：请求参数

+ `#SomewhereInTheDocument`：锚点

### 请求头

[MDN关于请求头的介绍](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)

HTTP的请求标头分为四种：<a href="#common-header">通用标头</a>、<a href="#request-header">请求标头</a>、<a href="#response-header">响应标头</a>、<a href="#solid-header">实体标头</a>

#### <span id="common-header">通用标头</span>

> 通用标头：可以出现在请求标头和响应标头中

通用标头主要有三个，分别是 `Date`、`Cache-Control` 和 `Connection`

Date 是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下

```http
Date: Wed, 21 Oct 2015 07:28:00 GMT 
```

`Cache-Control`

Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接

Connection 有两种：`持久性连接`、`非持久性连接`

持久性连接即一次事务完成后不关闭网络连接

```http
Connection: keep-alive
```

非持久性连接即一次事务完成后关闭网络连接

```http
Connection: close
```

#### <span id="request-header">请求标头</span>

[MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header)

`referer`：标记请求来源，告诉服务器该网页是从哪个页面链接来的

```http
Referer: https://developer.mozilla.org/testpage.html
```

#### <span id="response-header">响应标头</span>

首先出现的应该就是[响应状态码](#status)

`Access-Control-Allow-Origin`,指定允许访问来源，告诉浏览器允许该源进行资源访问。使用`*`通配符允许如何来源

```http
Access-Control-Allow-Origin: https://mozilla.org
```

`Keep-Alive`：指定[Connection](#connection)非持续性连接的存活时间

```http
Connection: Keep-Alive
Keep-Alive: timeout=5, max=997
```

`timeout`：指示空闲连接必须保持打开状态的最短时间（以秒为单位）。

`max`：指示在关闭连接之前可以在此连接上发送的最大请求数

上述 HTTP 代码的意思就是限制最大的超时时间是 5s 和 最大的连接请求是 997 个

`Server`：服务器标头包含有关原始服务器用来处理请求的软件的信息

```http
Server: Apache/2.4.1 (Unix)
```



#### <span id="solid-header">实体标头</span>

实体标头是描述消息正文内容的HTTP标头，实体标头用于 HTTP 请求和响应中

常见得到实体标头有：`Content-Length`、`Content-Language`、 `Content-Encoding`

Content-Length：指定实体主体的大小，以字节为单位，发送到接收方

```http
content-length: 1736
```

Content-Language：描述了客户端或者服务端能够接受的语言

```http
Content-Language: de-DE
Content-Language: en-US
accept-language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
```

Content-Encoding：指定应用编码方式

常见的内容编码：**gzip、compress、deflate、identity** 

```http
Accept-Encoding: gzip, deflate //请求头
Content-Encoding: gzip  //响应头
```



### 网络模型

#### OSI七层模型

[网络模型](https://www.cnblogs.com/hello-shf/p/13545959.html)

[网络基础](https://tonydeng.github.io/sdn-handbook/basic/tcpip.html)

![OSI](https://cdn.jsdelivr.net/gh/faith-hesper/Note/img/20220828091803.png)

七层模型各层功能

![模型功能](https://cdn.jsdelivr.net/gh/faith-hesper/Note/img/20220828091952.png)

##### 应用层

`OSI`参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：`HTTP`，`HTTPS`，`FTP`，`POP3`、`SMTP`等

##### 表示层

表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别

如：HTTP请求头/响应头 Content-Type：application/json; charset=utf-8 。这就是规定双方协商的数据格式： application/json; 和编码格式： charset=utf-8

##### 会话层

 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成

##### 传输层

传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，`TCP` `UDP`就是在这一层。端口号既是这里的“端”

##### 网络层

本层通过`IP`寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的`IP`层。这一层就是我们经常说的`IP`协议层。`IP`协议是`Internet`的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式

网络层的主要功能：通过IP地址，实现网络寻址，即IP寻址，通过路由算法进行最优的网络路由

##### 数据链路层

将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能

该层主要负责建立和管理不同计算机节点间的数据链路，并提供差错检测、封装成帧、透明传输的能力。数据链路层又分为两个层：媒体访问控制子层（MAC）和逻辑链路控制子层（LLC）

##### 物理层

实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质

#### TCP/IP五层模型

`TCP/IP`模型比`OSI`模型更加简洁，它把`应用层/表示层/会话层`全部整合为了`应用层`

![五层模型](https://cdn.jsdelivr.net/gh/faith-hesper/Note/img/20220828104032.webp)

### TCP与UDP

[TCP与UDP](https://juejin.cn/post/6844903490595061767#heading-11)

TCP和UDP都是传输层协议，都属于TCP/IP协议族

#### TCP

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

特点：

1. 面向连接

   即发送数据前必须先建立连接，进行三次握手

2. 仅支持单播传输

   即只支持点对点的数据传输，不支持多播和广播传输方式

3. 面向字节流

   虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送

4. 可靠传输

   对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传

5. 提供拥塞控制

   当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞

6. 提供全双工通信

   TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）

应用：

> TCP主要应用于对效率要求低，对准确性要求高或者要求有连接的的场景

+ 电子邮件
+ 文件下载与传输(FTP)
+ 远程终端连接(TELNEt)

#### UDP

UDP的全称是**用户数据报协议**

特点：

1. 面向无连接

   UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，在接收到数据后就立即开始发送数据

2. 有单播、多播、广播的功能

   UDP支持一对一、多对多、多对一的数据传输方式

3. 面向报文

   UDP不会对数据报文进行合并与拆分

4. 不可靠性

5. 头部开销小，传输数据报文时很高效

应用：

> UDP主要应用于对效率要求高，对准确性要求低的场景

+ 视频、音频通话
+ 包总量较少的通信(DNS、SNMP等)

![tcp与udp区别](https://cdn.jsdelivr.net/gh/faith-hesper/Note/img/20220826141412.png)

### TCP三次握手与四次挥手

<a href="#tcp">TCP</a>

> TCP: 一种面向连接的、可靠的、基于字节流的传输层通信协议

[三次握手与四次挥手](https://juejin.cn/post/6844903834708344840#heading-1)

#### 三次握手

建立连接

1. 第一次握手：客户端给服务器发送一个SYN报文，进行请求连接
2. 第二次握手：服务器收到SYN报文后，服务器发送一个SYN+ACK报文
3. 第三次握手：客户端收到SYN+ACK报文后，会回应一个ACK报文，服务器收到ACK报文后，完成三次握手

#### 四次挥手

断开连接

1. 第一次挥手：客户端发送一个FIN报文给服务器
2. 第二次挥手：服务器收到FIN之后，会发送ACK报文，
3. 第三次挥手：服务器发送一个FIN报文给客户端
4. 第四次挥手：客户端收到FIN之后，发送一个ACK报文应答，客户端会等待一个报文来回的时长，确定服务器没有再发送信息后关闭连接，服务器收到ACK报文之后就关闭连接
