define(["./AttributeCompression-44abee07","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./combine-ac72e009","./IndexDatatype-ed8b21cb","./Math-56779564","./Cartesian2-0a34ed75","./createTaskProcessorWorker-03824364","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./WebGLConstants-7f557f93","./Matrix2-e52b9454","./Matrix3-59918a96","./RuntimeError-cfbf2bc8"],(function(t,e,a,s,n,r,i,o,l,c,d,f,h,u,C){"use strict";const p=32767,m=Math.cos(r.CesiumMath.toRadians(150)),A=new a.Cartographic,b=new e.Cartesian3;const w=new a.Cartographic,g=new a.Cartographic;function y(t){const e=8*t,a=3*e,s=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(s),this.startFaceNormalAndVertexCornerIds=new Float32Array(s),this.endPositionAndHeights=new Float32Array(s),this.endFaceNormalAndHalfWidths=new Float32Array(s),this.vertexBatchIds=new Uint16Array(e),this.indices=n.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const N=new e.Cartesian3,k=new e.Cartesian3;function x(t,a,s,n,r){const i=e.Cartesian3.subtract(s,a,k);let o=e.Cartesian3.subtract(a,t,N);return e.Cartesian3.normalize(i,i),e.Cartesian3.normalize(o,o),e.Cartesian3.dot(i,o)<m&&(o=e.Cartesian3.multiplyByScalar(o,-1,N)),e.Cartesian3.add(i,o,r),e.Cartesian3.equals(r,e.Cartesian3.ZERO)&&(r=e.Cartesian3.subtract(t,a)),e.Cartesian3.cross(r,n,r),e.Cartesian3.cross(n,r,r),e.Cartesian3.normalize(r,r),r}const I=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],E=I.length,F=new e.Cartesian3,H=new e.Cartesian3,P=new e.Cartesian3,O=new e.Cartesian3,v=new e.Cartesian3;y.prototype.addVolume=function(t,a,s,n,r,i,o,l,c,d){let f=e.Cartesian3.add(a,c,F);const h=d.geodeticSurfaceNormal(f,H);f=e.Cartesian3.add(s,c,F);const u=d.geodeticSurfaceNormal(f,O),C=x(t,a,s,h,P),p=x(n,s,a,u,v),m=this.startEllipsoidNormals,A=this.endEllipsoidNormals,b=this.startPositionAndHeights,w=this.startFaceNormalAndVertexCornerIds,g=this.endPositionAndHeights,y=this.endFaceNormalAndHalfWidths,N=this.vertexBatchIds;let k,D=this.batchIdOffset,M=this.vec3Offset,S=this.vec4Offset;for(k=0;k<8;k++)e.Cartesian3.pack(h,m,M),e.Cartesian3.pack(u,A,M),e.Cartesian3.pack(a,b,S),b[S+3]=r,e.Cartesian3.pack(s,g,S),g[S+3]=i,e.Cartesian3.pack(C,w,S),w[S+3]=k,e.Cartesian3.pack(p,y,S),y[S+3]=o,N[D++]=l,M+=3,S+=4;this.batchIdOffset=D,this.vec3Offset=M,this.vec4Offset=S;const R=this.indices,U=this.volumeStartIndex,B=this.indexOffset;for(k=0;k<E;k++)R[B+k]=I[k]+U;this.volumeStartIndex+=8,this.indexOffset+=E};const D=new i.Rectangle,M=new a.Ellipsoid,S=new e.Cartesian3,R=new e.Cartesian3,U=new e.Cartesian3,B=new e.Cartesian3,T=new e.Cartesian3;return o.createTaskProcessorWorker((function(o,l){const c=new Uint16Array(o.positions),d=new Uint16Array(o.widths),f=new Uint32Array(o.counts),h=new Uint16Array(o.batchIds),u=D,C=M,m=S,N=new Float64Array(o.packedBuffer);let k=0;const x=N[k++],I=N[k++];let E;i.Rectangle.unpack(N,k,u),k+=i.Rectangle.packedLength,a.Ellipsoid.unpack(N,k,C),k+=a.Ellipsoid.packedLength,e.Cartesian3.unpack(N,k,m);let F=c.length/3;const H=c.subarray(0,F),P=c.subarray(F,2*F),O=c.subarray(2*F,3*F);t.AttributeCompression.zigZagDeltaDecode(H,P,O),function(t,e,s,n){const r=n.length,i=t.length,o=new Uint8Array(i),l=w,c=g;let d=0;for(let s=0;s<r;s++){const r=n[s];let i=r;for(let s=1;s<r;s++){const n=d+s,r=n-1;c.longitude=t[n],c.latitude=e[n],l.longitude=t[r],l.latitude=e[r],a.Cartographic.equals(c,l)&&(i--,o[r]=1)}n[s]=i,d+=r}let f=0;for(let a=0;a<i;a++)1!==o[a]&&(t[f]=t[a],e[f]=e[a],s[f]=s[a],f++)}(H,P,O,f);const v=f.length;let V=0;for(E=0;E<v;E++){V+=f[E]-1}const W=new y(V),z=function(t,s,n,i,o,l,c){const d=t.length,f=new Float64Array(3*d);for(let h=0;h<d;++h){const d=t[h],u=s[h],C=n[h],m=r.CesiumMath.lerp(i.west,i.east,d/p),w=r.CesiumMath.lerp(i.south,i.north,u/p),g=r.CesiumMath.lerp(o,l,C/p),y=a.Cartographic.fromRadians(m,w,g,A),N=c.cartographicToCartesian(y,b);e.Cartesian3.pack(N,f,3*h)}return f}(H,P,O,u,x,I,C);F=H.length;const q=new Float32Array(3*F);for(E=0;E<F;++E)q[3*E]=z[3*E]-m.x,q[3*E+1]=z[3*E+1]-m.y,q[3*E+2]=z[3*E+2]-m.z;let L=0,_=0;for(E=0;E<v;E++){const t=f[E]-1,a=.5*d[E],s=h[E],n=L;for(let i=0;i<t;i++){const o=e.Cartesian3.unpack(q,L,U),l=e.Cartesian3.unpack(q,L+3,B);let c=O[_],d=O[_+1];c=r.CesiumMath.lerp(x,I,c/p),d=r.CesiumMath.lerp(x,I,d/p),_++;let f=R,h=T;if(0===i){const a=n+3*t,s=e.Cartesian3.unpack(q,a,R);if(e.Cartesian3.equals(s,o))e.Cartesian3.unpack(q,a-3,f);else{const t=e.Cartesian3.subtract(o,l,R);f=e.Cartesian3.add(t,o,R)}}else e.Cartesian3.unpack(q,L-3,f);if(i===t-1){const t=e.Cartesian3.unpack(q,n,T);if(e.Cartesian3.equals(t,l))e.Cartesian3.unpack(q,n+3,h);else{const t=e.Cartesian3.subtract(l,o,T);h=e.Cartesian3.add(t,l,T)}}else e.Cartesian3.unpack(q,L+6,h);W.addVolume(f,o,l,h,c,d,a,s,m,C),L+=3}L+=3,_++}const G=W.indices;l.push(W.startEllipsoidNormals.buffer),l.push(W.endEllipsoidNormals.buffer),l.push(W.startPositionAndHeights.buffer),l.push(W.startFaceNormalAndVertexCornerIds.buffer),l.push(W.endPositionAndHeights.buffer),l.push(W.endFaceNormalAndHalfWidths.buffer),l.push(W.vertexBatchIds.buffer),l.push(G.buffer);let Z={indexDatatype:2===G.BYTES_PER_ELEMENT?n.IndexDatatype.UNSIGNED_SHORT:n.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:W.startEllipsoidNormals.buffer,endEllipsoidNormals:W.endEllipsoidNormals.buffer,startPositionAndHeights:W.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:W.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:W.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:W.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:W.vertexBatchIds.buffer,indices:G.buffer};if(o.keepDecodedPositions){const t=function(t){const e=t.length,a=new Uint32Array(e+1);let s=0;for(let n=0;n<e;++n)a[n]=s,s+=t[n];return a[e]=s,a}(f);l.push(z.buffer,t.buffer),Z=s.combine(Z,{decodedPositions:z.buffer,decodedPositionOffsets:t.buffer})}return Z}))}));
