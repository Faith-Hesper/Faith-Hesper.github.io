define(["./defined-64766648","./Ellipsoid-fa58f06f","./Transforms-b1e48e05","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./IndexDatatype-ed8b21cb","./Math-56779564","./VertexFormat-01d05a0d","./WallGeometryLibrary-c6d6ac47","./GeographicProjection-868b0b16","./Matrix3-59918a96","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./Cartesian2-0a34ed75","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93","./arrayRemoveDuplicates-d0608faf","./PolylinePipeline-206d6e54","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6","./IntersectionTests-39c3b1c1","./Plane-f9bf6226"],(function(e,t,i,n,a,o,r,s,l,m,u,p,c,d,y,g,f,h,C,x,A,_,E,b,v,w,F,L){"use strict";const k=new n.Cartesian3,G=new n.Cartesian3,V=new n.Cartesian3,H=new n.Cartesian3,P=new n.Cartesian3,D=new n.Cartesian3,T=new n.Cartesian3;function z(i){const a=(i=o.defaultValue(i,o.defaultValue.EMPTY_OBJECT)).positions,r=i.maximumHeights,s=i.minimumHeights,l=o.defaultValue(i.vertexFormat,p.VertexFormat.DEFAULT),m=o.defaultValue(i.granularity,u.CesiumMath.RADIANS_PER_DEGREE),c=o.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84);this._positions=a,this._minimumHeights=s,this._maximumHeights=r,this._vertexFormat=p.VertexFormat.clone(l),this._granularity=m,this._ellipsoid=t.Ellipsoid.clone(c),this._workerName="createWallGeometry";let d=1+a.length*n.Cartesian3.packedLength+2;e.defined(s)&&(d+=s.length),e.defined(r)&&(d+=r.length),this.packedLength=d+t.Ellipsoid.packedLength+p.VertexFormat.packedLength+1}z.pack=function(i,a,r){let s;r=o.defaultValue(r,0);const l=i._positions;let m=l.length;for(a[r++]=m,s=0;s<m;++s,r+=n.Cartesian3.packedLength)n.Cartesian3.pack(l[s],a,r);const u=i._minimumHeights;if(m=e.defined(u)?u.length:0,a[r++]=m,e.defined(u))for(s=0;s<m;++s)a[r++]=u[s];const c=i._maximumHeights;if(m=e.defined(c)?c.length:0,a[r++]=m,e.defined(c))for(s=0;s<m;++s)a[r++]=c[s];return t.Ellipsoid.pack(i._ellipsoid,a,r),r+=t.Ellipsoid.packedLength,p.VertexFormat.pack(i._vertexFormat,a,r),a[r+=p.VertexFormat.packedLength]=i._granularity,a};const O=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),R=new p.VertexFormat,M={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:O,vertexFormat:R,granularity:void 0};return z.unpack=function(i,a,r){let s;a=o.defaultValue(a,0);let l=i[a++];const m=new Array(l);for(s=0;s<l;++s,a+=n.Cartesian3.packedLength)m[s]=n.Cartesian3.unpack(i,a);let u,c;if(l=i[a++],l>0)for(u=new Array(l),s=0;s<l;++s)u[s]=i[a++];if(l=i[a++],l>0)for(c=new Array(l),s=0;s<l;++s)c[s]=i[a++];const d=t.Ellipsoid.unpack(i,a,O);a+=t.Ellipsoid.packedLength;const y=p.VertexFormat.unpack(i,a,R),g=i[a+=p.VertexFormat.packedLength];return e.defined(r)?(r._positions=m,r._minimumHeights=u,r._maximumHeights=c,r._ellipsoid=t.Ellipsoid.clone(d,r._ellipsoid),r._vertexFormat=p.VertexFormat.clone(y,r._vertexFormat),r._granularity=g,r):(M.positions=m,M.minimumHeights=u,M.maximumHeights=c,M.granularity=g,new z(M))},z.fromConstantHeights=function(t){const i=(t=o.defaultValue(t,o.defaultValue.EMPTY_OBJECT)).positions;let n,a;const r=t.minimumHeight,s=t.maximumHeight,l=e.defined(r),m=e.defined(s);if(l||m){const e=i.length;n=l?new Array(e):void 0,a=m?new Array(e):void 0;for(let t=0;t<e;++t)l&&(n[t]=r),m&&(a[t]=s)}return new z({positions:i,maximumHeights:a,minimumHeights:n,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},z.createGeometry=function(t){const o=t._positions,p=t._minimumHeights,d=t._maximumHeights,y=t._vertexFormat,g=t._granularity,f=t._ellipsoid,h=c.WallGeometryLibrary.computePositions(f,o,d,p,g,!0);if(!e.defined(h))return;const C=h.bottomPositions,x=h.topPositions,A=h.numCorners;let _=x.length,E=2*_;const b=y.position?new Float64Array(E):void 0,v=y.normal?new Float32Array(E):void 0,w=y.tangent?new Float32Array(E):void 0,F=y.bitangent?new Float32Array(E):void 0,L=y.st?new Float32Array(E/3*2):void 0;let z,O=0,R=0,M=0,S=0,I=0,N=T,W=D,B=P,q=!0;_/=3;let J=0;const U=1/(_-A-1);for(z=0;z<_;++z){const e=3*z,t=n.Cartesian3.fromArray(x,e,k),i=n.Cartesian3.fromArray(C,e,G);if(y.position&&(b[O++]=i.x,b[O++]=i.y,b[O++]=i.z,b[O++]=t.x,b[O++]=t.y,b[O++]=t.z),y.st&&(L[I++]=J,L[I++]=0,L[I++]=J,L[I++]=1),y.normal||y.tangent||y.bitangent){let i=n.Cartesian3.clone(n.Cartesian3.ZERO,H);const a=n.Cartesian3.subtract(t,f.geodeticSurfaceNormal(t,G),G);if(z+1<_&&(i=n.Cartesian3.fromArray(x,e+3,H)),q){const e=n.Cartesian3.subtract(i,t,V),o=n.Cartesian3.subtract(a,t,k);N=n.Cartesian3.normalize(n.Cartesian3.cross(o,e,N),N),q=!1}n.Cartesian3.equalsEpsilon(t,i,u.CesiumMath.EPSILON10)?q=!0:(J+=U,y.tangent&&(W=n.Cartesian3.normalize(n.Cartesian3.subtract(i,t,W),W)),y.bitangent&&(B=n.Cartesian3.normalize(n.Cartesian3.cross(N,W,B),B))),y.normal&&(v[R++]=N.x,v[R++]=N.y,v[R++]=N.z,v[R++]=N.x,v[R++]=N.y,v[R++]=N.z),y.tangent&&(w[S++]=W.x,w[S++]=W.y,w[S++]=W.z,w[S++]=W.x,w[S++]=W.y,w[S++]=W.z),y.bitangent&&(F[M++]=B.x,F[M++]=B.y,F[M++]=B.z,F[M++]=B.x,F[M++]=B.y,F[M++]=B.z)}}const j=new l.GeometryAttributes;y.position&&(j.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:b})),y.normal&&(j.normal=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v})),y.tangent&&(j.tangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:w})),y.bitangent&&(j.bitangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:F})),y.st&&(j.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:L}));const Y=E/3;E-=6*(A+1);const Z=m.IndexDatatype.createTypedArray(Y,E);let K=0;for(z=0;z<Y-2;z+=2){const e=z,t=z+2,i=n.Cartesian3.fromArray(b,3*e,k),a=n.Cartesian3.fromArray(b,3*t,G);if(n.Cartesian3.equalsEpsilon(i,a,u.CesiumMath.EPSILON10))continue;const o=z+1,r=z+3;Z[K++]=o,Z[K++]=e,Z[K++]=r,Z[K++]=r,Z[K++]=e,Z[K++]=t}return new r.Geometry({attributes:j,indices:Z,primitiveType:r.PrimitiveType.TRIANGLES,boundingSphere:new i.BoundingSphere.fromVertices(b)})},function(i,n){return e.defined(n)&&(i=z.unpack(i,n)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),z.createGeometry(i)}}));
