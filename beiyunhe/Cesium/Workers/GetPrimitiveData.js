define(["./Color-cad7c885","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./GeometryInstance-a555221e","./PolygonGeometry-9ef51ca3","./PolygonOutlineGeometry-9f19e302","./VertexFormat-01d05a0d","./Resource-be841477","./combine-ac72e009","./WebGLConstants-7f557f93","./Cartesian2-0a34ed75","./Texture-3b0b528f","./Transforms-b1e48e05","./defer-7878b392","./RuntimeError-cfbf2bc8","./Matrix2-e52b9454","./Matrix3-59918a96","./PixelFormat-5109196d","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./Geometry-dd0ae099","./PrimitivePipeline-7bd2b931","./Ellipsoid-fa58f06f","./GeographicProjection-868b0b16","./Cartesian3-e96ac170","./GetRidingLanternGeometry","./Math-56779564","./ArcType-26a3f38d","./BoundingRectangle-3100662d","./EllipsoidGeodesic-9e013872","./EllipsoidTangentPlane-8f36a7e0","./AxisAlignedBoundingBox-8b4e9f9c","./IntersectionTests-39c3b1c1","./Plane-f9bf6226","./GeometryOffsetAttribute-2579b8d2","./GeometryPipeline-92c34dd1","./AttributeCompression-44abee07","./EncodedCartesian3-e0f0a7d1","./IndexDatatype-ed8b21cb","./PolygonGeometryLibrary-37fe200f","./arrayRemoveDuplicates-d0608faf","./EllipsoidRhumbLine-cea00df6","./PolygonPipeline-d79010c3","./WebMercatorProjection-78306e76"],(function(e,t,a,n,r,i,o,l,s,u,c,m,f,p,d,h,_,g,y,C,T,b,x,v,E,I,A,P,S,M,D,w,z,O,L,R,N,F,B,U,V,k,G,W,H){"use strict";function Y(t,n,r,i){t=a.defaultValue(t,1),n=a.defaultValue(n,1),r=a.defaultValue(r,1),i=a.defaultValue(i,1),this.value=new Uint8Array([e.Color.floatToByte(t),e.Color.floatToByte(n),e.Color.floatToByte(r),e.Color.floatToByte(i)])}Object.defineProperties(Y.prototype,{componentDatatype:{get:function(){return t.ComponentDatatype.UNSIGNED_BYTE}},componentsPerAttribute:{get:function(){return 4}},normalize:{get:function(){return!0}}}),Y.fromColor=function(e){return new Y(e.red,e.green,e.blue,e.alpha)},Y.toValue=function(e,t){return n.defined(t)?e.toBytes(t):new Uint8Array(e.toBytes())},Y.equals=function(e,t){return e===t||n.defined(e)&&n.defined(t)&&e.value[0]===t.value[0]&&e.value[1]===t.value[1]&&e.value[2]===t.value[2]&&e.value[3]===t.value[3]};var X="in vec3 v_positionMC;\nin vec3 v_positionEC;\nin vec2 v_st;\nvoid main()\n{\nczm_materialInput materialInput;\nvec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n#ifdef FACE_FORWARD\nnormalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\nmaterialInput.s = v_st.s;\nmaterialInput.st = v_st;\nmaterialInput.str = vec3(v_st, 0.0);\nmaterialInput.normalEC = normalEC;\nmaterialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\nvec3 positionToEyeEC = -v_positionEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nczm_material material = czm_getMaterial(materialInput);\n#ifdef FLAT\nout_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\nout_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n",j="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec2 st;\nin float batchId;\nout vec3 v_positionMC;\nout vec3 v_positionEC;\nout vec2 v_st;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionMC = position3DHigh + position3DLow;\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_st = st;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";const $={ADD:c.WebGLConstants.FUNC_ADD,SUBTRACT:c.WebGLConstants.FUNC_SUBTRACT,REVERSE_SUBTRACT:c.WebGLConstants.FUNC_REVERSE_SUBTRACT,MIN:c.WebGLConstants.MIN,MAX:c.WebGLConstants.MAX};var K=Object.freeze($);const Z={ZERO:c.WebGLConstants.ZERO,ONE:c.WebGLConstants.ONE,SOURCE_COLOR:c.WebGLConstants.SRC_COLOR,ONE_MINUS_SOURCE_COLOR:c.WebGLConstants.ONE_MINUS_SRC_COLOR,DESTINATION_COLOR:c.WebGLConstants.DST_COLOR,ONE_MINUS_DESTINATION_COLOR:c.WebGLConstants.ONE_MINUS_DST_COLOR,SOURCE_ALPHA:c.WebGLConstants.SRC_ALPHA,ONE_MINUS_SOURCE_ALPHA:c.WebGLConstants.ONE_MINUS_SRC_ALPHA,DESTINATION_ALPHA:c.WebGLConstants.DST_ALPHA,ONE_MINUS_DESTINATION_ALPHA:c.WebGLConstants.ONE_MINUS_DST_ALPHA,CONSTANT_COLOR:c.WebGLConstants.CONSTANT_COLOR,ONE_MINUS_CONSTANT_COLOR:c.WebGLConstants.ONE_MINUS_CONSTANT_COLOR,CONSTANT_ALPHA:c.WebGLConstants.CONSTANT_ALPHA,ONE_MINUS_CONSTANT_ALPHA:c.WebGLConstants.ONE_MINUS_CONSTANT_ALPHA,SOURCE_ALPHA_SATURATE:c.WebGLConstants.SRC_ALPHA_SATURATE};var q=Object.freeze(Z);const J={DISABLED:Object.freeze({enabled:!1}),ALPHA_BLEND:Object.freeze({enabled:!0,equationRgb:K.ADD,equationAlpha:K.ADD,functionSourceRgb:q.SOURCE_ALPHA,functionSourceAlpha:q.ONE,functionDestinationRgb:q.ONE_MINUS_SOURCE_ALPHA,functionDestinationAlpha:q.ONE_MINUS_SOURCE_ALPHA}),PRE_MULTIPLIED_ALPHA_BLEND:Object.freeze({enabled:!0,equationRgb:K.ADD,equationAlpha:K.ADD,functionSourceRgb:q.ONE,functionSourceAlpha:q.ONE,functionDestinationRgb:q.ONE_MINUS_SOURCE_ALPHA,functionDestinationAlpha:q.ONE_MINUS_SOURCE_ALPHA}),ADDITIVE_BLEND:Object.freeze({enabled:!0,equationRgb:K.ADD,equationAlpha:K.ADD,functionSourceRgb:q.SOURCE_ALPHA,functionSourceAlpha:q.ONE,functionDestinationRgb:q.ONE,functionDestinationAlpha:q.ONE})};var Q=Object.freeze(J);const ee={FRONT:c.WebGLConstants.FRONT,BACK:c.WebGLConstants.BACK,FRONT_AND_BACK:c.WebGLConstants.FRONT_AND_BACK};var te=Object.freeze(ee);function ae(e){e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT),this.material=e.material,this.translucent=a.defaultValue(e.translucent,!0),this._vertexShaderSource=e.vertexShaderSource,this._fragmentShaderSource=e.fragmentShaderSource,this._renderState=e.renderState,this._closed=a.defaultValue(e.closed,!1)}function ne(e,t,a,n,r){this._format=e,this._datatype=t,this._width=a,this._height=n,this._buffer=r}function re(){if(!n.defined(ce._canTransferArrayBuffer)){const e=new Worker(le("Workers/transferTypedArrayTest.js"));e.postMessage=a.defaultValue(e.webkitPostMessage,e.postMessage);const t=99,r=new Int8Array([t]);try{e.postMessage({array:r},[r.buffer])}catch(e){return ce._canTransferArrayBuffer=!1,ce._canTransferArrayBuffer}const i=d.defer();e.onmessage=function(a){const r=a.data.array,o=n.defined(r)&&r[0]===t;i.resolve(o),e.terminate(),ce._canTransferArrayBuffer=o},ce._canTransferArrayBuffer=i.promise}return ce._canTransferArrayBuffer}Object.defineProperties(ae.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}}}),ae.prototype.getFragmentShaderSource=function(){const e=[];return e.push("in vec4 v_endPlaneNormalEcAndBatchId;"),this.flat&&e.push("#define FLAT"),this.faceForward&&e.push("#define FACE_FORWARD"),n.defined(this.material)&&e.push(this.material.shaderSource),e.push(this.fragmentShaderSource),e.join("\n")},ae.prototype.isTranslucent=function(){return n.defined(this.material)&&this.material.isTranslucent()||!n.defined(this.material)&&this.translucent},ae.prototype.getRenderState=function(){const e=this.isTranslucent(),t=s.clone(this.renderState,!1);return e?(t.depthMask=!1,t.blending=Q.ALPHA_BLEND):t.depthMask=!0,t},ae.getDefaultRenderState=function(e,t,a){let r={depthTest:{enabled:!0}};return e&&(r.depthMask=!1,r.blending=Q.ALPHA_BLEND),t&&(r.cull={enabled:!0,face:te.BACK}),n.defined(a)&&(r=u.combine(a,r,!0)),r},Object.defineProperties(ne.prototype,{internalFormat:{get:function(){return this._format}},pixelDatatype:{get:function(){return this._datatype}},width:{get:function(){return this._width}},height:{get:function(){return this._height}},bufferView:{get:function(){return this._buffer}}}),ne.clone=function(e){if(n.defined(e))return new ne(e._format,e._datatype,e._width,e._height,e._buffer)},ne.prototype.clone=function(){return ne.clone(this)};const ie=new s.Event;function oe(e,t){--e._activeTasks;const a=t.id;if(!n.defined(a))return;const r=e._deferreds,i=r[a];if(n.defined(t.error)){let e=t.error;"RuntimeError"===e.name?(e=new h.RuntimeError(t.error.message),e.stack=t.error.stack):"DeveloperError"===e.name&&(e=new s.DeveloperError(t.error.message),e.stack=t.error.stack),ie.raiseEvent(e),i.reject(e)}else ie.raiseEvent(),i.resolve(t.result);delete r[a]}function le(e){let t=p.buildModuleUrl(e);if(s.isCrossOriginUrl(t)){const e=`importScripts("${t}");`;let a;try{a=new Blob([e],{type:"application/javascript"})}catch(t){const n=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder);n.append(e),a=n.getBlob("application/javascript")}t=(window.URL||window.webkitURL).createObjectURL(a)}return t}let se;function ue(e){const t=new Worker((n.defined(se)||(se=le("Workers/cesiumWorkerBootstrapper.js")),se));t.postMessage=a.defaultValue(t.webkitPostMessage,t.postMessage);const r={loaderConfig:{paths:{Workers:p.buildModuleUrl("Workers")},baseUrl:p.buildModuleUrl.getCesiumBaseUrl().url},workerModule:e._workerPath};return t.postMessage(r),t.onmessage=function(t){oe(e,t.data)},t}function ce(e,t){const n=new s.Uri(e);this._workerPath=0!==n.scheme().length&&0===n.fragment().length?e:ce._workerModulePrefix+e,this._maximumActiveTasks=a.defaultValue(t,Number.POSITIVE_INFINITY),this._activeTasks=0,this._deferreds={},this._nextID=0}const me=[];function fe(){}let pe;function de(e){let t;if(e instanceof ArrayBuffer||ArrayBuffer.isView(e))t=Promise.resolve(e);else{t=s.Resource.createIfNeeded(e).fetchArrayBuffer()}return t.then((function(e){return fe.transcode(e,pe)}))}function he(e,t,a,n,r,i,o,l,s,u,c){this._context=e,this._texture=t,this._textureTarget=a,this._targetFace=n,this._pixelDatatype=o,this._internalFormat=r,this._pixelFormat=i,this._size=l,this._preMultiplyAlpha=s,this._flipY=u,this._initialized=c}function _e(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).context,r=e.source;let i;if(n.defined(r)){const e=[r.positiveX,r.negativeX,r.positiveY,r.negativeY,r.positiveZ,r.negativeZ];i=e[0].width,e[0].height}else i=e.width,e.height;const o=i,l=a.defaultValue(e.pixelDatatype,y.PixelDatatype.UNSIGNED_BYTE),s=a.defaultValue(e.pixelFormat,y.PixelFormat.RGBA),u=y.PixelFormat.toInternalFormat(s,l,t),c=6*y.PixelFormat.textureSizeInBytes(s,l,o,o),m=e.preMultiplyAlpha||s===y.PixelFormat.RGB||s===y.PixelFormat.LUMINANCE,p=a.defaultValue(e.flipY,!0),d=a.defaultValue(e.skipColorSpaceConversion,!1),h=t._gl,_=h.TEXTURE_CUBE_MAP,g=h.createTexture();function C(e,a,r,c,m){let f=a.arrayBufferView;n.defined(f)||(f=a.bufferView);let p=4;n.defined(f)&&(p=y.PixelFormat.alignmentInBytes(s,l,i)),h.pixelStorei(h.UNPACK_ALIGNMENT,p),m?h.pixelStorei(h.UNPACK_COLORSPACE_CONVERSION_WEBGL,h.NONE):h.pixelStorei(h.UNPACK_COLORSPACE_CONVERSION_WEBGL,h.BROWSER_DEFAULT_WEBGL),n.defined(f)?(h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,!1),c&&(f=y.PixelFormat.flipY(f,s,l,o,o)),h.texImage2D(e,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),f)):(h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r),h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL,c),h.texImage2D(e,0,u,s,y.PixelDatatype.toWebGLConstant(l,t),a))}h.activeTexture(h.TEXTURE0),h.bindTexture(_,g),n.defined(r)?(C(h.TEXTURE_CUBE_MAP_POSITIVE_X,r.positiveX,m,p,d),C(h.TEXTURE_CUBE_MAP_NEGATIVE_X,r.negativeX,m,p,d),C(h.TEXTURE_CUBE_MAP_POSITIVE_Y,r.positiveY,m,p,d),C(h.TEXTURE_CUBE_MAP_NEGATIVE_Y,r.negativeY,m,p,d),C(h.TEXTURE_CUBE_MAP_POSITIVE_Z,r.positiveZ,m,p,d),C(h.TEXTURE_CUBE_MAP_NEGATIVE_Z,r.negativeZ,m,p,d)):(h.texImage2D(h.TEXTURE_CUBE_MAP_POSITIVE_X,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),null),h.texImage2D(h.TEXTURE_CUBE_MAP_NEGATIVE_X,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),null),h.texImage2D(h.TEXTURE_CUBE_MAP_POSITIVE_Y,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),null),h.texImage2D(h.TEXTURE_CUBE_MAP_NEGATIVE_Y,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),null),h.texImage2D(h.TEXTURE_CUBE_MAP_POSITIVE_Z,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),null),h.texImage2D(h.TEXTURE_CUBE_MAP_NEGATIVE_Z,0,u,o,o,0,s,y.PixelDatatype.toWebGLConstant(l,t),null)),h.bindTexture(_,null),this._context=t,this._textureFilterAnisotropic=t._textureFilterAnisotropic,this._textureTarget=_,this._texture=g,this._pixelFormat=s,this._pixelDatatype=l,this._size=o,this._hasMipmap=!1,this._sizeInBytes=c,this._preMultiplyAlpha=m,this._flipY=p,this._sampler=void 0;const T=n.defined(r);this._positiveX=new he(t,g,_,h.TEXTURE_CUBE_MAP_POSITIVE_X,u,s,l,o,m,p,T),this._negativeX=new he(t,g,_,h.TEXTURE_CUBE_MAP_NEGATIVE_X,u,s,l,o,m,p,T),this._positiveY=new he(t,g,_,h.TEXTURE_CUBE_MAP_POSITIVE_Y,u,s,l,o,m,p,T),this._negativeY=new he(t,g,_,h.TEXTURE_CUBE_MAP_NEGATIVE_Y,u,s,l,o,m,p,T),this._positiveZ=new he(t,g,_,h.TEXTURE_CUBE_MAP_POSITIVE_Z,u,s,l,o,m,p,T),this._negativeZ=new he(t,g,_,h.TEXTURE_CUBE_MAP_NEGATIVE_Z,u,s,l,o,m,p,T),this.sampler=n.defined(e.sampler)?e.sampler:new f.Sampler}ce.prototype.scheduleTask=function(e,t){if(n.defined(this._worker)||(this._worker=ue(this)),this._activeTasks>=this._maximumActiveTasks)return;++this._activeTasks;const a=this;return Promise.resolve(re()).then((function(r){n.defined(t)?r||(t.length=0):t=me;const i=a._nextID++,o=d.defer();return a._deferreds[i]=o,a._worker.postMessage({id:i,parameters:e,canTransferArrayBuffer:r},t),o.promise}))},ce.prototype.initWebAssemblyModule=function(e){n.defined(this._worker)||(this._worker=ue(this));const t=d.defer(),a=this,r=this._worker;return function(e,t){const a={modulePath:void 0,wasmBinaryFile:void 0,wasmBinary:void 0};if(!p.FeatureDetection.supportsWebAssembly()){if(!n.defined(t.fallbackModulePath))throw new h.RuntimeError(`This browser does not support Web Assembly, and no backup module was provided for ${e._workerPath}`);return a.modulePath=p.buildModuleUrl(t.fallbackModulePath),Promise.resolve(a)}return a.modulePath=p.buildModuleUrl(t.modulePath),a.wasmBinaryFile=p.buildModuleUrl(t.wasmBinaryFile),s.Resource.fetchArrayBuffer({url:a.wasmBinaryFile}).then((function(e){return a.wasmBinary=e,a}))}(this,e).then((function(e){return Promise.resolve(re()).then((function(i){let o;const l=e.wasmBinary;n.defined(l)&&i&&(o=[l]),r.onmessage=function(e){r.onmessage=function(e){oe(a,e.data)},t.resolve(e.data)},r.postMessage({webAssemblyConfig:e},o)}))})),t.promise},ce.prototype.isDestroyed=function(){return!1},ce.prototype.destroy=function(){return n.defined(this._worker)&&this._worker.terminate(),f.destroyObject(this)},ce.taskCompletedEvent=ie,ce._defaultWorkerModulePrefix="Workers/",ce._workerModulePrefix=ce._defaultWorkerModulePrefix,ce._canTransferArrayBuffer=void 0,fe._transcodeTaskProcessor=new ce("transcodeKTX2",Number.POSITIVE_INFINITY),fe._readyPromise=void 0,fe.transcode=function(e,t){return n.defined(fe._readyPromise)||function(){const e=fe._transcodeTaskProcessor.initWebAssemblyModule({modulePath:"ThirdParty/Workers/basis_transcoder.js",wasmBinaryFile:"ThirdParty/basis_transcoder.wasm"}).then((function(){return fe._transcodeTaskProcessor}));fe._readyPromise=e}(),fe._readyPromise.then((function(a){let n;if(e instanceof ArrayBuffer){const r=new Uint8Array(e);return n={supportedTargetFormats:t,ktx2Buffer:r},a.scheduleTask(n,[e])}return n={supportedTargetFormats:t,ktx2Buffer:e},a.scheduleTask(n,[e.buffer])})).then((function(e){const t=e.length,a=Object.keys(e[0]),n=a.length;let r;for(r=0;r<t;r++){const t=e[r];for(let e=0;e<n;e++){const n=t[a[e]];t[a[e]]=new ne(n.internalFormat,n.datatype,n.width,n.height,n.levelBuffer)}}if(1===n){for(r=0;r<t;++r)e[r]=e[r][a[0]];1===t&&(e=e[0])}return e})).catch((function(e){throw e}))},de.setKTX2SupportedFormats=function(e,t,a,n,r,i){pe={s3tc:e,pvrtc:t,astc:a,etc:n,etc1:r,bc7:i}},Object.defineProperties(he.prototype,{pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},_target:{get:function(){return this._targetFace}}}),he.prototype.copyFrom=function(e){const t=a.defaultValue(e.xOffset,0),r=a.defaultValue(e.yOffset,0),i=e.source,o=this._context._gl,l=this._textureTarget,s=this._targetFace;o.activeTexture(o.TEXTURE0),o.bindTexture(l,this._texture);const u=i.width,c=i.height;let m=i.arrayBufferView;const f=this._size,p=this._pixelFormat,d=this._internalFormat,h=this._pixelDatatype,_=this._preMultiplyAlpha,g=this._flipY,C=a.defaultValue(e.skipColorSpaceConversion,!1);let T=4;n.defined(m)&&(T=y.PixelFormat.alignmentInBytes(p,h,u)),o.pixelStorei(o.UNPACK_ALIGNMENT,T),C?o.pixelStorei(o.UNPACK_COLORSPACE_CONVERSION_WEBGL,o.NONE):o.pixelStorei(o.UNPACK_COLORSPACE_CONVERSION_WEBGL,o.BROWSER_DEFAULT_WEBGL);let b=!1;if(!this._initialized){if(0===t&&0===r&&u===f&&c===f)n.defined(m)?(o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL,!1),g&&(m=y.PixelFormat.flipY(m,p,h,f,f)),o.texImage2D(s,0,d,f,f,0,p,y.PixelDatatype.toWebGLConstant(h,this._context),m)):(o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,_),o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL,g),o.texImage2D(s,0,d,p,y.PixelDatatype.toWebGLConstant(h,this._context),i)),b=!0;else{o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL,!1);const e=y.PixelFormat.createTypedArray(p,h,f,f);o.texImage2D(s,0,d,f,f,0,p,y.PixelDatatype.toWebGLConstant(h,this._context),e)}this._initialized=!0}b||(n.defined(m)?(o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL,!1),g&&(m=y.PixelFormat.flipY(m,p,h,u,c)),o.texSubImage2D(s,0,t,r,u,c,p,y.PixelDatatype.toWebGLConstant(h,this._context),m)):(o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,_),o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL,g),o.texSubImage2D(s,0,t,r,p,y.PixelDatatype.toWebGLConstant(h,this._context),i))),o.bindTexture(l,null)},he.prototype.copyFromFramebuffer=function(e,t,n,r,i,o){e=a.defaultValue(e,0),t=a.defaultValue(t,0),n=a.defaultValue(n,0),r=a.defaultValue(r,0),i=a.defaultValue(i,this._size),o=a.defaultValue(o,this._size);const l=this._context._gl,s=this._textureTarget;l.activeTexture(l.TEXTURE0),l.bindTexture(s,this._texture),l.copyTexSubImage2D(this._targetFace,0,e,t,n,r,i,o),l.bindTexture(s,null),this._initialized=!0},he.prototype.destroy=function(){},Object.defineProperties(_e.prototype,{positiveX:{get:function(){return this._positiveX}},negativeX:{get:function(){return this._negativeX}},positiveY:{get:function(){return this._positiveY}},negativeY:{get:function(){return this._negativeY}},positiveZ:{get:function(){return this._positiveZ}},negativeZ:{get:function(){return this._negativeZ}},sampler:{get:function(){return this._sampler},set:function(e){let t=e.minificationFilter,a=e.magnificationFilter;const r=t===f.TextureMinificationFilter.NEAREST_MIPMAP_NEAREST||t===f.TextureMinificationFilter.NEAREST_MIPMAP_LINEAR||t===f.TextureMinificationFilter.LINEAR_MIPMAP_NEAREST||t===f.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,i=this._context,o=this._pixelDatatype;(o===y.PixelDatatype.FLOAT&&!i.textureFloatLinear||o===y.PixelDatatype.HALF_FLOAT&&!i.textureHalfFloatLinear)&&(t=r?f.TextureMinificationFilter.NEAREST_MIPMAP_NEAREST:f.TextureMinificationFilter.NEAREST,a=f.TextureMagnificationFilter.NEAREST);const l=i._gl,s=this._textureTarget;l.activeTexture(l.TEXTURE0),l.bindTexture(s,this._texture),l.texParameteri(s,l.TEXTURE_MIN_FILTER,t),l.texParameteri(s,l.TEXTURE_MAG_FILTER,a),l.texParameteri(s,l.TEXTURE_WRAP_S,e.wrapS),l.texParameteri(s,l.TEXTURE_WRAP_T,e.wrapT),n.defined(this._textureFilterAnisotropic)&&l.texParameteri(s,this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,e.maximumAnisotropy),l.bindTexture(s,null),this._sampler=e}},pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},width:{get:function(){return this._size}},height:{get:function(){return this._size}},sizeInBytes:{get:function(){return this._hasMipmap?Math.floor(4*this._sizeInBytes/3):this._sizeInBytes}},preMultiplyAlpha:{get:function(){return this._preMultiplyAlpha}},flipY:{get:function(){return this._flipY}},_target:{get:function(){return this._textureTarget}}}),_e.prototype.generateMipmap=function(e){e=a.defaultValue(e,f.MipmapHint.DONT_CARE),this._hasMipmap=!0;const t=this._context._gl,n=this._textureTarget;t.hint(t.GENERATE_MIPMAP_HINT,e),t.activeTexture(t.TEXTURE0),t.bindTexture(n,this._texture),t.generateMipmap(n),t.bindTexture(n,null)},_e.prototype.isDestroyed=function(){return!1},_e.prototype.destroy=function(){return this._context._gl.deleteTexture(this._texture),this._positiveX=f.destroyObject(this._positiveX),this._negativeX=f.destroyObject(this._negativeX),this._positiveY=f.destroyObject(this._positiveY),this._negativeY=f.destroyObject(this._negativeY),this._positiveZ=f.destroyObject(this._positiveZ),this._negativeZ=f.destroyObject(this._negativeZ),f.destroyObject(this)};function ge(e){this.type=void 0,this.shaderSource=void 0,this.materials=void 0,this.uniforms=void 0,this._uniforms=void 0,this.translucent=void 0,this._minificationFilter=a.defaultValue(e.minificationFilter,f.TextureMinificationFilter.LINEAR),this._magnificationFilter=a.defaultValue(e.magnificationFilter,f.TextureMagnificationFilter.LINEAR),this._strict=void 0,this._template=void 0,this._count=void 0,this._texturePaths={},this._loadedImages=[],this._loadedCubeMaps=[],this._textures={},this._updateFunctions=[],this._defaultTexture=void 0,function(e,t){let r;e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT),t._strict=a.defaultValue(e.strict,!1),t._count=a.defaultValue(e.count,0),t._template=s.clone(a.defaultValue(e.fabric,a.defaultValue.EMPTY_OBJECT)),t._template.uniforms=s.clone(a.defaultValue(t._template.uniforms,a.defaultValue.EMPTY_OBJECT)),t._template.materials=s.clone(a.defaultValue(t._template.materials,a.defaultValue.EMPTY_OBJECT)),t.type=n.defined(t._template.type)?t._template.type:f.createGuid(),t.shaderSource="",t.materials={},t.uniforms={},t._uniforms={},t._translucentFunctions=[];const i=ge._materialCache.getMaterial(t.type);if(n.defined(i)){const e=s.clone(i.fabric,!0);t._template=u.combine(t._template,e,!0),r=i.translucent}(function(e){const t=e._template,a=t.uniforms,n=t.materials,r=t.components;ye(t,be,Ce,!0),ye(r,xe,Ce,!0);const i=[];for(const e in n)n.hasOwnProperty(e)&&i.push(e);ye(a,i,Te,!1)})(t),n.defined(i)||ge._materialCache.addMaterial(t.type,t);(function(e){const t=e._template.components,a=e._template.source;if(n.defined(a))e.shaderSource+=`${a}\n`;else{if(e.shaderSource+="czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n",e.shaderSource+="czm_material material = czm_getDefaultMaterial(materialInput);\n",n.defined(t)){const a=Object.keys(e._template.materials).length>0;for(const n in t)if(t.hasOwnProperty(n))if("diffuse"===n||"emission"===n){const r=a&&ve(t[n],e)?t[n]:`czm_gammaCorrect(${t[n]})`;e.shaderSource+=`material.${n} = ${r}; \n`}else e.shaderSource+="alpha"===n?`material.alpha = ${t.alpha}; \n`:`material.${n} = ${t[n]};\n`}e.shaderSource+="return material;\n}\n"}})(t),function(e){const t=e._template.uniforms;for(const a in t)t.hasOwnProperty(a)&&Ae(e,a)}(t),function(e){const t=e._strict,a=e._template.materials;for(const n in a)if(a.hasOwnProperty(n)){const r=new ge({strict:t,fabric:a[n],count:e._count});e._count=r._count,e._uniforms=u.combine(e._uniforms,r._uniforms,!0),e.materials[n]=r,e._translucentFunctions=e._translucentFunctions.concat(r._translucentFunctions);const i="czm_getMaterial",o=`${i}_${e._count++}`;Pe(r,i,o),e.shaderSource=r.shaderSource+e.shaderSource;Pe(e,n,`${o}(materialInput)`)}}(t);const o=0===t._translucentFunctions.length||void 0;if(r=a.defaultValue(r,o),r=a.defaultValue(e.translucent,r),n.defined(r))if("function"==typeof r){const e=function(){return r(t)};t._translucentFunctions.push(e)}else t._translucentFunctions.push(r)}(e,this),Object.defineProperties(this,{type:{value:this.type,writable:!1}}),n.defined(ge._uniformList[this.type])||(ge._uniformList[this.type]=Object.keys(this._uniforms))}function ye(e,t,a,r){if(n.defined(e))for(const n in e)if(e.hasOwnProperty(n)){const e=-1!==t.indexOf(n);(r&&!e||!r&&e)&&a(n,t)}}function Ce(e,t){}function Te(e,t){}ge._uniformList={},ge.fromType=function(e,t){const a=new ge({fabric:{type:e}});if(n.defined(t))for(const e in t)t.hasOwnProperty(e)&&(a.uniforms[e]=t[e]);return a},ge.prototype.isTranslucent=function(){if(n.defined(this.translucent))return"function"==typeof this.translucent?this.translucent():this.translucent;let e=!0;const t=this._translucentFunctions,a=t.length;for(let n=0;n<a;++n){const a=t[n];if(e="function"==typeof a?e&&a():e&&a,!e)break}return e},ge.prototype.update=function(e){let t,a;this._defaultTexture=e.defaultTexture;const r=this._loadedImages;let i=r.length;for(t=0;t<i;++t){const i=r[t];a=i.id;let o,l=i.image;Array.isArray(l)&&(o=l.slice(1,l.length).map((function(e){return e.bufferView})),l=l[0]);const s=new f.Sampler({minificationFilter:this._minificationFilter,magnificationFilter:this._magnificationFilter});let u;u=n.defined(l.internalFormat)?new f.Texture({context:e,pixelFormat:l.internalFormat,width:l.width,height:l.height,source:{arrayBufferView:l.bufferView,mipLevels:o},sampler:s}):new f.Texture({context:e,source:l,sampler:s}),this._minificationFilter==f.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR&&u.generateMipmap();const c=this._textures[a];n.defined(c)&&c!==this._defaultTexture&&c.destroy(),this._textures[a]=u;const m=`${a}Dimensions`;if(this.uniforms.hasOwnProperty(m)){const e=this.uniforms[m];e.x=u._width,e.y=u._height}}r.length=0;const o=this._loadedCubeMaps;for(i=o.length,t=0;t<i;++t){const n=o[t];a=n.id;const r=n.images,i=new _e({context:e,source:{positiveX:r[0],negativeX:r[1],positiveY:r[2],negativeY:r[3],positiveZ:r[4],negativeZ:r[5]},sampler:new f.Sampler({minificationFilter:this._minificationFilter,magnificationFilter:this._magnificationFilter})});this._textures[a]=i}o.length=0;const l=this._updateFunctions;for(i=l.length,t=0;t<i;++t)l[t](this,e);const s=this.materials;for(const t in s)s.hasOwnProperty(t)&&s[t].update(e)},ge.prototype.isDestroyed=function(){return!1},ge.prototype.destroy=function(){const e=this._textures;for(const t in e)if(e.hasOwnProperty(t)){const a=e[t];a!==this._defaultTexture&&a.destroy()}const t=this.materials;for(const e in t)t.hasOwnProperty(e)&&t[e].destroy();return f.destroyObject(this)};const be=["type","materials","uniforms","components","source"],xe=["diffuse","specular","shininess","normal","emission","alpha"];function ve(e,t){const a=t._template.materials;for(const t in a)if(a.hasOwnProperty(t)&&e.indexOf(t)>-1)return!0;return!1}const Ee={mat2:_.Matrix2,mat3:g.Matrix3,mat4:_.Matrix4},Ie=/\.ktx2$/i;function Ae(e,t){e._strict;const a=e._template.uniforms,r=a[t],i=function(e){let t=e.type;if(!n.defined(t)){const a=typeof e;if("number"===a)t="float";else if("boolean"===a)t="bool";else if("string"===a||e instanceof s.Resource||e instanceof HTMLCanvasElement||e instanceof HTMLImageElement)t=/^([rgba]){1,4}$/i.test(e)?"channels":e===ge.DefaultCubeMapId?"samplerCube":"sampler2D";else if("object"===a)if(Array.isArray(e))4!==e.length&&9!==e.length&&16!==e.length||(t=`mat${Math.sqrt(e.length)}`);else{let a=0;for(const t in e)e.hasOwnProperty(t)&&(a+=1);a>=2&&a<=4?t=`vec${a}`:6===a&&(t="samplerCube")}}return t}(r);if("channels"===i)Pe(e,t,r,!1);else{if("sampler2D"===i){const n=`${t}Dimensions`;(function(e,t,a){return Pe(e,t,t,a)})(e,n)>0&&(a[n]={type:"ivec3",x:1,y:1},Ae(e,n))}if(!new RegExp(`uniform\\s+${i}\\s+${t}\\s*;`).test(e.shaderSource)){const a=`uniform ${i} ${t};`;e.shaderSource=a+e.shaderSource}const o=`${t}_${e._count++}`;if(Pe(e,t,o),e.uniforms[t]=r,"sampler2D"===i)e._uniforms[o]=function(){return e._textures[t]},e._updateFunctions.push(function(e){let t;return function(a,r){const i=a.uniforms,o=i[e],l=t!==o,u=!n.defined(o)||o===ge.DefaultImageId;t=o;let c,m,p=a._textures[e];if(o instanceof HTMLVideoElement){if(o.readyState>=2){if(l&&n.defined(p)&&(p!==r.defaultTexture&&p.destroy(),p=void 0),!n.defined(p)||p===r.defaultTexture){const t=new f.Sampler({minificationFilter:a._minificationFilter,magnificationFilter:a._magnificationFilter});return p=new f.Texture({context:r,source:o,sampler:t}),void(a._textures[e]=p)}p.copyFrom({source:o})}else n.defined(p)||(a._textures[e]=r.defaultTexture);return}if(o instanceof f.Texture&&o!==p){a._texturePaths[e]=void 0;const t=a._textures[e];return n.defined(t)&&t!==a._defaultTexture&&t.destroy(),a._textures[e]=o,c=`${e}Dimensions`,void(i.hasOwnProperty(c)&&(m=i[c],m.x=o._width,m.y=o._height))}if(l&&n.defined(p)&&u&&(p!==a._defaultTexture&&p.destroy(),p=void 0),n.defined(p)||(a._texturePaths[e]=void 0,p=a._textures[e]=a._defaultTexture,c=`${e}Dimensions`,i.hasOwnProperty(c)&&(m=i[c],m.x=p._width,m.y=p._height)),u)return;const d=o instanceof s.Resource;if(!n.defined(a._texturePaths[e])||d&&o.url!==a._texturePaths[e].url||!d&&o!==a._texturePaths[e]){if("string"==typeof o||d){const t=d?o:s.Resource.createIfNeeded(o);let r;r=Ie.test(t.url)?de(t.url):t.fetchImage(),Promise.resolve(r).then((function(t){a._loadedImages.push({id:e,image:t})})).catch((function(){n.defined(p)&&p!==a._defaultTexture&&p.destroy(),a._textures[e]=a._defaultTexture}))}else(o instanceof HTMLCanvasElement||o instanceof HTMLImageElement)&&a._loadedImages.push({id:e,image:o});a._texturePaths[e]=o}}}(t));else if("samplerCube"===i)e._uniforms[o]=function(){return e._textures[t]},e._updateFunctions.push(function(e){return function(t,a){const r=t.uniforms[e];if(r instanceof _e){const a=t._textures[e];return a!==t._defaultTexture&&a.destroy(),t._texturePaths[e]=void 0,void(t._textures[e]=r)}if(n.defined(t._textures[e])||(t._texturePaths[e]=void 0,t._textures[e]=a.defaultCubeMap),r===ge.DefaultCubeMapId)return;const i=r.positiveX+r.negativeX+r.positiveY+r.negativeY+r.positiveZ+r.negativeZ;if(i!==t._texturePaths[e]){const a=[s.Resource.createIfNeeded(r.positiveX).fetchImage(),s.Resource.createIfNeeded(r.negativeX).fetchImage(),s.Resource.createIfNeeded(r.positiveY).fetchImage(),s.Resource.createIfNeeded(r.negativeY).fetchImage(),s.Resource.createIfNeeded(r.positiveZ).fetchImage(),s.Resource.createIfNeeded(r.negativeZ).fetchImage()];Promise.all(a).then((function(a){t._loadedCubeMaps.push({id:e,images:a})})),t._texturePaths[e]=i}}}(t));else if(-1!==i.indexOf("mat")){const a=new Ee[i];e._uniforms[o]=function(){return Ee[i].fromColumnMajorArray(e.uniforms[t],a)}}else e._uniforms[o]=function(){return e.uniforms[t]}}}function Pe(e,t,n,r){r=a.defaultValue(r,!0);let i=0;const o=new RegExp(`([\\w${r?".":""}])?`+t+"([\\w])?","g");return e.shaderSource=e.shaderSource.replace(o,(function(e,t,a){return t||a?e:(i+=1,n)})),i}function Se(e){e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT);const t=a.defaultValue(e.translucent,!0),r=a.defaultValue(e.aboveGround,!1);this.material=n.defined(e.material)?e.material:ge.fromType(ge.ColorType),this.translucent=a.defaultValue(e.translucent,!0),this._vertexShaderSource=a.defaultValue(e.vertexShaderSource,j),this._fragmentShaderSource=a.defaultValue(e.fragmentShaderSource,X),this._renderState=ae.getDefaultRenderState(t,!r,e.renderState),this._closed=!1,this._flat=a.defaultValue(e.flat,!1),this._faceForward=a.defaultValue(e.faceForward,r),this._aboveGround=r}ge._materialCache={_materials:{},addMaterial:function(e,t){this._materials[e]=t},getMaterial:function(e){return this._materials[e]}},ge.DefaultImageId="czm_defaultImage",ge.DefaultCubeMapId="czm_defaultCubeMap",ge.ColorType="Color",ge._materialCache.addMaterial(ge.ColorType,{fabric:{type:ge.ColorType,uniforms:{color:new e.Color(1,0,0,.5)},components:{diffuse:"color.rgb",alpha:"color.a"}},translucent:function(e){return e.uniforms.color.alpha<1}}),ge.ImageType="Image",ge._materialCache.addMaterial(ge.ImageType,{fabric:{type:ge.ImageType,uniforms:{image:ge.DefaultImageId,repeat:new m.Cartesian2(1,1),color:new e.Color(1,1,1,1)},components:{diffuse:"texture(image, fract(repeat * materialInput.st)).rgb * color.rgb",alpha:"texture(image, fract(repeat * materialInput.st)).a * color.a"}},translucent:function(e){return e.uniforms.color.alpha<1}}),ge.RotationImageType="RotationImage",ge._materialCache.addMaterial(ge.RotationImageType,{fabric:{type:ge.ImageType,uniforms:{image:ge.DefaultImageId,repeat:new m.Cartesian2(1,1),color:new e.Color(1,1,1,1)},source:"czm_material czm_getMaterial(czm_materialInput materialInput){czm_material material = czm_getDefaultMaterial(materialInput);mat2 tran = mat2(v_czm_batchTable_rotationMat);vec2 st = fract(repeat * v_czm_batchTable_repeat * vec2(materialInput.st.s * v_czm_batchTable_ratio,materialInput.st.t) * tran);vec4 rampColor = texture(image, st);material.diffuse = rampColor.rgb * color.rgb;material.alpha = rampColor.a * color.a;return material;}"},translucent:function(e){return e.uniforms.color.alpha<1}}),ge.DiffuseMapType="DiffuseMap",ge._materialCache.addMaterial(ge.DiffuseMapType,{fabric:{type:ge.DiffuseMapType,uniforms:{image:ge.DefaultImageId,channels:"rgb",repeat:new m.Cartesian2(1,1)},components:{diffuse:"texture(image, fract(repeat * materialInput.st)).channels"}},translucent:!1}),ge.AlphaMapType="AlphaMap",ge._materialCache.addMaterial(ge.AlphaMapType,{fabric:{type:ge.AlphaMapType,uniforms:{image:ge.DefaultImageId,channel:"a",repeat:new m.Cartesian2(1,1)},components:{alpha:"texture(image, fract(repeat * materialInput.st)).channel"}},translucent:!0}),ge.SpecularMapType="SpecularMap",ge._materialCache.addMaterial(ge.SpecularMapType,{fabric:{type:ge.SpecularMapType,uniforms:{image:ge.DefaultImageId,channel:"r",repeat:new m.Cartesian2(1,1)},components:{specular:"texture(image, fract(repeat * materialInput.st)).channel"}},translucent:!1}),ge.EmissionMapType="EmissionMap",ge._materialCache.addMaterial(ge.EmissionMapType,{fabric:{type:ge.EmissionMapType,uniforms:{image:ge.DefaultImageId,channels:"rgb",repeat:new m.Cartesian2(1,1)},components:{emission:"texture(image, fract(repeat * materialInput.st)).channels"}},translucent:!1}),ge.BumpMapType="BumpMap",ge._materialCache.addMaterial(ge.BumpMapType,{fabric:{type:ge.BumpMapType,uniforms:{image:ge.DefaultImageId,channel:"r",strength:.8,repeat:new m.Cartesian2(1,1)},source:"uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nvec2 centerPixel = fract(repeat * st);\nfloat centerBump = texture(image, centerPixel).channel;\nfloat imageWidth = float(imageDimensions.x);\nvec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\nfloat rightBump = texture(image, rightPixel).channel;\nfloat imageHeight = float(imageDimensions.y);\nvec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\nfloat topBump = texture(image, leftPixel).channel;\nvec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\nvec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\nmaterial.normal = normalEC;\nmaterial.diffuse = vec3(0.01);\nreturn material;\n}\n"},translucent:!1}),ge.NormalMapType="NormalMap",ge._materialCache.addMaterial(ge.NormalMapType,{fabric:{type:ge.NormalMapType,uniforms:{image:ge.DefaultImageId,channels:"rgb",strength:.8,repeat:new m.Cartesian2(1,1)},source:"uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec4 textureValue = texture(image, fract(repeat * materialInput.st));\nvec3 normalTangentSpace = textureValue.channels;\nnormalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\nnormalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\nnormalTangentSpace = normalize(normalTangentSpace);\nvec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\nmaterial.normal = normalEC;\nreturn material;\n}\n"},translucent:!1}),ge.GridType="Grid",ge._materialCache.addMaterial(ge.GridType,{fabric:{type:ge.GridType,uniforms:{color:new e.Color(0,1,0,1),cellAlpha:.1,lineCount:new m.Cartesian2(8,8),lineThickness:new m.Cartesian2(1,1),lineOffset:new m.Cartesian2(0,0)},source:"uniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\nscaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\nfloat scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\nscaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\nfloat value;\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\nconst float fuzz = 1.2;\nvec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;\nvec2 dx = abs(dFdx(st));\nvec2 dy = abs(dFdy(st));\nvec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\nvalue = min(\nsmoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\nsmoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\nconst float fuzz = 0.05;\nvec2 range = 0.5 - (lineThickness * 0.05);\nvalue = min(\n1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\nfloat dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\nfloat sRim = smoothstep(0.8, 1.0, dRim);\nvalue *= (1.0 - sRim);\nvec4 halfColor;\nhalfColor.rgb = color.rgb * 0.5;\nhalfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));\nhalfColor = czm_gammaCorrect(halfColor);\nmaterial.diffuse = halfColor.rgb;\nmaterial.emission = halfColor.rgb;\nmaterial.alpha = halfColor.a;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.color.alpha<1||t.cellAlpha<1}}),ge.StripeType="Stripe",ge._materialCache.addMaterial(ge.StripeType,{fabric:{type:ge.StripeType,uniforms:{horizontal:!0,evenColor:new e.Color(1,1,1,.5),oddColor:new e.Color(0,0,1,.5),offset:0,repeat:5},source:"uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\nfloat value = fract((coord - offset) * (repeat * 0.5));\nfloat dist = min(value, min(abs(value - 0.5), 1.0 - value));\nvec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\nvec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\ncolor = czm_gammaCorrect(color);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.evenColor.alpha<1||t.oddColor.alpha<1}}),ge.CheckerboardType="Checkerboard",ge._materialCache.addMaterial(ge.CheckerboardType,{fabric:{type:ge.CheckerboardType,uniforms:{lightColor:new e.Color(1,1,1,.5),darkColor:new e.Color(0,0,0,.5),repeat:new m.Cartesian2(5,5)},source:"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);\nfloat scaledWidth = fract(repeat.s * st.s);\nscaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\nfloat scaledHeight = fract(repeat.t * st.t);\nscaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\nfloat value = min(scaledWidth, scaledHeight);\nvec4 currentColor = mix(lightColor, darkColor, b);\nvec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\ncolor = czm_gammaCorrect(color);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.lightColor.alpha<1||t.darkColor.alpha<1}}),ge.DotType="Dot",ge._materialCache.addMaterial(ge.DotType,{fabric:{type:ge.DotType,uniforms:{lightColor:new e.Color(1,1,0,.75),darkColor:new e.Color(0,1,1,.75),repeat:new m.Cartesian2(5,5)},source:"uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));\nvec4 color = mix(lightColor, darkColor, b);\ncolor = czm_gammaCorrect(color);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.lightColor.alpha<1||t.darkColor.alpha<1}}),ge.WaterType="Water",ge._materialCache.addMaterial(ge.WaterType,{fabric:{type:ge.WaterType,uniforms:{baseWaterColor:new e.Color(.2,.3,.6,1),blendColor:new e.Color(0,1,.699,1),specularMap:ge.DefaultImageId,normalMap:ge.DefaultImageId,frequency:10,animationSpeed:.01,amplitude:1,specularIntensity:.5,fadeFactor:1},source:"uniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat time = czm_frameNumber * animationSpeed;\nfloat fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\nfloat specularMapValue = texture(specularMap, materialInput.st).r;\nvec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\nvec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\nnormalTangentSpace.xy /= fade;\nnormalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\nnormalTangentSpace = normalize(normalTangentSpace);\nfloat tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\nmaterial.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;\nmaterial.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\nmaterial.diffuse += (0.1 * tsPerturbationRatio);\nmaterial.diffuse = material.diffuse;\nmaterial.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\nmaterial.specular = specularIntensity;\nmaterial.shininess = 10.0;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.baseWaterColor.alpha<1||t.blendColor.alpha<1}}),ge.WaJueType="WaJue",ge._materialCache.addMaterial(ge.WaJueType,{fabric:{type:ge.WaJueType,source:"czm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nreturn material;\n}\n"},translucent:!1}),ge.RimLightingType="RimLighting",ge._materialCache.addMaterial(ge.RimLightingType,{fabric:{type:ge.RimLightingType,uniforms:{color:new e.Color(1,0,0,.7),rimColor:new e.Color(1,1,1,.4),width:.3},source:"uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\nfloat s = smoothstep(1.0 - width, 1.0, d);\nvec4 outColor = czm_gammaCorrect(color);\nvec4 outRimColor = czm_gammaCorrect(rimColor);\nmaterial.diffuse = outColor.rgb;\nmaterial.emission = outRimColor.rgb * s;\nmaterial.alpha = mix(outColor.a, outRimColor.a, s);\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.color.alpha<1||t.rimColor.alpha<1}}),ge.FadeType="Fade",ge._materialCache.addMaterial(ge.FadeType,{fabric:{type:ge.FadeType,uniforms:{fadeInColor:new e.Color(1,0,0,1),fadeOutColor:new e.Color(0,0,0,0),maximumDistance:.5,repeat:!0,fadeDirection:{x:!0,y:!0},time:new m.Cartesian2(.5,.5)},source:"uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\nfloat getTime(float t, float coord)\n{\nfloat scalar = 1.0 / maximumDistance;\nfloat q  = distance(t, coord) * scalar;\nif (repeat)\n{\nfloat r = distance(t, coord + 1.0) * scalar;\nfloat s = distance(t, coord - 1.0) * scalar;\nq = min(min(r, s), q);\n}\nreturn clamp(q, 0.0, 1.0);\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat s = getTime(time.x, st.s) * fadeDirection.s;\nfloat t = getTime(time.y, st.t) * fadeDirection.t;\nfloat u = length(vec2(s, t));\nvec4 color = mix(fadeInColor, fadeOutColor, u);\ncolor = czm_gammaCorrect(color);\nmaterial.emission = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.fadeInColor.alpha<1||t.fadeOutColor.alpha<1}}),ge.PolylineArrowType="PolylineArrow",ge._materialCache.addMaterial(ge.PolylineArrowType,{fabric:{type:ge.PolylineArrowType,uniforms:{color:new e.Color(1,1,1,1)},source:"uniform vec4 color;\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\nfloat slope = (p0.y - p1.y) / (p0.x - p1.x);\nreturn slope * (x - p0.x) + p0.y;\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\nfloat base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;\n#else\nfloat base = 0.975;\n#endif\nvec2 center = vec2(1.0, 0.5);\nfloat ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\nfloat ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\nfloat halfWidth = 0.15;\nfloat s = step(0.5 - halfWidth, st.t);\ns *= 1.0 - step(0.5 + halfWidth, st.t);\ns *= 1.0 - step(base, st.s);\nfloat t = step(base, materialInput.st.s);\nt *= 1.0 - step(ptOnUpperLine, st.t);\nt *= step(ptOnLowerLine, st.t);\nfloat dist;\nif (st.s < base)\n{\nfloat d1 = abs(st.t - (0.5 - halfWidth));\nfloat d2 = abs(st.t - (0.5 + halfWidth));\ndist = min(d1, d2);\n}\nelse\n{\nfloat d1 = czm_infinity;\nif (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n{\nd1 = abs(st.s - base);\n}\nfloat d2 = abs(st.t - ptOnUpperLine);\nfloat d3 = abs(st.t - ptOnLowerLine);\ndist = min(min(d1, d2), d3);\n}\nvec4 outsideColor = vec4(0.0);\nvec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\nvec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\noutColor = czm_gammaCorrect(outColor);\nmaterial.diffuse = outColor.rgb;\nmaterial.alpha = outColor.a;\nreturn material;\n}\n"},translucent:!0}),ge.PolylineDashType="PolylineDash",ge._materialCache.addMaterial(ge.PolylineDashType,{fabric:{type:ge.PolylineDashType,uniforms:{color:new e.Color(1,0,1,1),gapColor:new e.Color(0,0,0,0),dashLength:16,dashPattern:255},source:"uniform vec4 color;\nuniform vec4 gapColor;\nuniform float dashLength;\nuniform float dashPattern;\nin float v_polylineAngle;\nconst float maskLength = 16.0;\nmat2 rotate(float rad) {\nfloat c = cos(rad);\nfloat s = sin(rad);\nreturn mat2(\nc, s,\n-s, c\n);\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\nfloat dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));\nfloat maskIndex = floor(dashPosition * maskLength);\nfloat maskTest = floor(dashPattern / pow(2.0, maskIndex));\nvec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;\nif (fragColor.a < 0.005) {\ndiscard;\n}\nfragColor = czm_gammaCorrect(fragColor);\nmaterial.emission = fragColor.rgb;\nmaterial.alpha = fragColor.a;\nreturn material;\n}\n"},translucent:!0}),ge.PolylineGlowType="PolylineGlow",ge._materialCache.addMaterial(ge.PolylineGlowType,{fabric:{type:ge.PolylineGlowType,uniforms:{color:new e.Color(0,.5,1,1),glowPower:.25,taperPower:1},source:"uniform vec4 color;\nuniform float glowPower;\nuniform float taperPower;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\nif (taperPower <= 0.99999) {\nglow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));\n}\nvec4 fragColor;\nfragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);\nfragColor.a = clamp(0.0, 1.0, glow) * color.a;\nfragColor = czm_gammaCorrect(fragColor);\nmaterial.emission = fragColor.rgb;\nmaterial.alpha = fragColor.a;\nreturn material;\n}\n"},translucent:!0}),ge.PolylineOutlineType="PolylineOutline",ge._materialCache.addMaterial(ge.PolylineOutlineType,{fabric:{type:ge.PolylineOutlineType,uniforms:{color:new e.Color(1,1,1,1),outlineColor:new e.Color(1,0,0,1),outlineWidth:1},source:"uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\nin float v_width;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec2 st = materialInput.st;\nfloat halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\nfloat b = step(0.5 - halfInteriorWidth, st.t);\nb *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\nfloat d1 = abs(st.t - (0.5 - halfInteriorWidth));\nfloat d2 = abs(st.t - (0.5 + halfInteriorWidth));\nfloat dist = min(d1, d2);\nvec4 currentColor = mix(outlineColor, color, b);\nvec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\noutColor = czm_gammaCorrect(outColor);\nmaterial.diffuse = outColor.rgb;\nmaterial.alpha = outColor.a;\nreturn material;\n}\n"},translucent:function(e){const t=e.uniforms;return t.color.alpha<1||t.outlineColor.alpha<1}}),ge.ElevationContourType="ElevationContour",ge._materialCache.addMaterial(ge.ElevationContourType,{fabric:{type:ge.ElevationContourType,uniforms:{spacing:100,color:new e.Color(1,0,0,1),width:1},source:"uniform vec4 color;\nuniform float spacing;\nuniform float width;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat distanceToContour = mod(materialInput.height, spacing);\n#if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\nfloat dxc = abs(dFdx(materialInput.height));\nfloat dyc = abs(dFdy(materialInput.height));\nfloat dF = max(dxc, dyc) * czm_pixelRatio * width;\nfloat alpha = (distanceToContour < dF) ? 1.0 : 0.0;\n#else\nfloat alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;\n#endif\nvec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));\nmaterial.diffuse = outColor.rgb;\nmaterial.alpha = outColor.a;\nreturn material;\n}\n"},translucent:!1}),ge.ElevationRampType="ElevationRamp",ge._materialCache.addMaterial(ge.ElevationRampType,{fabric:{type:ge.ElevationRampType,uniforms:{image:ge.DefaultImageId,minimumHeight:0,maximumHeight:1e4},source:"uniform sampler2D image;\nuniform float minimumHeight;\nuniform float maximumHeight;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);\nvec4 rampColor = texture(image, vec2(scaledHeight, 0.5));\nrampColor = czm_gammaCorrect(rampColor);\nmaterial.diffuse = rampColor.rgb;\nmaterial.alpha = rampColor.a;\nreturn material;\n}\n"},translucent:!1}),ge.SlopeRampMaterialType="SlopeRamp",ge._materialCache.addMaterial(ge.SlopeRampMaterialType,{fabric:{type:ge.SlopeRampMaterialType,uniforms:{image:ge.DefaultImageId},source:"uniform sampler2D image;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec4 rampColor = texture(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));\nrampColor = czm_gammaCorrect(rampColor);\nmaterial.diffuse = rampColor.rgb;\nmaterial.alpha = rampColor.a;\nreturn material;\n}\n"},translucent:!1}),ge.AspectRampMaterialType="AspectRamp",ge._materialCache.addMaterial(ge.AspectRampMaterialType,{fabric:{type:ge.AspectRampMaterialType,uniforms:{image:ge.DefaultImageId},source:"uniform sampler2D image;\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nvec4 rampColor = texture(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));\nrampColor = czm_gammaCorrect(rampColor);\nmaterial.diffuse = rampColor.rgb;\nmaterial.alpha = rampColor.a;\nreturn material;\n}\n"},translucent:!1}),ge.ElevationBandType="ElevationBand",ge._materialCache.addMaterial(ge.ElevationBandType,{fabric:{type:ge.ElevationBandType,uniforms:{heights:ge.DefaultImageId,colors:ge.DefaultImageId},source:"uniform sampler2D heights;\nuniform sampler2D colors;\nfloat getHeight(int idx, float invTexSize)\n{\nvec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);\n#ifdef OES_texture_float\nreturn texture(heights, uv).x;\n#else\nreturn czm_unpackFloat(texture(heights, uv));\n#endif\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\nczm_material material = czm_getDefaultMaterial(materialInput);\nfloat height = materialInput.height;\nfloat invTexSize = 1.0 / float(heightsDimensions.x);\nfloat minHeight = getHeight(0, invTexSize);\nfloat maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);\nif (height < minHeight || height > maxHeight) {\nmaterial.diffuse = vec3(0.0);\nmaterial.alpha = 0.0;\nreturn material;\n}\nint idxBelow = 0;\nint idxAbove = heightsDimensions.x;\nfloat heightBelow = minHeight;\nfloat heightAbove = maxHeight;\nconst int maxIterations = 16;\nfor (int i = 0; i < maxIterations; i++) {\nif (idxBelow >= idxAbove - 1) {\nbreak;\n}\nint idxMid = (idxBelow + idxAbove) / 2;\nfloat heightTex = getHeight(idxMid, invTexSize);\nif (height > heightTex) {\nidxBelow = idxMid;\nheightBelow = heightTex;\n} else {\nidxAbove = idxMid;\nheightAbove = heightTex;\n}\n}\nfloat lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);\nvec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);\nvec4 color = texture(colors, colorUv);\nif (color.a > 0.0)\n{\ncolor.rgb /= color.a;\n}\ncolor.rgb = czm_gammaCorrect(color.rgb);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nreturn material;\n}\n"},translucent:!0}),Object.defineProperties(Se.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return Se.VERTEX_FORMAT}},flat:{get:function(){return this._flat}},faceForward:{get:function(){return this._faceForward}},aboveGround:{get:function(){return this._aboveGround}}}),Se.VERTEX_FORMAT=l.VertexFormat.POSITION_AND_ST,Se.prototype.getFragmentShaderSource=ae.prototype.getFragmentShaderSource,Se.prototype.isTranslucent=ae.prototype.isTranslucent,Se.prototype.getRenderState=ae.prototype.getRenderState;var Me="in vec3 v_positionEC;\nin vec3 v_normalEC;\nin vec4 v_color;\nvoid main()\n{\nvec3 positionToEyeEC = -v_positionEC;\nvec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\nnormalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\nvec4 color = czm_gammaCorrect(v_color);\nczm_materialInput materialInput;\nmaterialInput.normalEC = normalEC;\nmaterialInput.positionToEyeEC = positionToEyeEC;\nczm_material material = czm_getDefaultMaterial(materialInput);\nmaterial.diffuse = color.rgb;\nmaterial.alpha = color.a;\nout_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n",De="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec3 normal;\nin vec4 color;\nin float batchId;\nout vec3 v_positionEC;\nout vec3 v_normalEC;\nout vec4 v_color;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_positionEC = (czm_modelViewRelativeToEye * p).xyz;\nv_normalEC = czm_normal * normal;\nv_color = color;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n",we="in vec4 v_color;\nvoid main()\n{\nout_FragColor = czm_gammaCorrect(v_color);\n}\n",ze="in vec3 position3DHigh;\nin vec3 position3DLow;\nin vec4 color;\nin float batchId;\nout vec4 v_color;\nvoid main()\n{\nvec4 p = czm_computePosition();\nv_color = color;\ngl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n";function Oe(e){e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT);const t=a.defaultValue(e.translucent,!0),n=a.defaultValue(e.closed,!1),r=a.defaultValue(e.flat,!1),i=r?ze:De,o=r?we:Me,l=r?Oe.FLAT_VERTEX_FORMAT:Oe.VERTEX_FORMAT;this.material=void 0,this.translucent=t,this._vertexShaderSource=a.defaultValue(e.vertexShaderSource,i),this._fragmentShaderSource=a.defaultValue(e.fragmentShaderSource,o),this._renderState=ae.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._vertexFormat=l,this._flat=r,this._faceForward=a.defaultValue(e.faceForward,!n)}function Le(e,a,n){if(this._attributes=a,this._numberOfInstances=n,0===a.length)return;const r=function(e){let a=!1;const n=e.length;for(let r=0;r<n;++r)if(e[r].componentDatatype!==t.ComponentDatatype.UNSIGNED_BYTE){a=!0;break}return a?y.PixelDatatype.FLOAT:y.PixelDatatype.UNSIGNED_BYTE}(a),i=e.floatingPointTexture,o=r===y.PixelDatatype.FLOAT&&!i,l=function(e,a){const n=new Array(e.length);let r=0;const i=e.length;for(let o=0;o<i;++o){const i=e[o].componentDatatype;n[o]=r,i!==t.ComponentDatatype.UNSIGNED_BYTE&&a?r+=4:++r}return n}(a,o),s=function(e,a,n){const r=e.length,i=e[r-1],o=a[r-1];if(o.componentDatatype!==t.ComponentDatatype.UNSIGNED_BYTE&&n)return i+4;return i+1}(l,a,o),u=Math.floor(f.ContextLimits.maximumTextureSize/s),c=Math.min(n,u),p=s*c,d=Math.ceil(n/c),h=1/p,g=.5*h,C=1/d,T=.5*C;this._textureDimensions=new m.Cartesian2(p,d),this._textureStep=new _.Cartesian4(h,g,C,T),this._pixelDatatype=o?y.PixelDatatype.UNSIGNED_BYTE:r,this._packFloats=o,this._offsets=l,this._stride=s,this._texture=void 0;const b=4*p*d;this._batchValues=r!==y.PixelDatatype.FLOAT||o?new Uint8Array(b):new Float32Array(b),this._batchValuesDirty=!1}function Re(e,t){const a=e[t].componentsPerAttribute;return 2===a?m.Cartesian2:3===a?I.Cartesian3:4===a?_.Cartesian4:Number}Object.defineProperties(Oe.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return this._vertexFormat}},flat:{get:function(){return this._flat}},faceForward:{get:function(){return this._faceForward}}}),Oe.VERTEX_FORMAT=l.VertexFormat.POSITION_AND_NORMAL,Oe.FLAT_VERTEX_FORMAT=l.VertexFormat.POSITION_ONLY,Oe.prototype.getFragmentShaderSource=ae.prototype.getFragmentShaderSource,Oe.prototype.isTranslucent=ae.prototype.isTranslucent,Oe.prototype.getRenderState=ae.prototype.getRenderState,Object.defineProperties(Le.prototype,{attributes:{get:function(){return this._attributes}},numberOfInstances:{get:function(){return this._numberOfInstances}}});const Ne=new _.Cartesian4;const Fe=new _.Cartesian4;Le.prototype.getBatchedAttribute=function(e,t,a){const r=this._attributes,i=this._offsets[t],o=4*this._stride*e+4*i;let l;l=this._packFloats&&r[t].componentDatatype!==y.PixelDatatype.UNSIGNED_BYTE?function(e,t,a){let n=_.Cartesian4.unpack(e,t,Ne);const r=_.Cartesian4.unpackFloat(n);n=_.Cartesian4.unpack(e,t+4,Ne);const i=_.Cartesian4.unpackFloat(n);n=_.Cartesian4.unpack(e,t+8,Ne);const o=_.Cartesian4.unpackFloat(n);n=_.Cartesian4.unpack(e,t+12,Ne);const l=_.Cartesian4.unpackFloat(n);return _.Cartesian4.fromElements(r,i,o,l,a)}(this._batchValues,o,Fe):_.Cartesian4.unpack(this._batchValues,o,Fe);const s=Re(r,t);return n.defined(s.fromCartesian4)?s.fromCartesian4(l,a):n.defined(s.clone)?s.clone(l,a):l.x};const Be=[void 0,void 0,new m.Cartesian2,new I.Cartesian3,new _.Cartesian4],Ue=new _.Cartesian4;function Ve(e){return 1===e?"float":`vec${e}`}function ke(e,a){const n=e._attributes[a],r=n.componentsPerAttribute,i=n.functionName,o=Ve(r),l=function(e){return 1===e?".x":2===e?".xy":3===e?".xyz":""}(r);var s="v_"+i;let u=`${o} ${i}(float batchId) \n{ \n    vec2 st = computeSt(batchId); \n    st.x += batchTextureStep.x * float(${e._offsets[a]}); \n`;if(e._packFloats&&n.componentDatatype!==y.PixelDatatype.UNSIGNED_BYTE?u+="vec4 textureValue; \ntextureValue.x = czm_unpackFloat(texture(batchTexture, st)); \ntextureValue.y = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \ntextureValue.z = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \ntextureValue.w = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \n":u+="    vec4 textureValue = texture(batchTexture, st); \n",u+=`    ${o} value = textureValue${l}; \n`,e._pixelDatatype!==y.PixelDatatype.UNSIGNED_BYTE||n.componentDatatype!==t.ComponentDatatype.UNSIGNED_BYTE||n.normalize?e._pixelDatatype===y.PixelDatatype.FLOAT&&n.componentDatatype===t.ComponentDatatype.UNSIGNED_BYTE&&n.normalize&&(u+="value /= 255.0; \n"):u+="value *= 255.0; \n",u+="    return value; \n} \n",-1!=e.NOTGlslAutoAttributeArray().indexOf(i))return u;return"out "+o+" "+s+";\n"+u}function Ge(e,t){var a=e._attributes[t].functionName;return-1!=e.NOTGlslAutoAttributeArray().indexOf(a)?"":"    "+("v_"+a)+" = "+a+"(batchId);\n"}Le.prototype.setBatchedAttribute=function(e,t,a){const r=this._attributes,i=Be[r[t].componentsPerAttribute],o=this.getBatchedAttribute(e,t,i),l=Re(this._attributes,t);if(n.defined(l.equals)?l.equals(o,a):o===a)return;const s=Ue;s.x=n.defined(a.x)?a.x:a,s.y=n.defined(a.y)?a.y:0,s.z=n.defined(a.z)?a.z:0,s.w=n.defined(a.w)?a.w:0;const u=this._offsets[t],c=4*this._stride*e+4*u;this._packFloats&&r[t].componentDatatype!==y.PixelDatatype.UNSIGNED_BYTE?function(e,t,a){let n=_.Cartesian4.packFloat(e.x,Ne);_.Cartesian4.pack(n,t,a),n=_.Cartesian4.packFloat(e.y,n),_.Cartesian4.pack(n,t,a+4),n=_.Cartesian4.packFloat(e.z,n),_.Cartesian4.pack(n,t,a+8),n=_.Cartesian4.packFloat(e.w,n),_.Cartesian4.pack(n,t,a+12)}(s,this._batchValues,c):_.Cartesian4.pack(s,this._batchValues,c),this._batchValuesDirty=!0},Le.prototype.update=function(e){n.defined(this._texture)&&!this._batchValuesDirty||0===this._attributes.length||(this._batchValuesDirty=!1,n.defined(this._texture)||function(e,t){const a=e._textureDimensions;e._texture=new f.Texture({context:t,pixelFormat:y.PixelFormat.RGBA,pixelDatatype:e._pixelDatatype,width:a.x,height:a.y,sampler:f.Sampler.NEAREST,flipY:!1})}(this,e.context),function(e){const t=e._textureDimensions;e._texture.copyFrom({source:{width:t.x,height:t.y,arrayBufferView:e._batchValues}})}(this))},Le.prototype.getUniformMapCallback=function(){const e=this;return function(t){if(0===e._attributes.length)return t;const a={batchTexture:function(){return e._texture},batchTextureDimensions:function(){return e._textureDimensions},batchTextureStep:function(){return e._textureStep}};return u.combine(t,a)}},Le.prototype.getVertexShaderCallback=function(){const e=this._attributes;if(0===e.length)return function(e){return e};let t="uniform highp sampler2D batchTexture; \n";t+=`${function(e){const t=e._stride;return 1===e._textureDimensions.y?`uniform vec4 batchTextureStep; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float numberOfAttributes = float(${t}); \n    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \n} \n`:`uniform vec4 batchTextureStep; \nuniform vec2 batchTextureDimensions; \nvec2 computeSt(float batchId) \n{ \n    float stepX = batchTextureStep.x; \n    float centerX = batchTextureStep.y; \n    float stepY = batchTextureStep.z; \n    float centerY = batchTextureStep.w; \n    float numberOfAttributes = float(${t}); \n    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \n    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \n    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \n} \n`}(this)}\n`;var a=[];const n=e.length;for(let e=0;e<n;++e)t+=ke(this,e),a.push(Ge(this,e));return a=a.join(""),function(e){const n=e.indexOf("void main"),r=e.substring(0,n),i=e.substring(n);var o=i.lastIndexOf("}"),l=i.substr(0,o)+a+i.substr(o);return r+"\n"+t+"\n"+l}},Le.prototype.NOTGlslAutoAttributeArray=function(){return["czm_batchTable_color","czm_batchTable_pickColor","czm_batchTable_show","czm_batchTable_distanceDisplayCondition","czm_batchTable_width","czm_batchTable_boundingSphereCenter3DHigh","czm_batchTable_boundingSphereCenter3DLow","czm_batchTable_boundingSphereCenter2DHigh","czm_batchTable_boundingSphereCenter2DLow","czm_batchTable_boundingSphereRadius","s3m_batchTable_color","s3m_batchTable_operation","s3m_batchTable_pickColor"]},Le.prototype.setFSAttributesHeader=function(e){var t=this._attributes;if(0===t.length)return e;for(var a=[],n=0;n<t.length;++n){var r=this._attributes[n],i=r.functionName,o=Ve(r.componentsPerAttribute);if(-1==this.NOTGlslAutoAttributeArray().indexOf(i)){var l="in "+o+" "+("v_"+i)+";";a.push(l)}}return a.join("\n")+"\n"+e},Le.prototype.isDestroyed=function(){return!1},Le.prototype.destroy=function(){return this._texture=this._texture&&this._texture.destroy(),f.destroyObject(this)};let We={MultiPolygon:function(e){tt(e)},Polygon:tt},He=new function(e){e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT),this.componentDatatype=e.componentDatatype,this.componentsPerAttribute=e.componentsPerAttribute,this.normalize=a.defaultValue(e.normalize,!1),this.value=e.value}({componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:1,normalize:!0,value:new Float32Array([1])}),Ye=[],Xe=[],je=[],$e=[],Ke=0,Ze={},qe=2e9;function Je(t){let a=[];for(let e=0;e<t.length;e++){let n=t[e];a=a.concat(n.polygons)}if(0==a.length)return;let n=new A({positions:a,height:Ze.ridingLanternHeight,speed:Ze.ridingLanternSpeed,type:Ze.ridingLanternType,direction:1,color:e.Color.fromAlpha(e.Color.fromCssColorString(Ze.ridingLanternColor),Ze.ridingLanternAlpha),translucent:!0});$e=n.createGeometryInstances()}function Qe(e){if(e.length>0){let t=e[0],a=We[t.type];a&&a(e)}}function et(e){for(let t=0;t<e.length;t++){let a=e[t];for(let e=0;e<a.polygons.length;e++){let t=a.polygons[e],n=at(a.id,a.properties,t);Xe.push(n)}}}function tt(e){let t=0;for(let a=0;a<e.length;a++){let n,r,i,o=e[a],l=o.style;if(l){let e=nt(l,"fillColor","fillOpacity");n={color:Y.fromColor(e),display:He},l.stroke&&(r=nt(l,"strokeColor","strokeOpacity"),i={color:Y.fromColor(r),display:He})}for(let e=0;e<o.polygons.length;e++){let a=o.polygons[e],r=Ze.heightValue?Ze.heightValue:0;t=o.totalHeight,t=t||r;let s=rt(o.id,o.properties,a,0,t,n);if(Ye.push(s),l&&l.stroke){let e=it(o.id,o.properties,a,0,t,i);je.push(e)}}}}function at(e,t,a){return e=e+"_"+Ke+"_water",new r.GeometryInstance({id:e,geometry:i.PolygonGeometry.fromPositions({height:0,positions:a,vertexFormat:Se.VERTEX_FORMAT}),attributes:{display:He},properties:t})}function nt(t,a,r){let i,o=t[a];Ze.hasOwnProperty("fillColor")&&(o=Ze.fillColor),n.defined(o)&&(i=e.Color.fromCssColorString(o),n.defined(i)||(i=e.Color.fromCssColorString("#ffffff")),i.alpha=1);let l=t[r];return Ze.hasOwnProperty("opacity")&&(l=Ze.opacity),n.defined(l)&&1!==l&&(i.alpha=l),i}function rt(e,t,a,n,o,l){if(e=e+"_"+Ke+"_polygon",Ze.translucentMaterial){let s=new r.GeometryInstance({id:e,geometry:i.PolygonGeometry.fromPositions({height:n,extrudedHeight:o,positions:a}),properties:t});return l&&(s.attributes=l),s}{let s=new r.GeometryInstance({id:e,geometry:i.PolygonGeometry.fromPositions({height:n,extrudedHeight:o,positions:a,vertexFormat:Oe.VERTEX_FORMAT}),properties:t});return l&&(s.attributes=l),s}}function it(e,t,a,n,i,l){e=e+"_"+Ke+"_polygonOutLine";let s=new r.GeometryInstance({id:e,geometry:o.PolygonOutlineGeometry.fromPositions({height:n,extrudedHeight:i,positions:a,vertexFormat:Oe.VERTEX_FORMAT}),properties:t});return l&&(s.attributes=l),s}function ot(e,t){let a=e.length;if(0==a)return null;var r,i,o=new Array(a),l=[],s=0;for(i=0;i<a;i++){var u,c=(r=e[i]).geometry;u=n.defined(c.attributes)&&n.defined(c.primitiveType)?ut(c):c.constructor.createGeometry(c),o[s++]=lt(r,u),l.push(r.id)}o.length=s;var m=v.Ellipsoid.WGS84,f=new E.GeographicProjection(m),p=x.PrimitivePipeline.combineGeometry({instances:o,ellipsoid:f.ellipsoid,projection:f,elementIndexUintSupported:!0,scene3DOnly:!1,vertexCacheOptimize:!1,compressVertices:!0,modelMatrix:_.Matrix4.IDENTITY,createPickOffsets:void 0});return x.PrimitivePipeline.packCombineGeometryResults(p,t)}function lt(e,t){return{geometry:t,attributes:e.attributes,modelMatrix:_.Matrix4.clone(e.modelMatrix),pickPrimitive:e.pickPrimitive,id:e.id}}function st(e,t){t.attributes=e.attributes,t.attributeIndices=e.attributeIndices,t.batchValues=e.batchValues,t.propertiesMapBuffer=e.propertiesMapBuffer,t.pickId=e.pickId,t.ids=e.ids}function ut(e){var t,a=e.attributes,r=new T.GeometryAttributes;for(var i in a)a.hasOwnProperty(i)&&n.defined(a[i])&&(r[i]=ct(a[i]));if(n.defined(e.indices)){var o=e.indices;t=Array.isArray(o)?o.slice(0):new o.constructor(o)}return new b.Geometry({attributes:r,indices:t,primitiveType:e.primitiveType,boundingSphere:p.BoundingSphere.clone(e.boundingSphere)})}function ct(e){var t;return t=Array.isArray(e.values)?e.values.slice(0):new e.values.constructor(e.values),new C.GeometryAttribute({componentDatatype:e.componentDatatype,componentsPerAttribute:e.componentsPerAttribute,normalize:e.normalize,values:t})}function mt(a,r){var i,o,l,s=new m.Cartesian2,u=new I.Cartesian3,c=new _.Cartesian4,f=a.length,p=function(e){var t,a=e.length,r=[],i=e[0].attributes;for(t in i)if(i.hasOwnProperty(t)&&n.defined(i[t])){for(var o=i[t],l=!0,s=1;s<a;++s){var u=e[s].attributes[t];if(!n.defined(u)||o.componentDatatype!==u.componentDatatype||o.componentsPerAttribute!==u.componentsPerAttribute||o.normalize!==u.normalize){l=!1;break}}l&&r.push(t)}return r}(a),d=p.length,h=[],g=[],y={},C=a[0].attributes;for(i=0;i<d;++i)l=C[o=p[i]],y[o]=i,g.push({functionName:"czm_batchTable_"+o,componentDatatype:l.componentDatatype,componentsPerAttribute:l.componentsPerAttribute,normalize:l.normalize});-1!==p.indexOf("distanceDisplayCondition")&&(g.push({functionName:"czm_batchTable_boundingSphereCenter3DHigh",componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter3DLow",componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter2DHigh",componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter2DLow",componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereRadius",componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:1}),g.length,g.length,g.length,g.length,g.length),-1!==p.indexOf("offset")&&(g.push({functionName:"czm_batchTable_offset2D",componentDatatype:t.ComponentDatatype.FLOAT,componentsPerAttribute:3}),g.length),g.push({functionName:"czm_batchTable_pickColor",componentDatatype:t.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,normalize:!0});var T=g.length,b=new Le({floatingPointTexture:!0},g,f);let x=qe,v={},E=!1;for(i=0;i<f;++i){var A=a[i];A.properties&&(v[A.id]=A.properties,E=!0),C=A.attributes;for(var P=0;P<d;++P){var S=ft((l=C[o=p[P]]).value,s,u,c),M=y[o];b.setBatchedAttribute(i,M,S)}h.push(A.id),qe++;var D=e.Color.fromRgba(qe),w=c;w.x=e.Color.floatToByte(D.red),w.y=e.Color.floatToByte(D.green),w.z=e.Color.floatToByte(D.blue),w.w=e.Color.floatToByte(D.alpha),b.setBatchedAttribute(i,T-1,w)}var z,O=b._batchValues;(r.push(O.buffer),E)?z=function(e){for(var t=new ArrayBuffer(2*e.length),a=new Uint16Array(t),n=0,r=e.length;n<r;n++)a[n]=e.charCodeAt(n);return t}(JSON.stringify(v)):z=new ArrayBuffer(0);return r.push(z),{attributes:g,attributeIndices:y,batchValues:O,propertiesMapBuffer:z,ids:h,pickId:x}}function ft(e,t,a,n){var r=e.length;return 1===r?e[0]:2===r?m.Cartesian2.unpack(e,0,t):3===r?I.Cartesian3.unpack(e,0,a):4===r?_.Cartesian4.unpack(e,0,n):void 0}return f.ContextLimits._maximumTextureSize=16384,function(e,t,a,n){return Ye=[],Xe=[],je=[],Ke=t,Ze=a,function(e){for(let t in e)if(Ze.ridingLanternLayerId&&Ze.ridingLanternLayerId.indexOf(t)>-1){Je(e[t])}else if(Ze.waterLayerId&&Ze.waterLayerId.indexOf(t)>-1){et(e[t])}else{Qe(e[t])}}(e),function(e){var t=ot(Ye,e),a=ot(Xe,e),n=ot(je,e),r=ot($e,e);let i={};if(t){st(mt(Ye,e),t),i.polygon=t}if(a){st(mt(Xe,e),a),i.water=a}if(n){st(mt(je,e),n),i.outline=n}if(r){st(mt($e,e),r),i.ridingLantern=r}return i}(n)}}));
