define(["exports","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./EllipseGeometryLibrary-6f58b026","./GeographicProjection-868b0b16","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryInstance-a555221e","./GeometryOffsetAttribute-2579b8d2","./GeometryPipeline-92c34dd1","./IndexDatatype-ed8b21cb","./Math-56779564","./Matrix3-59918a96","./VertexFormat-01d05a0d"],(function(t,e,i,r,n,o,a,s,l,u,m,c,p,y,d,f,A,x,h,g){"use strict";const _=new r.Cartesian3,b=new r.Cartesian3,C=new r.Cartesian3,w=new r.Cartesian3,M=new i.Cartesian2,E=new h.Matrix3,I=new h.Matrix3,T=new e.Quaternion,G=new r.Cartesian3,N=new r.Cartesian3,P=new r.Cartesian3,v=new n.Cartographic,V=new r.Cartesian3,F=new i.Cartesian2,D=new i.Cartesian2;function O(t,n,a){const m=n.vertexFormat,y=n.center,f=n.semiMajorAxis,A=n.semiMinorAxis,x=n.ellipsoid,g=n.stRotation,w=a?t.length/3*2:t.length/3,O=n.shadowVolume,S=m.st?new Float32Array(2*w):void 0,L=m.normal?new Float32Array(3*w):void 0,R=m.tangent?new Float32Array(3*w):void 0,j=m.bitangent?new Float32Array(3*w):void 0,k=O?new Float32Array(3*w):void 0;let z=0,B=G,Y=N,H=P;const U=new u.GeographicProjection(x),Q=U.project(x.cartesianToCartographic(y,v),V),W=x.scaleToGeodeticSurface(y,_);x.geodeticSurfaceNormal(W,W);let J=E,q=I;if(0!==g){let t=e.Quaternion.fromAxisAngle(W,g,T);J=h.Matrix3.fromQuaternion(t,J),t=e.Quaternion.fromAxisAngle(W,-g,T),q=h.Matrix3.fromQuaternion(t,q)}else J=h.Matrix3.clone(h.Matrix3.IDENTITY,J),q=h.Matrix3.clone(h.Matrix3.IDENTITY,q);const Z=i.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,F),K=i.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,D);let X=t.length;const $=a?X:0,tt=$/3*2;for(let e=0;e<X;e+=3){const i=e+1,n=e+2,o=r.Cartesian3.fromArray(t,e,_);if(m.st){const t=h.Matrix3.multiplyByVector(J,o,b),e=U.project(x.cartesianToCartographic(t,v),C);r.Cartesian3.subtract(e,Q,e),M.x=(e.x+f)/(2*f),M.y=(e.y+A)/(2*A),Z.x=Math.min(M.x,Z.x),Z.y=Math.min(M.y,Z.y),K.x=Math.max(M.x,K.x),K.y=Math.max(M.y,K.y),a&&(S[z+tt]=M.x,S[z+1+tt]=M.y),S[z++]=M.x,S[z++]=M.y}(m.normal||m.tangent||m.bitangent||O)&&(B=x.geodeticSurfaceNormal(o,B),O&&(k[e+$]=-B.x,k[i+$]=-B.y,k[n+$]=-B.z),(m.normal||m.tangent||m.bitangent)&&((m.tangent||m.bitangent)&&(Y=r.Cartesian3.normalize(r.Cartesian3.cross(r.Cartesian3.UNIT_Z,B,Y),Y),h.Matrix3.multiplyByVector(q,Y,Y)),m.normal&&(L[e]=B.x,L[i]=B.y,L[n]=B.z,a&&(L[e+$]=-B.x,L[i+$]=-B.y,L[n+$]=-B.z)),m.tangent&&(R[e]=Y.x,R[i]=Y.y,R[n]=Y.z,a&&(R[e+$]=-Y.x,R[i+$]=-Y.y,R[n+$]=-Y.z)),m.bitangent&&(H=r.Cartesian3.normalize(r.Cartesian3.cross(B,Y,H),H),j[e]=H.x,j[i]=H.y,j[n]=H.z,a&&(j[e+$]=H.x,j[i+$]=H.y,j[n+$]=H.z))))}if(m.st){X=S.length;for(let t=0;t<X;t+=2)S[t]=(S[t]-Z.x)/(K.x-Z.x),S[t+1]=(S[t+1]-Z.y)/(K.y-Z.y)}const et=new p.GeometryAttributes;if(m.position){const e=l.EllipseGeometryLibrary.raisePositionsToHeight(t,n,a);et.position=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e})}if(m.st&&(et.st=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S})),m.normal&&(et.normal=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),m.tangent&&(et.tangent=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),m.bitangent&&(et.bitangent=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})),O&&(et.extrudeDirection=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),a&&s.defined(n.offsetAttribute)){let t=new Uint8Array(w);if(n.offsetAttribute===d.GeometryOffsetAttribute.TOP)t=t.fill(1,0,w/2);else{const e=n.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;t=t.fill(e)}et.applyOffset=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return et}function S(t){const e=new Array(t*(t+1)*12-6);let i,r,n,o,a,s=0;for(i=0,n=1,o=0;o<3;o++)e[s++]=n++,e[s++]=i,e[s++]=n;for(o=2;o<t+1;++o){for(n=o*(o+1)-1,i=(o-1)*o-1,e[s++]=n++,e[s++]=i,e[s++]=n,r=2*o,a=0;a<r-1;++a)e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i,e[s++]=n;e[s++]=n++,e[s++]=i,e[s++]=n}for(r=2*t,++n,++i,o=0;o<r-1;++o)e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i,e[s++]=n;for(e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i++,e[s++]=i,++i,o=t-1;o>1;--o){for(e[s++]=i++,e[s++]=i,e[s++]=n,r=2*o,a=0;a<r-1;++a)e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i,e[s++]=n;e[s++]=i++,e[s++]=i++,e[s++]=n++}for(o=0;o<3;o++)e[s++]=i++,e[s++]=i,e[s++]=n;return e}let L=new r.Cartesian3;const R=new e.BoundingSphere,j=new e.BoundingSphere;function k(t){const n=t.center,a=t.ellipsoid,x=t.semiMajorAxis;let g=r.Cartesian3.multiplyByScalar(a.geodeticSurfaceNormal(n,_),t.height,_);R.center=r.Cartesian3.add(n,g,R.center),R.radius=x,g=r.Cartesian3.multiplyByScalar(a.geodeticSurfaceNormal(n,g),t.extrudedHeight,g),j.center=r.Cartesian3.add(n,g,j.center),j.radius=x;const I=l.EllipseGeometryLibrary.computeEllipsePositions(t,!0,!0),L=I.positions,k=I.numPts,z=I.outerPositions,B=e.BoundingSphere.union(R,j),Y=O(L,t,!0);let H=S(k);const U=H.length;H.length=2*U;const Q=L.length/3;for(let t=0;t<U;t+=3)H[t+U]=H[t+2]+Q,H[t+1+U]=H[t+1]+Q,H[t+2+U]=H[t]+Q;const W=A.IndexDatatype.createTypedArray(2*Q/3,H),J=new m.Geometry({attributes:Y,indices:W,primitiveType:m.PrimitiveType.TRIANGLES}),q=function(t,n){const a=n.vertexFormat,l=n.center,m=n.semiMajorAxis,y=n.semiMinorAxis,f=n.ellipsoid,A=n.height,x=n.extrudedHeight,g=n.stRotation,I=t.length/3*2,O=new Float64Array(3*I),S=a.st?new Float32Array(2*I):void 0,L=a.normal?new Float32Array(3*I):void 0,R=a.tangent?new Float32Array(3*I):void 0,j=a.bitangent?new Float32Array(3*I):void 0,k=n.shadowVolume,z=k?new Float32Array(3*I):void 0;let B=0,Y=G,H=N,U=P;const Q=new u.GeographicProjection(f),W=Q.project(f.cartesianToCartographic(l,v),V),J=f.scaleToGeodeticSurface(l,_);f.geodeticSurfaceNormal(J,J);const q=e.Quaternion.fromAxisAngle(J,g,T),Z=h.Matrix3.fromQuaternion(q,E),K=i.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,F),X=i.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,D);let $=t.length;const tt=$/3*2;for(let e=0;e<$;e+=3){const i=e+1,n=e+2;let o,s=r.Cartesian3.fromArray(t,e,_);if(a.st){const t=h.Matrix3.multiplyByVector(Z,s,b),e=Q.project(f.cartesianToCartographic(t,v),C);r.Cartesian3.subtract(e,W,e),M.x=(e.x+m)/(2*m),M.y=(e.y+y)/(2*y),K.x=Math.min(M.x,K.x),K.y=Math.min(M.y,K.y),X.x=Math.max(M.x,X.x),X.y=Math.max(M.y,X.y),S[B+tt]=M.x,S[B+1+tt]=M.y,S[B++]=M.x,S[B++]=M.y}s=f.scaleToGeodeticSurface(s,s),o=r.Cartesian3.clone(s,b),Y=f.geodeticSurfaceNormal(s,Y),k&&(z[e+$]=-Y.x,z[i+$]=-Y.y,z[n+$]=-Y.z);let l=r.Cartesian3.multiplyByScalar(Y,A,w);if(s=r.Cartesian3.add(s,l,s),l=r.Cartesian3.multiplyByScalar(Y,x,l),o=r.Cartesian3.add(o,l,o),a.position&&(O[e+$]=o.x,O[i+$]=o.y,O[n+$]=o.z,O[e]=s.x,O[i]=s.y,O[n]=s.z),a.normal||a.tangent||a.bitangent){U=r.Cartesian3.clone(Y,U);const l=r.Cartesian3.fromArray(t,(e+3)%$,w);r.Cartesian3.subtract(l,s,l);const u=r.Cartesian3.subtract(o,s,C);Y=r.Cartesian3.normalize(r.Cartesian3.cross(u,l,Y),Y),a.normal&&(L[e]=Y.x,L[i]=Y.y,L[n]=Y.z,L[e+$]=Y.x,L[i+$]=Y.y,L[n+$]=Y.z),a.tangent&&(H=r.Cartesian3.normalize(r.Cartesian3.cross(U,Y,H),H),R[e]=H.x,R[i]=H.y,R[n]=H.z,R[e+$]=H.x,R[e+1+$]=H.y,R[e+2+$]=H.z),a.bitangent&&(j[e]=U.x,j[i]=U.y,j[n]=U.z,j[e+$]=U.x,j[i+$]=U.y,j[n+$]=U.z)}}if(a.st){$=S.length;for(let t=0;t<$;t+=2)S[t]=(S[t]-K.x)/(X.x-K.x),S[t+1]=(S[t+1]-K.y)/(X.y-K.y)}const et=new p.GeometryAttributes;if(a.position&&(et.position=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O})),a.st&&(et.st=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S})),a.normal&&(et.normal=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),a.tangent&&(et.tangent=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),a.bitangent&&(et.bitangent=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})),k&&(et.extrudeDirection=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:z})),s.defined(n.offsetAttribute)){let t=new Uint8Array(I);if(n.offsetAttribute===d.GeometryOffsetAttribute.TOP)t=t.fill(1,0,I/2);else{const e=n.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;t=t.fill(e)}et.applyOffset=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return et}(z,t);H=function(t){const e=t.length/3,i=A.IndexDatatype.createTypedArray(e,6*e);let r=0;for(let t=0;t<e;t++){const n=t,o=t+e,a=(n+1)%e,s=a+e;i[r++]=n,i[r++]=o,i[r++]=a,i[r++]=a,i[r++]=o,i[r++]=s}return i}(z);const Z=A.IndexDatatype.createTypedArray(2*z.length/3,H),K=new m.Geometry({attributes:q,indices:Z,primitiveType:m.PrimitiveType.TRIANGLES}),X=f.GeometryPipeline.combineInstances([new y.GeometryInstance({geometry:J}),new y.GeometryInstance({geometry:K})]);return{boundingSphere:B,attributes:X[0].attributes,indices:X[0].indices}}function z(t,e,n,o,a,s,u){const m=l.EllipseGeometryLibrary.computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:n,rotation:o,granularity:a},!1,!0).outerPositions,c=m.length/3,p=new Array(c);for(let t=0;t<c;++t)p[t]=r.Cartesian3.fromArray(m,3*t);const y=i.Rectangle.fromCartesianArray(p,s,u);return y.width>x.CesiumMath.PI&&(y.north=y.north>0?x.CesiumMath.PI_OVER_TWO-x.CesiumMath.EPSILON7:y.north,y.south=y.south<0?x.CesiumMath.EPSILON7-x.CesiumMath.PI_OVER_TWO:y.south,y.east=x.CesiumMath.PI,y.west=-x.CesiumMath.PI),y}function B(t){const e=(t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT)).center,i=a.defaultValue(t.ellipsoid,n.Ellipsoid.WGS84),o=t.semiMajorAxis,s=t.semiMinorAxis,l=a.defaultValue(t.granularity,x.CesiumMath.RADIANS_PER_DEGREE),u=a.defaultValue(t.vertexFormat,g.VertexFormat.DEFAULT),m=a.defaultValue(t.height,0),c=a.defaultValue(t.extrudedHeight,m);this._center=r.Cartesian3.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=s,this._ellipsoid=n.Ellipsoid.clone(i),this._rotation=a.defaultValue(t.rotation,0),this._stRotation=a.defaultValue(t.stRotation,0),this._height=Math.max(c,m),this._granularity=l,this._vertexFormat=g.VertexFormat.clone(u),this._extrudedHeight=Math.min(c,m),this._shadowVolume=a.defaultValue(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}B.packedLength=r.Cartesian3.packedLength+n.Ellipsoid.packedLength+g.VertexFormat.packedLength+9,B.pack=function(t,e,i){return i=a.defaultValue(i,0),r.Cartesian3.pack(t._center,e,i),i+=r.Cartesian3.packedLength,n.Ellipsoid.pack(t._ellipsoid,e,i),i+=n.Ellipsoid.packedLength,g.VertexFormat.pack(t._vertexFormat,e,i),i+=g.VertexFormat.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=t._shadowVolume?1:0,e[i]=a.defaultValue(t._offsetAttribute,-1),e};const Y=new r.Cartesian3,H=new n.Ellipsoid,U=new g.VertexFormat,Q={center:Y,ellipsoid:H,vertexFormat:U,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};B.unpack=function(t,e,i){e=a.defaultValue(e,0);const o=r.Cartesian3.unpack(t,e,Y);e+=r.Cartesian3.packedLength;const l=n.Ellipsoid.unpack(t,e,H);e+=n.Ellipsoid.packedLength;const u=g.VertexFormat.unpack(t,e,U);e+=g.VertexFormat.packedLength;const m=t[e++],c=t[e++],p=t[e++],y=t[e++],d=t[e++],f=t[e++],A=t[e++],x=1===t[e++],h=t[e];return s.defined(i)?(i._center=r.Cartesian3.clone(o,i._center),i._ellipsoid=n.Ellipsoid.clone(l,i._ellipsoid),i._vertexFormat=g.VertexFormat.clone(u,i._vertexFormat),i._semiMajorAxis=m,i._semiMinorAxis=c,i._rotation=p,i._stRotation=y,i._height=d,i._granularity=f,i._extrudedHeight=A,i._shadowVolume=x,i._offsetAttribute=-1===h?void 0:h,i):(Q.height=d,Q.extrudedHeight=A,Q.granularity=f,Q.stRotation=y,Q.rotation=p,Q.semiMajorAxis=m,Q.semiMinorAxis=c,Q.shadowVolume=x,Q.offsetAttribute=-1===h?void 0:h,new B(Q))},B.computeRectangle=function(t,e){const i=(t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT)).center,r=a.defaultValue(t.ellipsoid,n.Ellipsoid.WGS84),o=t.semiMajorAxis,s=t.semiMinorAxis,l=a.defaultValue(t.granularity,x.CesiumMath.RADIANS_PER_DEGREE);return z(i,o,s,a.defaultValue(t.rotation,0),l,r,e)},B.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const i=t._height,n=t._extrudedHeight,a=!x.CesiumMath.equalsEpsilon(i,n,0,x.CesiumMath.EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const u={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:i,granularity:t._granularity,vertexFormat:t._vertexFormat,stRotation:t._stRotation};let p;if(a)u.extrudedHeight=n,u.shadowVolume=t._shadowVolume,u.offsetAttribute=t._offsetAttribute,p=k(u);else if(p=function(t){const i=t.center;L=r.Cartesian3.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(i,L),t.height,L),L=r.Cartesian3.add(i,L,L);const n=new e.BoundingSphere(L,t.semiMajorAxis),o=l.EllipseGeometryLibrary.computeEllipsePositions(t,!0,!1),a=o.positions,s=o.numPts,u=O(a,t,!1);let m=S(s);return m=A.IndexDatatype.createTypedArray(a.length/3,m),{boundingSphere:n,attributes:u,indices:m}}(u),s.defined(t._offsetAttribute)){const e=p.attributes.position.values.length,i=t._offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1,r=new Uint8Array(e/3).fill(i);p.attributes.applyOffset=new c.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new m.Geometry({attributes:p.attributes,indices:p.indices,primitiveType:m.PrimitiveType.TRIANGLES,boundingSphere:p.boundingSphere,offsetAttribute:t._offsetAttribute})},B.createShadowVolume=function(t,e,i){const r=t._granularity,n=t._ellipsoid,o=e(r,n),a=i(r,n);return new B({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:r,extrudedHeight:o,height:a,vertexFormat:g.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(B.prototype,{rectangle:{get:function(){return s.defined(this._rectangle)||(this._rectangle=z(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return s.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const i=l.EllipseGeometryLibrary.computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0).outerPositions,n=i.length/3,o=new Array(n);for(let t=0;t<n;++t)o[t]=r.Cartesian3.fromArray(i,3*t);const a=t._ellipsoid,s=t.rectangle;return m.Geometry._textureCoordinateRotationPoints(o,e,a,s)}(this)),this._textureCoordinateRotationPoints}}}),t.EllipseGeometry=B}));
