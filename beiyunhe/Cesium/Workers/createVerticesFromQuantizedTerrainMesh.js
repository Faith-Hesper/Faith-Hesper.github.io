define(["./AxisAlignedBoundingBox-8b4e9f9c","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./defined-64766648","./EllipsoidalOccluder-23ed042c","./IndexDatatype-ed8b21cb","./Math-56779564","./Matrix2-e52b9454","./TerrainEncoding-68597868","./Resource-be841477","./Transforms-b1e48e05","./WebMercatorProjection-78306e76","./createTaskProcessorWorker-03824364","./defaultValue-9f6a6288","./WebGLConstants-7f557f93","./Matrix3-59918a96","./RuntimeError-cfbf2bc8","./AttributeCompression-44abee07","./ComponentDatatype-63fd8cd4","./combine-ac72e009","./defer-7878b392","./GeographicProjection-868b0b16"],(function(e,t,r,n,o,i,a,s,c,d,h,u,l,I,g,m,T,E,p,f,y,N,w){"use strict";function M(){h.DeveloperError.throwInstantiationError()}Object.defineProperties(M.prototype,{errorEvent:{get:h.DeveloperError.throwInstantiationError},credit:{get:h.DeveloperError.throwInstantiationError},tilingScheme:{get:h.DeveloperError.throwInstantiationError},ready:{get:h.DeveloperError.throwInstantiationError},readyPromise:{get:h.DeveloperError.throwInstantiationError},hasWaterMask:{get:h.DeveloperError.throwInstantiationError},hasVertexNormals:{get:h.DeveloperError.throwInstantiationError},availability:{get:h.DeveloperError.throwInstantiationError}});const S=[];M.getRegularGridIndices=function(e,t){let r=S[e];o.defined(r)||(S[e]=r=[]);let n=r[t];return o.defined(n)||(n=e*t<s.CesiumMath.SIXTY_FOUR_KILOBYTES?r[t]=new Uint16Array((e-1)*(t-1)*6):r[t]=new Uint32Array((e-1)*(t-1)*6),b(e,t,n,0)),n};const x=[];M.getRegularGridIndicesAndEdgeIndices=function(e,t){let r=x[e];o.defined(r)||(x[e]=r=[]);let n=r[t];if(!o.defined(n)){const o=M.getRegularGridIndices(e,t),i=A(e,t),a=i.westIndicesSouthToNorth,s=i.southIndicesEastToWest,c=i.eastIndicesNorthToSouth,d=i.northIndicesWestToEast;n=r[t]={indices:o,westIndicesSouthToNorth:a,southIndicesEastToWest:s,eastIndicesNorthToSouth:c,northIndicesWestToEast:d}}return n};const C=[];function A(e,t){const r=new Array(t),n=new Array(e),o=new Array(t),i=new Array(e);let a;for(a=0;a<e;++a)i[a]=a,n[a]=e*t-1-a;for(a=0;a<t;++a)o[a]=(a+1)*e-1,r[a]=(t-a-1)*e;return{westIndicesSouthToNorth:r,southIndicesEastToWest:n,eastIndicesNorthToSouth:o,northIndicesWestToEast:i}}function b(e,t,r,n){let o=0;for(let i=0;i<t-1;++i){for(let t=0;t<e-1;++t){const t=o,i=t+e,a=i+1,s=t+1;r[n++]=t,r[n++]=i,r[n++]=s,r[n++]=s,r[n++]=i,r[n++]=a,++o}++o}}function W(e,t,r,n){let o=e[0];const i=e.length;for(let a=1;a<i;++a){const i=e[a];r[n++]=o,r[n++]=i,r[n++]=t,r[n++]=t,r[n++]=i,r[n++]=t+1,o=i,++t}return n}M.getRegularGridAndSkirtIndicesAndEdgeIndices=function(e,t){let r=C[e];o.defined(r)||(C[e]=r=[]);let n=r[t];if(!o.defined(n)){const o=e*t,i=(e-1)*(t-1)*6,s=2*e+2*t,c=o+s,d=i+6*Math.max(0,s-4),h=A(e,t),u=h.westIndicesSouthToNorth,l=h.southIndicesEastToWest,I=h.eastIndicesNorthToSouth,g=h.northIndicesWestToEast,m=a.IndexDatatype.createTypedArray(c,d);b(e,t,m,0),M.addSkirtIndices(u,l,I,g,o,m,i),n=r[t]={indices:m,westIndicesSouthToNorth:u,southIndicesEastToWest:l,eastIndicesNorthToSouth:I,northIndicesWestToEast:g,indexCountWithoutSkirts:i}}return n},M.addSkirtIndices=function(e,t,r,n,o,i,a){let s=o;a=W(e,s,i,a),s+=e.length,a=W(t,s,i,a),s+=t.length,a=W(r,s,i,a),s+=r.length,W(n,s,i,a)},M.heightmapTerrainQuality=.25,M.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(e,t,r){return 2*e.maximumRadius*Math.PI*M.heightmapTerrainQuality/(t*r)},M.prototype.requestTileGeometry=h.DeveloperError.throwInstantiationError,M.prototype.getLevelMaximumGeometricError=h.DeveloperError.throwInstantiationError,M.prototype.getTileDataAvailable=h.DeveloperError.throwInstantiationError,M.prototype.loadTileDataAvailability=h.DeveloperError.throwInstantiationError;const v=32767,P=new r.Cartesian3,k=new r.Cartesian3,D=new r.Cartesian3,F=new n.Cartographic,H=new t.Cartesian2;function G(e,t,n,o,i,a,d,h,u){let l=Number.POSITIVE_INFINITY;const I=i.north,g=i.south;let m=i.east;const T=i.west;m<T&&(m+=s.CesiumMath.TWO_PI);const E=e.length;for(let i=0;i<E;++i){const E=e[i],p=n[E],f=o[E];F.longitude=s.CesiumMath.lerp(T,m,f.x),F.latitude=s.CesiumMath.lerp(g,I,f.y),F.height=p-t;const y=a.cartographicToCartesian(F,P);c.Matrix4.multiplyByPoint(d,y,y),r.Cartesian3.minimumByComponent(y,h,h),r.Cartesian3.maximumByComponent(y,u,u),l=Math.min(l,F.height)}return l}function _(e,t,r,n,i,a,c,d,h,u,I,g,m,T){const E=o.defined(c),p=h.north,f=h.south;let y=h.east;const N=h.west;y<N&&(y+=s.CesiumMath.TWO_PI);const w=r.length;for(let o=0;o<w;++o){const h=r[o],w=i[h],M=a[h];F.longitude=s.CesiumMath.lerp(N,y,M.x)+m,F.latitude=s.CesiumMath.lerp(f,p,M.y)+T,F.height=w-u;const S=d.cartographicToCartesian(F,P);if(E){const e=2*h;H.x=c[e],H.y=c[e+1]}let x,C;n.hasWebMercatorT&&(x=(l.WebMercatorProjection.geodeticLatitudeToMercatorAngle(F.latitude)-I)*g),n.hasGeodeticSurfaceNormals&&(C=d.geodeticSurfaceNormal(S)),t=n.encode(e,t,S,M,F.height,H,x,C)}}function V(e,t){let r;return"function"==typeof e.slice&&(r=e.slice(),"function"!=typeof r.sort&&(r=void 0)),o.defined(r)||(r=Array.prototype.slice.call(e)),r.sort(t),r}return I.createTaskProcessorWorker((function(h,I){const g=h.quantizedVertices,m=g.length/3,T=h.octEncodedNormals,E=h.westIndices.length+h.eastIndices.length+h.southIndices.length+h.northIndices.length,p=h.includeWebMercatorT,f=h.exaggeration,y=h.exaggerationRelativeHeight,N=1!==f,w=t.Rectangle.clone(h.rectangle),S=w.west,x=w.south,C=w.east,A=w.north,b=n.Ellipsoid.clone(h.ellipsoid),W=h.minimumHeight,Y=h.maximumHeight,O=h.relativeToCenter,B=u.Transforms.eastNorthUpToFixedFrame(O,b),R=c.Matrix4.inverseTransformation(B,new c.Matrix4);let L,j;p&&(L=l.WebMercatorProjection.geodeticLatitudeToMercatorAngle(x),j=1/(l.WebMercatorProjection.geodeticLatitudeToMercatorAngle(A)-L));const U=g.subarray(0,m),z=g.subarray(m,2*m),q=g.subarray(2*m,3*m),Q=o.defined(T),Z=new Array(m),K=new Array(m),X=new Array(m),J=p?new Array(m):[],$=N?new Array(m):[],ee=k;ee.x=Number.POSITIVE_INFINITY,ee.y=Number.POSITIVE_INFINITY,ee.z=Number.POSITIVE_INFINITY;const te=D;te.x=Number.NEGATIVE_INFINITY,te.y=Number.NEGATIVE_INFINITY,te.z=Number.NEGATIVE_INFINITY;let re=Number.POSITIVE_INFINITY,ne=Number.NEGATIVE_INFINITY,oe=Number.POSITIVE_INFINITY,ie=Number.NEGATIVE_INFINITY;for(let e=0;e<m;++e){const n=U[e],o=z[e],i=n/v,a=o/v,d=s.CesiumMath.lerp(W,Y,q[e]/v);F.longitude=s.CesiumMath.lerp(S,C,i),F.latitude=s.CesiumMath.lerp(x,A,a),F.height=d,re=Math.min(F.longitude,re),ne=Math.max(F.longitude,ne),oe=Math.min(F.latitude,oe),ie=Math.max(F.latitude,ie);const h=b.cartographicToCartesian(F);Z[e]=new t.Cartesian2(i,a),K[e]=d,X[e]=h,p&&(J[e]=(l.WebMercatorProjection.geodeticLatitudeToMercatorAngle(F.latitude)-L)*j),N&&($[e]=b.geodeticSurfaceNormal(h)),c.Matrix4.multiplyByPoint(R,h,P),r.Cartesian3.minimumByComponent(P,ee,ee),r.Cartesian3.maximumByComponent(P,te,te)}const ae=V(h.westIndices,(function(e,t){return Z[e].y-Z[t].y})),se=V(h.eastIndices,(function(e,t){return Z[t].y-Z[e].y})),ce=V(h.southIndices,(function(e,t){return Z[t].x-Z[e].x})),de=V(h.northIndices,(function(e,t){return Z[e].x-Z[t].x}));let he;if(W<0){he=new i.EllipsoidalOccluder(b).computeHorizonCullingPointPossiblyUnderEllipsoid(O,X,W)}let ue=W;ue=Math.min(ue,G(h.westIndices,h.westSkirtHeight,K,Z,w,b,R,ee,te)),ue=Math.min(ue,G(h.southIndices,h.southSkirtHeight,K,Z,w,b,R,ee,te)),ue=Math.min(ue,G(h.eastIndices,h.eastSkirtHeight,K,Z,w,b,R,ee,te)),ue=Math.min(ue,G(h.northIndices,h.northSkirtHeight,K,Z,w,b,R,ee,te));const le=new e.AxisAlignedBoundingBox(ee,te,O),Ie=new d.TerrainEncoding(O,le,ue,Y,B,Q,p,N,f,y),ge=Ie.stride,me=new Float32Array(m*ge+E*ge);let Te=0;for(let e=0;e<m;++e){if(Q){const t=2*e;H.x=T[t],H.y=T[t+1]}Te=Ie.encode(me,Te,X[e],Z[e],K[e],H,J[e],$[e])}const Ee=Math.max(0,2*(E-4)),pe=h.indices.length+3*Ee,fe=a.IndexDatatype.createTypedArray(m+E,pe);fe.set(h.indices,0);const ye=1e-4,Ne=(ne-re)*ye,we=(ie-oe)*ye,Me=-Ne,Se=Ne,xe=we,Ce=-we;let Ae=m*ge;return _(me,Ae,ae,Ie,K,Z,T,b,w,h.westSkirtHeight,L,j,Me,0),Ae+=h.westIndices.length*ge,_(me,Ae,ce,Ie,K,Z,T,b,w,h.southSkirtHeight,L,j,0,Ce),Ae+=h.southIndices.length*ge,_(me,Ae,se,Ie,K,Z,T,b,w,h.eastSkirtHeight,L,j,Se,0),Ae+=h.eastIndices.length*ge,_(me,Ae,de,Ie,K,Z,T,b,w,h.northSkirtHeight,L,j,0,xe),M.addSkirtIndices(ae,ce,se,de,m,fe,h.indices.length),I.push(me.buffer,fe.buffer),{vertices:me.buffer,indices:fe.buffer,westIndicesSouthToNorth:ae,southIndicesEastToWest:ce,eastIndicesNorthToSouth:se,northIndicesWestToEast:de,vertexStride:ge,center:O,minimumHeight:W,maximumHeight:Y,occludeePointInScaledSpace:he,encoding:Ie,indexCountWithoutSkirts:h.indices.length}}))}));
