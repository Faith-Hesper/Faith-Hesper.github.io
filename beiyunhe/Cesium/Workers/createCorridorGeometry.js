define(["./arrayRemoveDuplicates-d0608faf","./Transforms-b1e48e05","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./ComponentDatatype-63fd8cd4","./PolylineVolumeGeometryLibrary-b5caf6df","./CorridorGeometryLibrary-5378285c","./defaultValue-9f6a6288","./defined-64766648","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-ed8b21cb","./Math-56779564","./PolygonPipeline-d79010c3","./Cartesian2-0a34ed75","./VertexFormat-01d05a0d","./GeographicProjection-868b0b16","./Matrix3-59918a96","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93","./EllipsoidTangentPlane-8f36a7e0","./AxisAlignedBoundingBox-8b4e9f9c","./IntersectionTests-39c3b1c1","./Plane-f9bf6226","./PolylinePipeline-206d6e54","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6"],(function(t,e,r,a,i,o,n,s,l,d,u,m,c,y,p,f,h,g,C,b,A,_,w,v,G,T,E,V,L,x,P,F,N){"use strict";const M=new r.Cartesian3,D=new r.Cartesian3,O=new r.Cartesian3,I=new r.Cartesian3,S=new r.Cartesian3,R=new r.Cartesian3,k=new r.Cartesian3,H=new r.Cartesian3;function W(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function z(t,e,a,i,o,s){const l=t.normals,d=t.tangents,u=t.bitangents,m=r.Cartesian3.normalize(r.Cartesian3.cross(a,e,k),k);s.normal&&n.CorridorGeometryLibrary.addAttribute(l,e,i,o),s.tangent&&n.CorridorGeometryLibrary.addAttribute(d,m,i,o),s.bitangent&&n.CorridorGeometryLibrary.addAttribute(u,a,i,o)}function B(t,e,a){const o=t.positions,s=t.corners,d=t.endPositions,c=t.lefts,f=t.normals,h=new m.GeometryAttributes;let g,C,b,A=0,_=0,w=0;for(C=0;C<o.length;C+=2)b=o[C].length-3,A+=b,w+=2*b,_+=o[C+1].length-3;for(A+=3,_+=3,C=0;C<s.length;C++){g=s[C];const t=s[C].leftPositions;l.defined(t)?(b=t.length,A+=b,w+=b):(b=s[C].rightPositions.length,_+=b,w+=b)}const v=l.defined(d);let G;v&&(G=d[0].length-3,A+=G,_+=G,G/=3,w+=6*G);const T=A+_,E=new Float64Array(T),V={normals:e.normal?new Float32Array(T):void 0,tangents:e.tangent?new Float32Array(T):void 0,bitangents:e.bitangent?new Float32Array(T):void 0};let L,x,P,F,N,S,W=0,B=T-1,U=M,Y=D;const q=G/2,j=y.IndexDatatype.createTypedArray(T/3,w);let J=0;if(v){S=O,N=I;const t=d[0];for(U=r.Cartesian3.fromArray(f,0,U),Y=r.Cartesian3.fromArray(c,0,Y),C=0;C<q;C++)S=r.Cartesian3.fromArray(t,3*(q-1-C),S),N=r.Cartesian3.fromArray(t,3*(q+C),N),n.CorridorGeometryLibrary.addAttribute(E,N,W),n.CorridorGeometryLibrary.addAttribute(E,S,void 0,B),z(V,U,Y,W,B,e),x=W/3,F=x+1,L=(B-2)/3,P=L-1,j[J++]=L,j[J++]=x,j[J++]=P,j[J++]=P,j[J++]=x,j[J++]=F,W+=3,B-=3}let K,Q,X=0,Z=0,$=o[X++],tt=o[X++];for(E.set($,W),E.set(tt,B-tt.length+1),Y=r.Cartesian3.fromArray(c,Z,Y),b=tt.length-3,C=0;C<b;C+=3)K=a.geodeticSurfaceNormal(r.Cartesian3.fromArray($,C,k),k),Q=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,b-C,H),H),U=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,U),U),z(V,U,Y,W,B,e),x=W/3,F=x+1,L=(B-2)/3,P=L-1,j[J++]=L,j[J++]=x,j[J++]=P,j[J++]=P,j[J++]=x,j[J++]=F,W+=3,B-=3;for(K=a.geodeticSurfaceNormal(r.Cartesian3.fromArray($,b,k),k),Q=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,b,H),H),U=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,U),U),Z+=3,C=0;C<s.length;C++){let t;g=s[C];const i=g.leftPositions,d=g.rightPositions;let u,m,y=R,p=O,h=I;if(U=r.Cartesian3.fromArray(f,Z,U),l.defined(i)){for(z(V,U,Y,void 0,B,e),B-=3,u=F,m=P,t=0;t<i.length/3;t++)y=r.Cartesian3.fromArray(i,3*t,y),j[J++]=u,j[J++]=m-t-1,j[J++]=m-t,n.CorridorGeometryLibrary.addAttribute(E,y,void 0,B),p=r.Cartesian3.fromArray(E,3*(m-t-1),p),h=r.Cartesian3.fromArray(E,3*u,h),Y=r.Cartesian3.normalize(r.Cartesian3.subtract(p,h,Y),Y),z(V,U,Y,void 0,B,e),B-=3;y=r.Cartesian3.fromArray(E,3*u,y),p=r.Cartesian3.subtract(r.Cartesian3.fromArray(E,3*m,p),y,p),h=r.Cartesian3.subtract(r.Cartesian3.fromArray(E,3*(m-t),h),y,h),Y=r.Cartesian3.normalize(r.Cartesian3.add(p,h,Y),Y),z(V,U,Y,W,void 0,e),W+=3}else{for(z(V,U,Y,W,void 0,e),W+=3,u=P,m=F,t=0;t<d.length/3;t++)y=r.Cartesian3.fromArray(d,3*t,y),j[J++]=u,j[J++]=m+t,j[J++]=m+t+1,n.CorridorGeometryLibrary.addAttribute(E,y,W),p=r.Cartesian3.fromArray(E,3*u,p),h=r.Cartesian3.fromArray(E,3*(m+t),h),Y=r.Cartesian3.normalize(r.Cartesian3.subtract(p,h,Y),Y),z(V,U,Y,W,void 0,e),W+=3;y=r.Cartesian3.fromArray(E,3*u,y),p=r.Cartesian3.subtract(r.Cartesian3.fromArray(E,3*(m+t),p),y,p),h=r.Cartesian3.subtract(r.Cartesian3.fromArray(E,3*m,h),y,h),Y=r.Cartesian3.normalize(r.Cartesian3.negate(r.Cartesian3.add(h,p,Y),Y),Y),z(V,U,Y,void 0,B,e),B-=3}for($=o[X++],tt=o[X++],$.splice(0,3),tt.splice(tt.length-3,3),E.set($,W),E.set(tt,B-tt.length+1),b=tt.length-3,Z+=3,Y=r.Cartesian3.fromArray(c,Z,Y),t=0;t<tt.length;t+=3)K=a.geodeticSurfaceNormal(r.Cartesian3.fromArray($,t,k),k),Q=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(tt,b-t,H),H),U=r.Cartesian3.normalize(r.Cartesian3.add(K,Q,U),U),z(V,U,Y,W,B,e),F=W/3,x=F-1,P=(B-2)/3,L=P+1,j[J++]=L,j[J++]=x,j[J++]=P,j[J++]=P,j[J++]=x,j[J++]=F,W+=3,B-=3;W-=3,B+=3}if(U=r.Cartesian3.fromArray(f,f.length-3,U),z(V,U,Y,W,B,e),v){W+=3,B-=3,S=O,N=I;const t=d[1];for(C=0;C<q;C++)S=r.Cartesian3.fromArray(t,3*(G-C-1),S),N=r.Cartesian3.fromArray(t,3*C,N),n.CorridorGeometryLibrary.addAttribute(E,S,void 0,B),n.CorridorGeometryLibrary.addAttribute(E,N,W),z(V,U,Y,W,B,e),F=W/3,x=F-1,P=(B-2)/3,L=P+1,j[J++]=L,j[J++]=x,j[J++]=P,j[J++]=P,j[J++]=x,j[J++]=F,W+=3,B-=3}if(h.position=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:E}),e.st){const t=new Float32Array(T/3*2);let e,r,a=0;if(v){A/=3,_/=3;const i=Math.PI/(G+1);let o;r=1/(A-G+1),e=1/(_-G+1);const n=G/2;for(C=n+1;C<G+1;C++)o=p.CesiumMath.PI_OVER_TWO+i*C,t[a++]=e*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(C=1;C<_-G+1;C++)t[a++]=C*e,t[a++]=0;for(C=G;C>n;C--)o=p.CesiumMath.PI_OVER_TWO-C*i,t[a++]=1-e*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(C=n;C>0;C--)o=p.CesiumMath.PI_OVER_TWO-i*C,t[a++]=1-r*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o));for(C=A-G;C>0;C--)t[a++]=C*r,t[a++]=1;for(C=1;C<n+1;C++)o=p.CesiumMath.PI_OVER_TWO+i*C,t[a++]=r*(1+Math.cos(o)),t[a++]=.5*(1+Math.sin(o))}else{for(A/=3,_/=3,r=1/(A-1),e=1/(_-1),C=0;C<_;C++)t[a++]=C*e,t[a++]=0;for(C=A;C>0;C--)t[a++]=(C-1)*r,t[a++]=1}h.st=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(h.normal=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V.normals})),e.tangent&&(h.tangent=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V.tangents})),e.bitangent&&(h.bitangent=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V.bitangents})),{attributes:h,indices:j}}function U(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function Y(t,e){const a=new g.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),o=t.ellipsoid,s=B(n.CorridorGeometryLibrary.computePositions(t),a,o),d=t.height,m=t.extrudedHeight;let p=s.attributes;const h=s.indices;let C=p.position.values,b=C.length;const A=new Float64Array(6*b);let _=new Float64Array(b);_.set(C);let w,v=new Float64Array(4*b);if(t.topWidth){t.width=t.topWidth;C=B(n.CorridorGeometryLibrary.computePositions(t),a,o).attributes.position.values}C=f.PolygonPipeline.scaleToGeodeticHeight(C,d,o),v=U(C,0,v),_=f.PolygonPipeline.scaleToGeodeticHeight(_,m,o),v=U(_,2*b,v),A.set(C),A.set(_,b),A.set(v,2*b),p.position.values=A,p=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const a=t.position.values;let i,o;(e.normal||e.bitangent)&&(i=t.normal.values,o=t.bitangent.values);const s=t.position.values.length/18,l=3*s,d=2*s,u=2*l;let m;if(e.normal||e.bitangent||e.tangent){const s=e.normal?new Float32Array(6*l):void 0,d=e.tangent?new Float32Array(6*l):void 0,c=e.bitangent?new Float32Array(6*l):void 0;let y=M,p=D,f=O,h=I,g=S,C=R,b=u;for(m=0;m<l;m+=3){const t=b+u;y=r.Cartesian3.fromArray(a,m,y),p=r.Cartesian3.fromArray(a,m+l,p),f=r.Cartesian3.fromArray(a,(m+3)%l,f),p=r.Cartesian3.subtract(p,y,p),f=r.Cartesian3.subtract(f,y,f),h=r.Cartesian3.normalize(r.Cartesian3.cross(p,f,h),h),e.normal&&(n.CorridorGeometryLibrary.addAttribute(s,h,t),n.CorridorGeometryLibrary.addAttribute(s,h,t+3),n.CorridorGeometryLibrary.addAttribute(s,h,b),n.CorridorGeometryLibrary.addAttribute(s,h,b+3)),(e.tangent||e.bitangent)&&(C=r.Cartesian3.fromArray(i,m,C),e.bitangent&&(n.CorridorGeometryLibrary.addAttribute(c,C,t),n.CorridorGeometryLibrary.addAttribute(c,C,t+3),n.CorridorGeometryLibrary.addAttribute(c,C,b),n.CorridorGeometryLibrary.addAttribute(c,C,b+3)),e.tangent&&(g=r.Cartesian3.normalize(r.Cartesian3.cross(C,h,g),g),n.CorridorGeometryLibrary.addAttribute(d,g,t),n.CorridorGeometryLibrary.addAttribute(d,g,t+3),n.CorridorGeometryLibrary.addAttribute(d,g,b),n.CorridorGeometryLibrary.addAttribute(d,g,b+3))),b+=6}if(e.normal){for(s.set(i),m=0;m<l;m+=3)s[m+l]=-i[m],s[m+l+1]=-i[m+1],s[m+l+2]=-i[m+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(c.set(o),c.set(o,l),t.bitangent.values=c):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,l),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],m=2;m<d;m+=2){const t=e[m],i=e[m+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(p,e);const G=b/3;if(t.shadowVolume){const t=p.normal.values;b=t.length;let r=new Float32Array(6*b);for(w=0;w<b;w++)t[w]=-t[w];r.set(t,b),r=U(t,4*b,r),p.extrudeDirection=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:r}),e.normal||(p.normal=void 0)}if(l.defined(t.offsetAttribute)){let e=new Uint8Array(6*G);if(t.offsetAttribute===c.GeometryOffsetAttribute.TOP)e=e.fill(1,0,G).fill(1,2*G,4*G);else{const r=t.offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1;e=e.fill(r)}p.applyOffset=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const T=h.length,E=G+G,V=y.IndexDatatype.createTypedArray(A.length/3,2*T+3*E);V.set(h);let L,x,P,F,N=T;for(w=0;w<T;w+=3){const t=h[w],e=h[w+1],r=h[w+2];V[N++]=r+G,V[N++]=e+G,V[N++]=t+G}for(w=0;w<E;w+=2)L=w+E,x=L+E,P=L+1,F=x+1,V[N++]=L,V[N++]=x,V[N++]=P,V[N++]=P,V[N++]=x,V[N++]=F;return{attributes:p,indices:V}}const q=new r.Cartesian3,j=new r.Cartesian3,J=new a.Cartographic;function K(t,e,a,i,o,n){const s=r.Cartesian3.subtract(e,t,q);r.Cartesian3.normalize(s,s);const l=a.geodeticSurfaceNormal(t,j),d=r.Cartesian3.cross(s,l,q);r.Cartesian3.multiplyByScalar(d,i,d);let u=o.latitude,m=o.longitude,c=n.latitude,y=n.longitude;r.Cartesian3.add(t,d,j),a.cartesianToCartographic(j,J);let p=J.latitude,f=J.longitude;u=Math.min(u,p),m=Math.min(m,f),c=Math.max(c,p),y=Math.max(y,f),r.Cartesian3.subtract(t,d,j),a.cartesianToCartographic(j,J),p=J.latitude,f=J.longitude,u=Math.min(u,p),m=Math.min(m,f),c=Math.max(c,p),y=Math.max(y,f),o.latitude=u,o.longitude=m,n.latitude=c,n.longitude=y}const Q=new r.Cartesian3,X=new r.Cartesian3,Z=new a.Cartographic,$=new a.Cartographic;function tt(e,a,i,n,s){e=W(e,a);const d=t.arrayRemoveDuplicates(e,r.Cartesian3.equalsEpsilon),u=d.length;if(u<2||i<=0)return new h.Rectangle;const m=.5*i;let c,y;if(Z.latitude=Number.POSITIVE_INFINITY,Z.longitude=Number.POSITIVE_INFINITY,$.latitude=Number.NEGATIVE_INFINITY,$.longitude=Number.NEGATIVE_INFINITY,n===o.CornerType.ROUNDED){const t=d[0];r.Cartesian3.subtract(t,d[1],Q),r.Cartesian3.normalize(Q,Q),r.Cartesian3.multiplyByScalar(Q,m,Q),r.Cartesian3.add(t,Q,X),a.cartesianToCartographic(X,J),c=J.latitude,y=J.longitude,Z.latitude=Math.min(Z.latitude,c),Z.longitude=Math.min(Z.longitude,y),$.latitude=Math.max($.latitude,c),$.longitude=Math.max($.longitude,y)}for(let t=0;t<u-1;++t)K(d[t],d[t+1],a,m,Z,$);const p=d[u-1];r.Cartesian3.subtract(p,d[u-2],Q),r.Cartesian3.normalize(Q,Q),r.Cartesian3.multiplyByScalar(Q,m,Q),r.Cartesian3.add(p,Q,X),K(p,X,a,m,Z,$),n===o.CornerType.ROUNDED&&(a.cartesianToCartographic(X,J),c=J.latitude,y=J.longitude,Z.latitude=Math.min(Z.latitude,c),Z.longitude=Math.min(Z.longitude,y),$.latitude=Math.max($.latitude,c),$.longitude=Math.max($.longitude,y));const f=l.defined(s)?s:new h.Rectangle;return f.north=$.latitude,f.south=Z.latitude,f.east=$.longitude,f.west=Z.longitude,f}function et(t){const e=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,i=t.width,n=s.defaultValue(t.height,0),l=s.defaultValue(t.extrudedHeight,n);this._positions=e,this._ellipsoid=a.Ellipsoid.clone(s.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84)),this._vertexFormat=g.VertexFormat.clone(s.defaultValue(t.vertexFormat,g.VertexFormat.DEFAULT)),this._width=i,this._topWidth=t.topWidth,this._height=Math.max(n,l),this._extrudedHeight=Math.min(n,l),this._cornerType=s.defaultValue(t.cornerType,o.CornerType.ROUNDED),this._granularity=s.defaultValue(t.granularity,p.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=s.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*r.Cartesian3.packedLength+a.Ellipsoid.packedLength+g.VertexFormat.packedLength+7}et.pack=function(t,e,i){i=s.defaultValue(i,0);const o=t._positions,n=o.length;e[i++]=n;for(let t=0;t<n;++t,i+=r.Cartesian3.packedLength)r.Cartesian3.pack(o[t],e,i);return a.Ellipsoid.pack(t._ellipsoid,e,i),i+=a.Ellipsoid.packedLength,g.VertexFormat.pack(t._vertexFormat,e,i),i+=g.VertexFormat.packedLength,e[i++]=t._width,e[i++]=t._topWidth,e[i++]=t._height,e[i++]=t._extrudedHeight,e[i++]=t._cornerType,e[i++]=t._granularity,e[i++]=t._shadowVolume?1:0,e[i]=s.defaultValue(t._offsetAttribute,-1),e};const rt=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),at=new g.VertexFormat,it={positions:void 0,ellipsoid:rt,vertexFormat:at,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return et.unpack=function(t,e,i){e=s.defaultValue(e,0);const o=t[e++],n=new Array(o);for(let a=0;a<o;++a,e+=r.Cartesian3.packedLength)n[a]=r.Cartesian3.unpack(t,e);const d=a.Ellipsoid.unpack(t,e,rt);e+=a.Ellipsoid.packedLength;const u=g.VertexFormat.unpack(t,e,at);e+=g.VertexFormat.packedLength;const m=t[e++],c=t[e++],y=t[e++],p=t[e++],f=t[e++],h=t[e++],C=1===t[e++],b=t[e];return l.defined(i)?(i._positions=n,i._ellipsoid=a.Ellipsoid.clone(d,i._ellipsoid),i._vertexFormat=g.VertexFormat.clone(u,i._vertexFormat),i._width=m,i._height=y,i._extrudedHeight=p,i._cornerType=f,i._granularity=h,i._shadowVolume=C,i._offsetAttribute=-1===b?void 0:b,i):(it.positions=n,it.width=m,it.topWidth=c,it.height=y,it.extrudedHeight=p,it.cornerType=f,it.granularity=h,it.shadowVolume=C,it.offsetAttribute=-1===b?void 0:b,new et(it))},et.computeRectangle=function(t,e){const r=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,i=t.width;return tt(r,s.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84),i,s.defaultValue(t.cornerType,o.CornerType.ROUNDED),e)},et.createGeometry=function(a){let o=a._positions;const s=a._width,m=a._ellipsoid;o=W(o,m);const y=t.arrayRemoveDuplicates(o,r.Cartesian3.equalsEpsilon);if(y.length<2||s<=0)return;const h=a._height,g=a._extrudedHeight,C=!p.CesiumMath.equalsEpsilon(h,g,0,p.CesiumMath.EPSILON2),b=a._vertexFormat,A={ellipsoid:m,positions:y,width:s,topWidth:a._topWidth,cornerType:a._cornerType,granularity:a._granularity,saveAttributes:!0};let _;if(C)A.height=h,A.extrudedHeight=g,A.shadowVolume=a._shadowVolume,A.offsetAttribute=a._offsetAttribute,_=Y(A,b);else{if(_=B(n.CorridorGeometryLibrary.computePositions(A),b,m),_.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,h,m),l.defined(a._offsetAttribute)){const t=a._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,e=_.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);_.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}}const w=_.attributes,v=e.BoundingSphere.fromVertices(w.position.values,void 0,3);return b.position||(_.attributes.position.values=void 0),new d.Geometry({attributes:w,indices:_.indices,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:v,offsetAttribute:a._offsetAttribute})},et.createShadowVolume=function(t,e,r){const a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new et({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:g.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(et.prototype,{rectangle:{get:function(){return l.defined(this._rectangle)||(this._rectangle=tt(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return l.defined(e)&&(t=et.unpack(t,e)),t._ellipsoid=a.Ellipsoid.clone(t._ellipsoid),et.createGeometry(t)}}));
