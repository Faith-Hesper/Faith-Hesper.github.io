define(["exports","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Matrix2-e52b9454","./Ellipsoid-fa58f06f","./EllipsoidTangentPlane-8f36a7e0","./Math-56779564","./Matrix3-59918a96","./PolylinePipeline-206d6e54","./Transforms-b1e48e05","./defaultValue-9f6a6288","./defined-64766648"],(function(e,a,t,n,r,i,s,o,l,c,C,u){"use strict";var d=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2});const g={};function y(e,a){u.defined(g[e])||(g[e]=!0,console.warn(C.defaultValue(a,e)))}y.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",y.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",y.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",y.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const h=[new t.Cartesian3,new t.Cartesian3],m=new t.Cartesian3,f=new t.Cartesian3,p=new t.Cartesian3,w=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,P=new t.Cartesian3,M=new t.Cartesian3,T=new t.Cartesian3,b=new t.Cartesian3,B=new t.Cartesian3,z={};let S=new r.Cartographic;function A(e,a,n,r){const i=e[0],s=e[1],o=t.Cartesian3.angleBetween(i,s),l=Math.ceil(o/r),c=new Array(l);let C;if(a===n){for(C=0;C<l;C++)c[C]=a;return c.push(n),c}const u=(n-a)/l;for(C=1;C<l;C++){const e=a+C*u;c[C]=e}return c[0]=a,c.push(n),c}const D=new t.Cartesian3,R=new t.Cartesian3;const O=new t.Cartesian3(-1,0,0);let V=new n.Matrix4;const I=new n.Matrix4;let v=new o.Matrix3;const G=o.Matrix3.IDENTITY.clone(),N=new t.Cartesian3,H=new n.Cartesian4,L=new t.Cartesian3;function j(e,r,s,l,C,u,d,g){let y=N,h=H;V=c.Transforms.eastNorthUpToFixedFrame(e,C,V),y=n.Matrix4.multiplyByPointAsVector(V,O,y),y=t.Cartesian3.normalize(y,y);const m=function(e,n,r,s){const o=new i.EllipsoidTangentPlane(r,s),l=o.projectPointOntoPlane(t.Cartesian3.add(r,e,D),D),c=o.projectPointOntoPlane(t.Cartesian3.add(r,n,R),R),C=a.Cartesian2.angleBetween(l,c);return c.x*l.y-c.y*l.x>=0?-C:C}(y,r,e,C);v=o.Matrix3.fromRotationZ(m,v),L.z=u,V=n.Matrix4.multiplyTransformation(V,n.Matrix4.fromRotationTranslation(v,L,I),V);const f=G;f[0]=d;for(let e=0;e<g;e++)for(let e=0;e<s.length;e+=3)h=t.Cartesian3.fromArray(s,e,h),h=o.Matrix3.multiplyByVector(f,h,h),h=n.Matrix4.multiplyByPoint(V,h,h),l.push(h.x,h.y,h.z);return l}const Q=new t.Cartesian3;function q(e,a,n,r,i,s,o){for(let l=0;l<e.length;l+=3){r=j(t.Cartesian3.fromArray(e,l,Q),a,n,r,i,s[l/3],o,1)}return r}function F(e,a){const t=e.length,n=new Array(3*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;for(let a=0;a<t;a++)n[r++]=e[a].x-i,n[r++]=0,n[r++]=e[a].y-s;return n}const U=new c.Quaternion,_=new t.Cartesian3,Z=new o.Matrix3;function W(e,a,n,r,i,l,C,u,g,y){const h=t.Cartesian3.angleBetween(t.Cartesian3.subtract(a,e,b),t.Cartesian3.subtract(n,e,B)),m=r===d.BEVELED?0:Math.ceil(h/s.CesiumMath.toRadians(5));let f,p,w;if(f=i?o.Matrix3.fromQuaternion(c.Quaternion.fromAxisAngle(t.Cartesian3.negate(e,b),h/(m+1),U),Z):o.Matrix3.fromQuaternion(c.Quaternion.fromAxisAngle(e,h/(m+1),U),Z),a=t.Cartesian3.clone(a,_),m>0){const n=y?2:1;for(let r=0;r<m;r++)a=o.Matrix3.multiplyByVector(f,a,a),p=t.Cartesian3.subtract(a,e,b),p=t.Cartesian3.normalize(p,p),i||(p=t.Cartesian3.negate(p,p)),w=l.scaleToGeodeticSurface(a,B),C=j(w,p,u,C,l,g,1,n)}else p=t.Cartesian3.subtract(a,e,b),p=t.Cartesian3.normalize(p,p),i||(p=t.Cartesian3.negate(p,p)),w=l.scaleToGeodeticSurface(a,B),C=j(w,p,u,C,l,g,1,1),n=t.Cartesian3.clone(n,_),p=t.Cartesian3.subtract(n,e,b),p=t.Cartesian3.normalize(p,p),i||(p=t.Cartesian3.negate(p,p)),w=l.scaleToGeodeticSurface(n,B),C=j(w,p,u,C,l,g,1,1);return C}z.removeDuplicatesFromShape=function(e){const t=e.length,n=[];for(let r=t-1,i=0;i<t;r=i++){const t=e[r],s=e[i];a.Cartesian2.equals(t,s)||n.push(s)}return n},z.angleIsGreaterThanPi=function(e,a,n,r){const s=new i.EllipsoidTangentPlane(n,r),o=s.projectPointOntoPlane(t.Cartesian3.add(n,e,D),D),l=s.projectPointOntoPlane(t.Cartesian3.add(n,a,R),R);return l.x*o.y-l.y*o.x>=0};const Y=new t.Cartesian3,k=new t.Cartesian3;z.computePositions=function(e,a,n,r,i){const o=r._ellipsoid,c=function(e,a){const t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];S=a.cartesianToCartographic(r,S),t[n]=S.height,e[n]=a.scaleToGeodeticSurface(r,r)}return t}(e,o),C=r._granularity,u=r._cornerType,g=i?function(e,a){const t=e.length,n=new Array(6*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;let o=e[0];n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s;for(let a=1;a<t;a++){o=e[a];const t=o.x-i,l=o.y-s;n[r++]=t,n[r++]=0,n[r++]=l,n[r++]=t,n[r++]=0,n[r++]=l}return o=e[0],n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s,n}(a,n):F(a,n),B=i?F(a,n):void 0,D=n.height/2,R=n.width/2;let O=e.length,V=[],I=i?[]:void 0,v=m,G=f,N=p,H=w,L=x,Q=E,U=P,_=M,Z=T,J=e[0],K=e[1];H=o.geodeticSurfaceNormal(J,H),v=t.Cartesian3.subtract(K,J,v),v=t.Cartesian3.normalize(v,v),_=t.Cartesian3.cross(H,v,_),_=t.Cartesian3.normalize(_,_);let X,$,ee=c[0],ae=c[1];i&&(I=j(J,_,B,I,o,ee+D,1,1)),Z=t.Cartesian3.clone(J,Z),J=K,G=t.Cartesian3.negate(v,G);for(let a=1;a<O-1;a++){const n=i?2:1;if(K=e[a+1],J.equals(K)){y("Positions are too close and are considered equivalent with rounding error.");continue}v=t.Cartesian3.subtract(K,J,v),v=t.Cartesian3.normalize(v,v),N=t.Cartesian3.add(v,G,N),N=t.Cartesian3.normalize(N,N),H=o.geodeticSurfaceNormal(J,H);const r=t.Cartesian3.multiplyByScalar(H,t.Cartesian3.dot(v,H),Y);t.Cartesian3.subtract(v,r,r),t.Cartesian3.normalize(r,r);const m=t.Cartesian3.multiplyByScalar(H,t.Cartesian3.dot(G,H),k);t.Cartesian3.subtract(G,m,m),t.Cartesian3.normalize(m,m);if(!s.CesiumMath.equalsEpsilon(Math.abs(t.Cartesian3.dot(r,m)),1,s.CesiumMath.EPSILON7)){N=t.Cartesian3.cross(N,H,N),N=t.Cartesian3.cross(H,N,N),N=t.Cartesian3.normalize(N,N);const e=1/Math.max(.25,t.Cartesian3.magnitude(t.Cartesian3.cross(N,G,b))),a=z.angleIsGreaterThanPi(v,G,J,o);a?(L=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(N,e*R,N),L),Q=t.Cartesian3.add(L,t.Cartesian3.multiplyByScalar(_,R,Q),Q),h[0]=t.Cartesian3.clone(Z,h[0]),h[1]=t.Cartesian3.clone(Q,h[1]),X=A(h,ee+D,ae+D,C),$=l.PolylinePipeline.generateArc({positions:h,granularity:C,ellipsoid:o}),V=q($,_,g,V,o,X,1),_=t.Cartesian3.cross(H,v,_),_=t.Cartesian3.normalize(_,_),U=t.Cartesian3.add(L,t.Cartesian3.multiplyByScalar(_,R,U),U),u===d.ROUNDED||u===d.BEVELED?W(L,Q,U,u,a,o,V,g,ae+D,i):(N=t.Cartesian3.negate(N,N),V=j(J,N,g,V,o,ae+D,e,n)),Z=t.Cartesian3.clone(U,Z)):(L=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(N,e*R,N),L),Q=t.Cartesian3.add(L,t.Cartesian3.multiplyByScalar(_,-R,Q),Q),h[0]=t.Cartesian3.clone(Z,h[0]),h[1]=t.Cartesian3.clone(Q,h[1]),X=A(h,ee+D,ae+D,C),$=l.PolylinePipeline.generateArc({positions:h,granularity:C,ellipsoid:o}),V=q($,_,g,V,o,X,1),_=t.Cartesian3.cross(H,v,_),_=t.Cartesian3.normalize(_,_),U=t.Cartesian3.add(L,t.Cartesian3.multiplyByScalar(_,-R,U),U),u===d.ROUNDED||u===d.BEVELED?W(L,Q,U,u,a,o,V,g,ae+D,i):V=j(J,N,g,V,o,ae+D,e,n),Z=t.Cartesian3.clone(U,Z)),G=t.Cartesian3.negate(v,G)}else V=j(Z,_,g,V,o,ee+D,1,1),Z=J;ee=ae,ae=c[a+1],J=K}h[0]=t.Cartesian3.clone(Z,h[0]),h[1]=t.Cartesian3.clone(J,h[1]),X=A(h,ee+D,ae+D,C),$=l.PolylinePipeline.generateArc({positions:h,granularity:C,ellipsoid:o}),V=q($,_,g,V,o,X,1),i&&(I=j(J,_,B,I,o,ae+D,1,1)),O=V.length;const te=i?O+I.length:O,ne=new Float64Array(te);return ne.set(V),i&&ne.set(I,O),ne};var J=z;e.CornerType=d,e.PolylineVolumeGeometryLibrary=J,e.oneTimeWarning=y}));
