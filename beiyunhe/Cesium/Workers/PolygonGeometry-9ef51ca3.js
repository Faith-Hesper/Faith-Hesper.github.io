define(["exports","./ArcType-26a3f38d","./BoundingRectangle-3100662d","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./EllipsoidGeodesic-9e013872","./EllipsoidTangentPlane-8f36a7e0","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryInstance-a555221e","./GeometryOffsetAttribute-2579b8d2","./GeometryPipeline-92c34dd1","./IndexDatatype-ed8b21cb","./Math-56779564","./Matrix3-59918a96","./PolygonGeometryLibrary-37fe200f","./PolygonPipeline-d79010c3","./VertexFormat-01d05a0d"],(function(t,e,o,r,i,n,a,s,l,u,c,y,p,g,d,m,h,f,b,_,P,C,x){"use strict";const w=new a.Cartographic,T=new a.Cartographic;function I(t,e,o,r){const i=r.cartesianToCartographic(t,w).height,n=r.cartesianToCartographic(e,T);n.height=i,r.cartographicToCartesian(n,e);const a=r.cartesianToCartographic(o,T);a.height=i-100,r.cartographicToCartesian(a,o)}const A=new o.BoundingRectangle,v=new n.Cartesian3,E=new n.Cartesian3,G=new n.Cartesian3,O=new n.Cartesian3,V=new n.Cartesian3,L=new n.Cartesian3;let H=new n.Cartesian3,N=new n.Cartesian3,D=new n.Cartesian3;const F=new i.Cartesian2,R=new i.Cartesian2,M=new n.Cartesian3,S=new r.Quaternion,k=new _.Matrix3,B=new _.Matrix3;function z(t){const e=t.vertexFormat,o=t.geometry,a=t.shadowVolume,l=o.attributes.position.values,c=u.defined(o.attributes.st)?o.attributes.st.values:void 0;let y=l.length;const p=t.wall,d=t.top||p,h=t.bottom||p;if(e.st||e.normal||e.tangent||e.bitangent||a){const m=t.boundingRectangle,f=t.tangentPlane,P=t.ellipsoid,C=t.stRotation,x=t.perPositionHeight,w=F;w.x=m.x,w.y=m.y;const T=e.st?new Float32Array(y/3*2):void 0;let A;e.normal&&(A=x&&d&&!p?o.attributes.normal.values:new Float32Array(y));const z=e.tangent?new Float32Array(y):void 0,W=e.bitangent?new Float32Array(y):void 0,Y=a?new Float32Array(y):void 0;let U=0,j=0,Q=E,q=G,K=O,Z=!0,J=k,X=B;if(0!==C){let t=r.Quaternion.fromAxisAngle(f._plane.normal,C,S);J=_.Matrix3.fromQuaternion(t,J),t=r.Quaternion.fromAxisAngle(f._plane.normal,-C,S),X=_.Matrix3.fromQuaternion(t,X)}else J=_.Matrix3.clone(_.Matrix3.IDENTITY,J),X=_.Matrix3.clone(_.Matrix3.IDENTITY,X);let $=0,tt=0;d&&h&&($=y/2,tt=y/3,y/=2);for(let o=0;o<y;o+=3){const r=n.Cartesian3.fromArray(l,o,M);if(e.st&&!u.defined(c)){let t=_.Matrix3.multiplyByVector(J,r,v);t=P.scaleToGeodeticSurface(t,t);const e=f.projectPointOntoPlane(t,R);i.Cartesian2.subtract(e,w,e);const o=b.CesiumMath.clamp(e.x/m.width,0,1),n=b.CesiumMath.clamp(e.y/m.height,0,1);h&&(T[U+tt]=o,T[U+1+tt]=n),d&&(T[U]=o,T[U+1]=n),U+=2}if(e.normal||e.tangent||e.bitangent||a){const i=j+1,s=j+2;if(p){if(o+3<y){const t=n.Cartesian3.fromArray(l,o+3,V);if(Z){const e=n.Cartesian3.fromArray(l,o+y,L);x&&I(r,t,e,P),n.Cartesian3.subtract(t,r,t),n.Cartesian3.subtract(e,r,e),Q=n.Cartesian3.normalize(n.Cartesian3.cross(e,t,Q),Q),Z=!1}n.Cartesian3.equalsEpsilon(t,r,b.CesiumMath.EPSILON10)&&(Z=!0)}(e.tangent||e.bitangent)&&(K=P.geodeticSurfaceNormal(r,K),e.tangent&&(q=n.Cartesian3.normalize(n.Cartesian3.cross(K,Q,q),q)))}else Q=P.geodeticSurfaceNormal(r,Q),(e.tangent||e.bitangent)&&(x&&(H=n.Cartesian3.fromArray(A,j,H),N=n.Cartesian3.cross(n.Cartesian3.UNIT_Z,H,N),N=n.Cartesian3.normalize(_.Matrix3.multiplyByVector(X,N,N),N),e.bitangent&&(D=n.Cartesian3.normalize(n.Cartesian3.cross(H,N,D),D))),q=n.Cartesian3.cross(n.Cartesian3.UNIT_Z,Q,q),q=n.Cartesian3.normalize(_.Matrix3.multiplyByVector(X,q,q),q),e.bitangent&&(K=n.Cartesian3.normalize(n.Cartesian3.cross(Q,q,K),K)));e.normal&&(t.wall?(A[j+$]=Q.x,A[i+$]=Q.y,A[s+$]=Q.z):h&&(A[j+$]=-Q.x,A[i+$]=-Q.y,A[s+$]=-Q.z),(d&&!x||p)&&(A[j]=Q.x,A[i]=Q.y,A[s]=Q.z)),a&&(p&&(Q=P.geodeticSurfaceNormal(r,Q)),Y[j+$]=-Q.x,Y[i+$]=-Q.y,Y[s+$]=-Q.z),e.tangent&&(t.wall?(z[j+$]=q.x,z[i+$]=q.y,z[s+$]=q.z):h&&(z[j+$]=-q.x,z[i+$]=-q.y,z[s+$]=-q.z),d&&(x?(z[j]=N.x,z[i]=N.y,z[s]=N.z):(z[j]=q.x,z[i]=q.y,z[s]=q.z))),e.bitangent&&(h&&(W[j+$]=K.x,W[i+$]=K.y,W[s+$]=K.z),d&&(x?(W[j]=D.x,W[i]=D.y,W[s]=D.z):(W[j]=K.x,W[i]=K.y,W[s]=K.z))),j+=3}}e.st&&!u.defined(c)&&(o.attributes.st=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:T})),e.normal&&(o.attributes.normal=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A})),e.tangent&&(o.attributes.tangent=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:z})),e.bitangent&&(o.attributes.bitangent=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:W})),a&&(o.attributes.extrudeDirection=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y}))}if(t.extrude&&u.defined(t.offsetAttribute)){const e=l.length/3;let r=new Uint8Array(e);if(t.offsetAttribute===m.GeometryOffsetAttribute.TOP)d&&h||p?r=r.fill(1,0,e/2):d&&(r=r.fill(1));else{const e=t.offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1;r=r.fill(e)}o.attributes.applyOffset=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return o}const W=new a.Cartographic,Y=new a.Cartographic,U={westOverIDL:0,eastOverIDL:0};let j=new c.EllipsoidGeodesic;function Q(t,o,r,n,a){if(a=l.defaultValue(a,new i.Rectangle),!u.defined(t)||t.length<3)return a.west=0,a.north=0,a.south=0,a.east=0,a;if(r===e.ArcType.RHUMB)return i.Rectangle.fromCartesianArray(t,o,a);j.ellipsoid.equals(o)||(j=new c.EllipsoidGeodesic(void 0,void 0,o)),a.west=Number.POSITIVE_INFINITY,a.east=Number.NEGATIVE_INFINITY,a.south=Number.POSITIVE_INFINITY,a.north=Number.NEGATIVE_INFINITY,U.westOverIDL=Number.POSITIVE_INFINITY,U.eastOverIDL=Number.NEGATIVE_INFINITY;const s=1/b.CesiumMath.chordLength(n,o.maximumRadius),y=t.length;let p,g=o.cartesianToCartographic(t[0],Y),d=W;for(let e=1;e<y;e++)p=d,d=g,g=o.cartesianToCartographic(t[e],p),j.setEndPoints(d,g),K(j,s,a,U);return p=d,d=g,g=o.cartesianToCartographic(t[0],p),j.setEndPoints(d,g),K(j,s,a,U),a.east-a.west>U.eastOverIDL-U.westOverIDL&&(a.west=U.westOverIDL,a.east=U.eastOverIDL,a.east>b.CesiumMath.PI&&(a.east=a.east-b.CesiumMath.TWO_PI),a.west>b.CesiumMath.PI&&(a.west=a.west-b.CesiumMath.TWO_PI)),a}const q=new a.Cartographic;function K(t,e,o,r){const i=t.surfaceDistance,n=Math.ceil(i*e),a=n>0?i/(n-1):Number.POSITIVE_INFINITY;let s=0;for(let e=0;e<n;e++){const e=t.interpolateUsingSurfaceDistance(s,q);s+=a;const i=e.longitude,n=e.latitude;o.west=Math.min(o.west,i),o.east=Math.max(o.east,i),o.south=Math.min(o.south,n),o.north=Math.max(o.north,n);const l=i>=0?i:i+b.CesiumMath.TWO_PI;r.westOverIDL=Math.min(r.westOverIDL,l),r.eastOverIDL=Math.max(r.eastOverIDL,l)}}const Z=[];function J(t,e,o,r,i,n,a,s,l,c){const p={walls:[]};let g;if(a||s){const i=P.PolygonGeometryLibrary.createGeometryFromPositions(t,e,o,r,n,l,c),y=i.attributes.position.values,m=i.indices;let h,b;if(a&&s){const t=y.concat(y);h=t.length/3,b=f.IndexDatatype.createTypedArray(h,2*m.length),b.set(m);const e=m.length,r=h/2;for(g=0;g<e;g+=3){const t=b[g]+r,o=b[g+1]+r,i=b[g+2]+r;b[g+e]=i,b[g+1+e]=o,b[g+2+e]=t}if(i.attributes.position.values=t,n&&l.normal){const e=i.attributes.normal.values;i.attributes.normal.values=new Float32Array(t.length),i.attributes.normal.values.set(e)}if(l.st&&u.defined(o)){const t=i.attributes.st.values;i.attributes.st.values=new Float32Array(2*h),i.attributes.st.values=t.concat(t)}i.indices=b}else if(s){for(h=y.length/3,b=f.IndexDatatype.createTypedArray(h,m.length),g=0;g<m.length;g+=3)b[g]=m[g+2],b[g+1]=m[g+1],b[g+2]=m[g];i.indices=b}p.topAndBottom=new d.GeometryInstance({geometry:i})}let m=i.outerRing,h=y.EllipsoidTangentPlane.fromPoints(m,t),b=h.projectPointsOntoPlane(m,Z),_=C.PolygonPipeline.computeWindingOrder2D(b);_===C.WindingOrder.CLOCKWISE&&(m=m.slice().reverse());let x=P.PolygonGeometryLibrary.computeWallGeometry(m,o,t,r,n,c);p.walls.push(new d.GeometryInstance({geometry:x}));const w=i.holes;for(g=0;g<w.length;g++){let e=w[g];h=y.EllipsoidTangentPlane.fromPoints(e,t),b=h.projectPointsOntoPlane(e,Z),_=C.PolygonPipeline.computeWindingOrder2D(b),_===C.WindingOrder.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),x=P.PolygonGeometryLibrary.computeWallGeometry(e,o,t,r,n,c),p.walls.push(new d.GeometryInstance({geometry:x}))}return p}function X(t){const o=t.polygonHierarchy,r=l.defaultValue(t.vertexFormat,x.VertexFormat.DEFAULT),s=l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84),c=l.defaultValue(t.granularity,b.CesiumMath.RADIANS_PER_DEGREE),y=l.defaultValue(t.stRotation,0),p=t.textureCoordinates,g=l.defaultValue(t.perPositionHeight,!1),d=g&&u.defined(t.extrudedHeight);let m=l.defaultValue(t.height,0),h=l.defaultValue(t.extrudedHeight,m);if(!d){const t=Math.max(m,h);h=Math.min(m,h),m=t}this._vertexFormat=x.VertexFormat.clone(r),this._ellipsoid=a.Ellipsoid.clone(s),this._granularity=c,this._stRotation=y,this._height=m,this._extrudedHeight=h,this._closeTop=l.defaultValue(t.closeTop,!0),this._closeBottom=l.defaultValue(t.closeBottom,!0),this._polygonHierarchy=o,this._perPositionHeight=g,this._perPositionHeightExtrude=d,this._shadowVolume=l.defaultValue(t.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=l.defaultValue(t.arcType,e.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=p,this.packedLength=P.PolygonGeometryLibrary.computeHierarchyPackedLength(o,n.Cartesian3)+a.Ellipsoid.packedLength+x.VertexFormat.packedLength+(p?P.PolygonGeometryLibrary.computeHierarchyPackedLength(p,i.Cartesian2):1)+12}X.fromPositions=function(t){return new X({polygonHierarchy:{positions:(t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},X.pack=function(t,e,o){return o=l.defaultValue(o,0),o=P.PolygonGeometryLibrary.packPolygonHierarchy(t._polygonHierarchy,e,o,n.Cartesian3),a.Ellipsoid.pack(t._ellipsoid,e,o),o+=a.Ellipsoid.packedLength,x.VertexFormat.pack(t._vertexFormat,e,o),o+=x.VertexFormat.packedLength,e[o++]=t._height,e[o++]=t._extrudedHeight,e[o++]=t._granularity,e[o++]=t._stRotation,e[o++]=t._perPositionHeightExtrude?1:0,e[o++]=t._perPositionHeight?1:0,e[o++]=t._closeTop?1:0,e[o++]=t._closeBottom?1:0,e[o++]=t._shadowVolume?1:0,e[o++]=l.defaultValue(t._offsetAttribute,-1),e[o++]=t._arcType,u.defined(t._textureCoordinates)?o=P.PolygonGeometryLibrary.packPolygonHierarchy(t._textureCoordinates,e,o,i.Cartesian2):e[o++]=-1,e[o++]=t.packedLength,e};const $=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),tt=new x.VertexFormat,et={polygonHierarchy:{}};X.unpack=function(t,e,o){e=l.defaultValue(e,0);const r=P.PolygonGeometryLibrary.unpackPolygonHierarchy(t,e,n.Cartesian3);e=r.startingIndex,delete r.startingIndex;const s=a.Ellipsoid.unpack(t,e,$);e+=a.Ellipsoid.packedLength;const c=x.VertexFormat.unpack(t,e,tt);e+=x.VertexFormat.packedLength;const y=t[e++],p=t[e++],g=t[e++],d=t[e++],m=1===t[e++],h=1===t[e++],f=1===t[e++],b=1===t[e++],_=1===t[e++],C=t[e++],w=t[e++],T=-1===t[e]?void 0:P.PolygonGeometryLibrary.unpackPolygonHierarchy(t,e,i.Cartesian2);u.defined(T)?(e=T.startingIndex,delete T.startingIndex):e++;const I=t[e++];return u.defined(o)||(o=new X(et)),o._polygonHierarchy=r,o._ellipsoid=a.Ellipsoid.clone(s,o._ellipsoid),o._vertexFormat=x.VertexFormat.clone(c,o._vertexFormat),o._height=y,o._extrudedHeight=p,o._granularity=g,o._stRotation=d,o._perPositionHeightExtrude=m,o._perPositionHeight=h,o._closeTop=f,o._closeBottom=b,o._shadowVolume=_,o._offsetAttribute=-1===C?void 0:C,o._arcType=w,o._textureCoordinates=T,o.packedLength=I,o},X.computeRectangle=function(t,o){const r=l.defaultValue(t.granularity,b.CesiumMath.RADIANS_PER_DEGREE),i=l.defaultValue(t.arcType,e.ArcType.GEODESIC),n=t.polygonHierarchy,s=l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84);return Q(n.positions,s,i,r,o)},X.createGeometry=function(t){const e=t._vertexFormat,o=t._ellipsoid,i=t._granularity,n=t._stRotation,a=t._polygonHierarchy,l=t._perPositionHeight,c=t._closeTop,_=t._closeBottom,x=t._arcType,w=t._textureCoordinates,T=u.defined(w);let I=a.positions;if(I.length<3)return;const v=y.EllipsoidTangentPlane.fromPoints(I,o),E=P.PolygonGeometryLibrary.polygonsFromHierarchy(a,T,v.projectPointsOntoPlane.bind(v),!l,o),G=E.hierarchy,O=E.polygons,V=T?P.PolygonGeometryLibrary.polygonsFromHierarchy(w,!0,(function(t){return t}),!1).polygons:void 0;if(0===G.length)return;I=G[0].outerRing;const L=P.PolygonGeometryLibrary.computeBoundingRectangle(v.plane.normal,v.projectPointOntoPlane.bind(v),I,n,A),H=[],N=t._height,D=t._extrudedHeight,F={perPositionHeight:l,vertexFormat:e,geometry:void 0,tangentPlane:v,boundingRectangle:L,ellipsoid:o,stRotation:n,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:x};let R;if(t._perPositionHeightExtrude||!b.CesiumMath.equalsEpsilon(N,D,0,b.CesiumMath.EPSILON2))for(F.extrude=!0,F.top=c,F.bottom=_,F.shadowVolume=t._shadowVolume,F.offsetAttribute=t._offsetAttribute,R=0;R<O.length;R++){const t=J(o,O[R],T?V[R]:void 0,i,G[R],l,c,_,e,x);let r;c&&_?(r=t.topAndBottom,F.geometry=P.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(r.geometry,N,D,o,l)):c?(r=t.topAndBottom,r.geometry.attributes.position.values=C.PolygonPipeline.scaleToGeodeticHeight(r.geometry.attributes.position.values,N,o,!l),F.geometry=r.geometry):_&&(r=t.topAndBottom,r.geometry.attributes.position.values=C.PolygonPipeline.scaleToGeodeticHeight(r.geometry.attributes.position.values,D,o,!0),F.geometry=r.geometry),(c||_)&&(F.wall=!1,r.geometry=z(F),H.push(r));const n=t.walls;F.wall=!0;for(let t=0;t<n.length;t++){const e=n[t];F.geometry=P.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,N,D,o,l),e.geometry=z(F),H.push(e)}}else for(R=0;R<O.length;R++){const r=new d.GeometryInstance({geometry:P.PolygonGeometryLibrary.createGeometryFromPositions(o,O[R],T?V[R]:void 0,i,l,e,x)});if(r.geometry.attributes.position.values=C.PolygonPipeline.scaleToGeodeticHeight(r.geometry.attributes.position.values,N,o,!l),F.geometry=r.geometry,r.geometry=z(F),u.defined(t._offsetAttribute)){const e=r.geometry.attributes.position.values.length,o=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(o);r.geometry.attributes.applyOffset=new g.GeometryAttribute({componentDatatype:s.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}H.push(r)}const M=h.GeometryPipeline.combineInstances(H)[0];M.attributes.position.values=new Float64Array(M.attributes.position.values),M.indices=f.IndexDatatype.createTypedArray(M.attributes.position.values.length/3,M.indices);const S=M.attributes,k=r.BoundingSphere.fromVertices(S.position.values);return e.position||delete S.position,new p.Geometry({attributes:S,indices:M.indices,primitiveType:M.primitiveType,boundingSphere:k,offsetAttribute:t._offsetAttribute})},X.createShadowVolume=function(t,e,o){const r=t._granularity,i=t._ellipsoid,n=e(r,i),a=o(r,i);return new X({polygonHierarchy:t._polygonHierarchy,ellipsoid:i,stRotation:t._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:n,height:a,vertexFormat:x.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(X.prototype,{rectangle:{get:function(){if(!u.defined(this._rectangle)){const t=this._polygonHierarchy.positions;this._rectangle=Q(t,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return u.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const o=t._ellipsoid,r=t._polygonHierarchy.positions,i=t.rectangle;return p.Geometry._textureCoordinateRotationPoints(r,e,o,i)}(this)),this._textureCoordinateRotationPoints}}}),t.PolygonGeometry=X}));
