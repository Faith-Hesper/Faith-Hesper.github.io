define(["./AttributeCompression-44abee07","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./defined-64766648","./EllipsoidalOccluder-23ed042c","./IndexDatatype-ed8b21cb","./Math-56779564","./OrientedBoundingBox-fa9d7c73","./TerrainEncoding-68597868","./createTaskProcessorWorker-03824364","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./WebGLConstants-7f557f93","./Matrix2-e52b9454","./Matrix3-59918a96","./RuntimeError-cfbf2bc8","./GeographicProjection-868b0b16","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./EllipsoidTangentPlane-8f36a7e0","./AxisAlignedBoundingBox-8b4e9f9c","./IntersectionTests-39c3b1c1","./Plane-f9bf6226"],(function(e,t,n,i,s,r,h,o,u,p,d,l,a,c,f,g,m,x,C,w,B,y,I,A,v,b){"use strict";const T={clipTriangleAtAxisAlignedThreshold:function(e,t,n,i,s,h){let o,u,p;r.defined(h)?h.length=0:h=[],t?(o=n<e,u=i<e,p=s<e):(o=n>e,u=i>e,p=s>e);const d=o+u+p;let l,a,c,f,g,m;return 1===d?o?(l=(e-n)/(i-n),a=(e-n)/(s-n),h.push(1),h.push(2),1!==a&&(h.push(-1),h.push(0),h.push(2),h.push(a)),1!==l&&(h.push(-1),h.push(0),h.push(1),h.push(l))):u?(c=(e-i)/(s-i),f=(e-i)/(n-i),h.push(2),h.push(0),1!==f&&(h.push(-1),h.push(1),h.push(0),h.push(f)),1!==c&&(h.push(-1),h.push(1),h.push(2),h.push(c))):p&&(g=(e-s)/(n-s),m=(e-s)/(i-s),h.push(0),h.push(1),1!==m&&(h.push(-1),h.push(2),h.push(1),h.push(m)),1!==g&&(h.push(-1),h.push(2),h.push(0),h.push(g))):2===d?o||n===e?u||i===e?p||s===e||(a=(e-n)/(s-n),c=(e-i)/(s-i),h.push(2),h.push(-1),h.push(0),h.push(2),h.push(a),h.push(-1),h.push(1),h.push(2),h.push(c)):(m=(e-s)/(i-s),l=(e-n)/(i-n),h.push(1),h.push(-1),h.push(2),h.push(1),h.push(m),h.push(-1),h.push(0),h.push(1),h.push(l)):(f=(e-i)/(n-i),g=(e-s)/(n-s),h.push(0),h.push(-1),h.push(1),h.push(0),h.push(f),h.push(-1),h.push(2),h.push(0),h.push(g)):3!==d&&(h.push(0),h.push(1),h.push(2)),h},computeBarycentricCoordinates:function(e,t,n,s,h,o,u,p,d){const l=n-u,a=u-h,c=o-p,f=s-p,g=1/(c*l+a*f),m=t-p,x=e-u,C=(c*x+a*m)*g,w=(-f*x+l*m)*g,B=1-C-w;return r.defined(d)?(d.x=C,d.y=w,d.z=B,d):new i.Cartesian3(C,w,B)},computeLineSegmentLineSegmentIntersection:function(e,t,i,s,h,o,u,p,d){const l=(p-o)*(i-e)-(u-h)*(s-t);if(0===l)return;const a=((u-h)*(t-o)-(p-o)*(e-h))/l,c=((i-e)*(t-o)-(s-t)*(e-h))/l;return a>=0&&a<=1&&c>=0&&c<=1?(r.defined(d)||(d=new n.Cartesian2),d.x=e+a*(i-e),d.y=t+a*(s-t),d):void 0}};var M=T;const z=32767,V=16383,E=[],N=[],R=[],H=new s.Cartographic;let O=new i.Cartesian3;const P=[],F=[],S=[],U=[],k=[],W=new i.Cartesian3,D=new t.BoundingSphere,X=new p.OrientedBoundingBox,Y=new n.Cartesian2,K=new i.Cartesian3;function L(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}L.prototype.clone=function(e){return r.defined(e)||(e=new L),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},L.prototype.initializeIndexed=function(e,t,n,i,s){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=n,this.normalBuffer=i,this.index=s,this.first=void 0,this.second=void 0,this.ratio=void 0},L.prototype.initializeFromClipResult=function(e,t,n){let i=t+1;return-1!==e[t]?n[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=n[e[i]],++i,this.second=n[e[i]],++i,this.ratio=e[i],++i),i},L.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},L.prototype.isIndexed=function(){return r.defined(this.index)},L.prototype.getH=function(){return r.defined(this.index)?this.heightBuffer[this.index]:u.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},L.prototype.getU=function(){return r.defined(this.index)?this.uBuffer[this.index]:u.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},L.prototype.getV=function(){return r.defined(this.index)?this.vBuffer[this.index]:u.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let G=new n.Cartesian2,Z=-1;const _=[new i.Cartesian3,new i.Cartesian3],j=[new i.Cartesian3,new i.Cartesian3];function q(t,n){++Z;let s=_[Z],r=j[Z];return s=e.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),s),r=e.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),r),O=i.Cartesian3.lerp(s,r,t.ratio,O),i.Cartesian3.normalize(O,O),e.AttributeCompression.octEncode(O,n),--Z,n}L.prototype.getNormalX=function(){return r.defined(this.index)?this.normalBuffer[2*this.index]:(G=q(this,G),G.x)},L.prototype.getNormalY=function(){return r.defined(this.index)?this.normalBuffer[2*this.index+1]:(G=q(this,G),G.y)};const J=[];function Q(e,t,n,i,s,h,o,u,p){if(0===o.length)return;let d=0,l=0;for(;l<o.length;)l=J[d++].initializeFromClipResult(o,l,u);for(let s=0;s<d;++s){const o=J[s];if(o.isIndexed())o.newIndex=h[o.index],o.uBuffer=e,o.vBuffer=t,o.heightBuffer=n,p&&(o.normalBuffer=i);else{const s=o.getKey();if(r.defined(h[s]))o.newIndex=h[s];else{const r=e.length;e.push(o.getU()),t.push(o.getV()),n.push(o.getH()),p&&(i.push(o.getNormalX()),i.push(o.getNormalY())),o.newIndex=r,h[s]=r}}}3===d?(s.push(J[0].newIndex),s.push(J[1].newIndex),s.push(J[2].newIndex)):4===d&&(s.push(J[0].newIndex),s.push(J[1].newIndex),s.push(J[2].newIndex),s.push(J[0].newIndex),s.push(J[2].newIndex),s.push(J[3].newIndex))}return J.push(new L),J.push(new L),J.push(new L),J.push(new L),l.createTaskProcessorWorker((function(e,r){const l=e.isEastChild,a=e.isNorthChild,c=l?V:0,f=l?z:V,g=a?V:0,m=a?z:V,x=P,C=F,w=S,B=k;x.length=0,C.length=0,w.length=0,B.length=0;const y=U;y.length=0;const I={},A=e.vertices;let v=e.indices;v=v.subarray(0,e.indexCountWithoutSkirts);const b=d.TerrainEncoding.clone(e.encoding),T=b.hasVertexNormals;let G=0;const Z=e.vertexCountWithoutSkirts,_=e.minimumHeight,j=e.maximumHeight,q=new Array(Z),J=new Array(Z),$=new Array(Z),ee=T?new Array(2*Z):void 0;let te,ne,ie,se,re;for(ne=0,ie=0;ne<Z;++ne,ie+=2){const e=b.decodeTextureCoordinates(A,ne,Y);if(te=b.decodeHeight(A,ne),se=u.CesiumMath.clamp(e.x*z|0,0,z),re=u.CesiumMath.clamp(e.y*z|0,0,z),$[ne]=u.CesiumMath.clamp((te-_)/(j-_)*z|0,0,z),se<20&&(se=0),re<20&&(re=0),z-se<20&&(se=z),z-re<20&&(re=z),q[ne]=se,J[ne]=re,T){const e=b.getOctEncodedNormal(A,ne,K);ee[ie]=e.x,ee[ie+1]=e.y}(l&&se>=V||!l&&se<=V)&&(a&&re>=V||!a&&re<=V)&&(I[ne]=G,x.push(se),C.push(re),w.push($[ne]),T&&(B.push(ee[ie]),B.push(ee[ie+1])),++G)}const he=[];he.push(new L),he.push(new L),he.push(new L);const oe=[];let ue,pe;for(oe.push(new L),oe.push(new L),oe.push(new L),ne=0;ne<v.length;ne+=3){const e=v[ne],t=v[ne+1],n=v[ne+2],i=q[e],s=q[t],r=q[n];he[0].initializeIndexed(q,J,$,ee,e),he[1].initializeIndexed(q,J,$,ee,t),he[2].initializeIndexed(q,J,$,ee,n);const h=M.clipTriangleAtAxisAlignedThreshold(V,l,i,s,r,E);ue=0,ue>=h.length||(ue=oe[0].initializeFromClipResult(h,ue,he),ue>=h.length||(ue=oe[1].initializeFromClipResult(h,ue,he),ue>=h.length||(ue=oe[2].initializeFromClipResult(h,ue,he),pe=M.clipTriangleAtAxisAlignedThreshold(V,a,oe[0].getV(),oe[1].getV(),oe[2].getV(),N),Q(x,C,w,B,y,I,pe,oe,T),ue<h.length&&(oe[2].clone(oe[1]),oe[2].initializeFromClipResult(h,ue,he),pe=M.clipTriangleAtAxisAlignedThreshold(V,a,oe[0].getV(),oe[1].getV(),oe[2].getV(),N),Q(x,C,w,B,y,I,pe,oe,T)))))}const de=l?-32767:0,le=a?-32767:0,ae=[],ce=[],fe=[],ge=[];let me=Number.MAX_VALUE,xe=-me;const Ce=R;Ce.length=0;const we=s.Ellipsoid.clone(e.ellipsoid),Be=n.Rectangle.clone(e.childRectangle),ye=Be.north,Ie=Be.south;let Ae=Be.east;const ve=Be.west;for(Ae<ve&&(Ae+=u.CesiumMath.TWO_PI),ne=0;ne<x.length;++ne)se=Math.round(x[ne]),se<=c?(ae.push(ne),se=0):se>=f?(fe.push(ne),se=z):se=2*se+de,x[ne]=se,re=Math.round(C[ne]),re<=g?(ce.push(ne),re=0):re>=m?(ge.push(ne),re=z):re=2*re+le,C[ne]=re,te=u.CesiumMath.lerp(_,j,w[ne]/z),te<me&&(me=te),te>xe&&(xe=te),w[ne]=te,H.longitude=u.CesiumMath.lerp(ve,Ae,se/z),H.latitude=u.CesiumMath.lerp(Ie,ye,re/z),H.height=te,we.cartographicToCartesian(H,O),Ce.push(O.x),Ce.push(O.y),Ce.push(O.z);const be=t.BoundingSphere.fromVertices(Ce,i.Cartesian3.ZERO,3,D),Te=p.OrientedBoundingBox.fromRectangle(Be,me,xe,we,X),Me=new h.EllipsoidalOccluder(we).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(be.center,Ce,3,be.center,me,W),ze=xe-me,Ve=new Uint16Array(x.length+C.length+w.length);for(ne=0;ne<x.length;++ne)Ve[ne]=x[ne];let Ee=x.length;for(ne=0;ne<C.length;++ne)Ve[Ee+ne]=C[ne];for(Ee+=C.length,ne=0;ne<w.length;++ne)Ve[Ee+ne]=z*(w[ne]-me)/ze;const Ne=o.IndexDatatype.createTypedArray(x.length,y);let Re;if(T){const e=new Uint8Array(B);r.push(Ve.buffer,Ne.buffer,e.buffer),Re=e.buffer}else r.push(Ve.buffer,Ne.buffer);return{vertices:Ve.buffer,encodedNormals:Re,indices:Ne.buffer,minimumHeight:me,maximumHeight:xe,westIndices:ae,southIndices:ce,eastIndices:fe,northIndices:ge,boundingSphere:be,orientedBoundingBox:Te,horizonOcclusionPoint:Me}}))}));
