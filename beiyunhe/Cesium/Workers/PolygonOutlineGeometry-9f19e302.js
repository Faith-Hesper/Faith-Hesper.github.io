define(["exports","./ArcType-26a3f38d","./Transforms-b1e48e05","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./Ellipsoid-fa58f06f","./EllipsoidTangentPlane-8f36a7e0","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryInstance-a555221e","./GeometryOffsetAttribute-2579b8d2","./GeometryPipeline-92c34dd1","./IndexDatatype-ed8b21cb","./Math-56779564","./PolygonGeometryLibrary-37fe200f","./PolygonPipeline-d79010c3"],(function(e,t,i,o,r,n,a,l,s,y,u,p,d,c,g,f,h,m,b){"use strict";const P=[],E=[];function A(e,i,o,n,a){const l=s.EllipsoidTangentPlane.fromPoints(i,e).projectPointsOntoPlane(i,P);let c,g;b.PolygonPipeline.computeWindingOrder2D(l)===b.WindingOrder.CLOCKWISE&&(l.reverse(),i=i.slice().reverse());let h=i.length,A=0;if(n)for(c=new Float64Array(2*h*3),g=0;g<h;g++){const e=i[g],t=i[(g+1)%h];c[A++]=e.x,c[A++]=e.y,c[A++]=e.z,c[A++]=t.x,c[A++]=t.y,c[A++]=t.z}else{let r=0;if(a===t.ArcType.GEODESIC)for(g=0;g<h;g++)r+=m.PolygonGeometryLibrary.subdivideLineCount(i[g],i[(g+1)%h],o);else if(a===t.ArcType.RHUMB)for(g=0;g<h;g++)r+=m.PolygonGeometryLibrary.subdivideRhumbLineCount(e,i[g],i[(g+1)%h],o);for(c=new Float64Array(3*r),g=0;g<h;g++){let r;a===t.ArcType.GEODESIC?r=m.PolygonGeometryLibrary.subdivideLine(i[g],i[(g+1)%h],o,E):a===t.ArcType.RHUMB&&(r=m.PolygonGeometryLibrary.subdivideRhumbLine(e,i[g],i[(g+1)%h],o,E));const n=r.length;for(let e=0;e<n;++e)c[A++]=r[e]}}h=c.length/3;const G=2*h,_=f.IndexDatatype.createTypedArray(h,G);for(A=0,g=0;g<h-1;g++)_[A++]=g,_[A++]=g+1;return _[A++]=h-1,_[A++]=0,new d.GeometryInstance({geometry:new y.Geometry({attributes:new p.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:_,primitiveType:y.PrimitiveType.LINES})})}function G(e,i,o,n,a){const l=s.EllipsoidTangentPlane.fromPoints(i,e).projectPointsOntoPlane(i,P);let c,g;b.PolygonPipeline.computeWindingOrder2D(l)===b.WindingOrder.CLOCKWISE&&(l.reverse(),i=i.slice().reverse());let h=i.length;const A=new Array(h);let G=0;if(n)for(c=new Float64Array(2*h*3*2),g=0;g<h;++g){A[g]=G/3;const e=i[g],t=i[(g+1)%h];c[G++]=e.x,c[G++]=e.y,c[G++]=e.z,c[G++]=t.x,c[G++]=t.y,c[G++]=t.z}else{let r=0;if(a===t.ArcType.GEODESIC)for(g=0;g<h;g++)r+=m.PolygonGeometryLibrary.subdivideLineCount(i[g],i[(g+1)%h],o);else if(a===t.ArcType.RHUMB)for(g=0;g<h;g++)r+=m.PolygonGeometryLibrary.subdivideRhumbLineCount(e,i[g],i[(g+1)%h],o);for(c=new Float64Array(3*r*2),g=0;g<h;++g){let r;A[g]=G/3,a===t.ArcType.GEODESIC?r=m.PolygonGeometryLibrary.subdivideLine(i[g],i[(g+1)%h],o,E):a===t.ArcType.RHUMB&&(r=m.PolygonGeometryLibrary.subdivideRhumbLine(e,i[g],i[(g+1)%h],o,E));const n=r.length;for(let e=0;e<n;++e)c[G++]=r[e]}}h=c.length/6;const _=A.length,H=2*(2*h+_),L=f.IndexDatatype.createTypedArray(h+_,H);for(G=0,g=0;g<h;++g)L[G++]=g,L[G++]=(g+1)%h,L[G++]=g+h,L[G++]=(g+1)%h+h;for(g=0;g<_;g++){const e=A[g];L[G++]=e,L[G++]=e+h}return new d.GeometryInstance({geometry:new y.Geometry({attributes:new p.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})}),indices:L,primitiveType:y.PrimitiveType.LINES})})}function _(e){const i=e.polygonHierarchy,r=n.defaultValue(e.ellipsoid,l.Ellipsoid.WGS84),s=n.defaultValue(e.granularity,h.CesiumMath.RADIANS_PER_DEGREE),y=n.defaultValue(e.perPositionHeight,!1),u=y&&a.defined(e.extrudedHeight),p=n.defaultValue(e.arcType,t.ArcType.GEODESIC);let d=n.defaultValue(e.height,0),c=n.defaultValue(e.extrudedHeight,d);if(!u){const e=Math.max(d,c);c=Math.min(d,c),d=e}this._ellipsoid=l.Ellipsoid.clone(r),this._granularity=s,this._height=d,this._extrudedHeight=c,this._arcType=p,this._polygonHierarchy=i,this._perPositionHeight=y,this._perPositionHeightExtrude=u,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=m.PolygonGeometryLibrary.computeHierarchyPackedLength(i,o.Cartesian3)+l.Ellipsoid.packedLength+8}_.pack=function(e,t,i){return i=n.defaultValue(i,0),i=m.PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,i,o.Cartesian3),l.Ellipsoid.pack(e._ellipsoid,t,i),i+=l.Ellipsoid.packedLength,t[i++]=e._height,t[i++]=e._extrudedHeight,t[i++]=e._granularity,t[i++]=e._perPositionHeightExtrude?1:0,t[i++]=e._perPositionHeight?1:0,t[i++]=e._arcType,t[i++]=n.defaultValue(e._offsetAttribute,-1),t[i]=e.packedLength,t};const H=l.Ellipsoid.clone(l.Ellipsoid.UNIT_SPHERE),L={polygonHierarchy:{}};_.unpack=function(e,t,i){t=n.defaultValue(t,0);const r=m.PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,o.Cartesian3);t=r.startingIndex,delete r.startingIndex;const s=l.Ellipsoid.unpack(e,t,H);t+=l.Ellipsoid.packedLength;const y=e[t++],u=e[t++],p=e[t++],d=1===e[t++],c=1===e[t++],g=e[t++],f=e[t++],h=e[t];return a.defined(i)||(i=new _(L)),i._polygonHierarchy=r,i._ellipsoid=l.Ellipsoid.clone(s,i._ellipsoid),i._height=y,i._extrudedHeight=u,i._granularity=p,i._perPositionHeight=c,i._perPositionHeightExtrude=d,i._arcType=g,i._offsetAttribute=-1===f?void 0:f,i.packedLength=h,i},_.fromPositions=function(e){return new _({polygonHierarchy:{positions:(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute})},_.createGeometry=function(e){const t=e._ellipsoid,o=e._granularity,n=e._polygonHierarchy,l=e._perPositionHeight,s=e._arcType,p=m.PolygonGeometryLibrary.polygonOutlinesFromHierarchy(n,!l,t);if(0===p.length)return;let d;const f=[],P=h.CesiumMath.chordLength(o,t.maximumRadius),E=e._height,_=e._extrudedHeight;let H,L;if(e._perPositionHeightExtrude||!h.CesiumMath.equalsEpsilon(E,_,0,h.CesiumMath.EPSILON2))for(L=0;L<p.length;L++){if(d=G(t,p[L],P,l,s),d.geometry=m.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(d.geometry,E,_,t,l),a.defined(e._offsetAttribute)){const t=d.geometry.attributes.position.values.length/3;let i=new Uint8Array(t);e._offsetAttribute===c.GeometryOffsetAttribute.TOP?i=i.fill(1,0,t/2):(H=e._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,i=i.fill(H)),d.geometry.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}f.push(d)}else for(L=0;L<p.length;L++){if(d=A(t,p[L],P,l,s),d.geometry.attributes.position.values=b.PolygonPipeline.scaleToGeodeticHeight(d.geometry.attributes.position.values,E,t,!l),a.defined(e._offsetAttribute)){const t=d.geometry.attributes.position.values.length;H=e._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1;const i=new Uint8Array(t/3).fill(H);d.geometry.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}f.push(d)}const T=g.GeometryPipeline.combineInstances(f)[0],O=i.BoundingSphere.fromVertices(T.attributes.position.values);return new y.Geometry({attributes:T.attributes,indices:T.indices,primitiveType:T.primitiveType,boundingSphere:O,offsetAttribute:e._offsetAttribute})},e.PolygonOutlineGeometry=_}));
