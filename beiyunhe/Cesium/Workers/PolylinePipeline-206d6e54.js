define(["exports","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./defaultValue-9f6a6288","./defined-64766648","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6","./IntersectionTests-39c3b1c1","./Math-56779564","./Matrix2-e52b9454","./Plane-f9bf6226"],(function(e,t,a,n,i,r,o,s,c,l,u){"use strict";const h={numberOfPoints:function(e,a,n){const i=t.Cartesian3.distance(e,a);return Math.ceil(i/n)},numberOfPointsRhumbLine:function(e,t,a){const n=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(n/(a*a))))}},f=new a.Cartographic;h.extractHeights=function(e,t){const a=e.length,n=new Array(a);for(let i=0;i<a;i++){const a=e[i];n[i]=t.cartesianToCartographic(a,f).height}return n};const g=new l.Matrix4,C=new t.Cartesian3,p=new t.Cartesian3,d=new u.Plane(t.Cartesian3.UNIT_X,0),m=new t.Cartesian3,w=new u.Plane(t.Cartesian3.UNIT_X,0),P=new t.Cartesian3,T=new t.Cartesian3,y=[];function A(e,t,a){const n=y;let i;if(n.length=e,t===a){for(i=0;i<e;i++)n[i]=t;return n}const r=(a-t)/e;for(i=0;i<e;i++){const e=t+i*r;n[i]=e}return n}const E=new a.Cartographic,M=new a.Cartographic,R=new t.Cartesian3,S=new t.Cartesian3,b=new t.Cartesian3,x=new r.EllipsoidGeodesic;let D=new o.EllipsoidRhumbLine;function N(e,a,n,i,r,o,s,c){const l=i.scaleToGeodeticSurface(e,S),u=i.scaleToGeodeticSurface(a,b),f=h.numberOfPoints(e,a,n),g=i.cartesianToCartographic(l,E),C=i.cartesianToCartographic(u,M),p=A(f,r,o);x.setEndPoints(g,C);const d=x.surfaceDistance/f;let m=c;g.height=r;let w=i.cartographicToCartesian(g,R);t.Cartesian3.pack(w,s,m),m+=3;for(let e=1;e<f;e++){const a=x.interpolateUsingSurfaceDistance(e*d,M);a.height=p[e],w=i.cartographicToCartesian(a,R),t.Cartesian3.pack(w,s,m),m+=3}return m}function G(e,a,n,i,r,s,c,l){const u=i.cartesianToCartographic(e,E),f=i.cartesianToCartographic(a,M),g=h.numberOfPointsRhumbLine(u,f,n);u.height=0,f.height=0;const C=A(g,r,s);D.ellipsoid.equals(i)||(D=new o.EllipsoidRhumbLine(void 0,void 0,i)),D.setEndPoints(u,f);const p=D.surfaceDistance/g;let d=l;u.height=r;let m=i.cartographicToCartesian(u,R);t.Cartesian3.pack(m,c,d),d+=3;for(let e=1;e<g;e++){const a=D.interpolateUsingSurfaceDistance(e*p,M);a.height=C[e],m=i.cartographicToCartesian(a,R),t.Cartesian3.pack(m,c,d),d+=3}return d}h.wrapLongitude=function(e,a){const r=[],o=[];if(i.defined(e)&&e.length>0){a=n.defaultValue(a,l.Matrix4.IDENTITY);const c=l.Matrix4.inverseTransformation(a,g),h=l.Matrix4.multiplyByPoint(c,t.Cartesian3.ZERO,C),f=t.Cartesian3.normalize(l.Matrix4.multiplyByPointAsVector(c,t.Cartesian3.UNIT_Y,p),p),y=u.Plane.fromPointNormal(h,f,d),A=t.Cartesian3.normalize(l.Matrix4.multiplyByPointAsVector(c,t.Cartesian3.UNIT_X,m),m),E=u.Plane.fromPointNormal(h,A,w);let M=1;r.push(t.Cartesian3.clone(e[0]));let R=r[0];const S=e.length;for(let a=1;a<S;++a){const n=e[a];if(u.Plane.getPointDistance(E,R)<0||u.Plane.getPointDistance(E,n)<0){const e=s.IntersectionTests.lineSegmentPlane(R,n,y,P);if(i.defined(e)){const a=t.Cartesian3.multiplyByScalar(f,5e-9,T);u.Plane.getPointDistance(y,R)<0&&t.Cartesian3.negate(a,a),r.push(t.Cartesian3.add(e,a,new t.Cartesian3)),o.push(M+1),t.Cartesian3.negate(a,a),r.push(t.Cartesian3.add(e,a,new t.Cartesian3)),M=1}}r.push(t.Cartesian3.clone(e[a])),M++,R=n}o.push(M)}return{positions:r,lengths:o}},h.generateArc=function(e){i.defined(e)||(e={});const r=e.positions,o=r.length,s=n.defaultValue(e.ellipsoid,a.Ellipsoid.WGS84);let l=n.defaultValue(e.height,0);const u=Array.isArray(l);if(o<1)return[];if(1===o){const e=s.scaleToGeodeticSurface(r[0],S);if(l=u?l[0]:l,0!==l){const a=s.geodeticSurfaceNormal(e,R);t.Cartesian3.multiplyByScalar(a,l,a),t.Cartesian3.add(e,a,e)}return[e.x,e.y,e.z]}let f=e.minDistance;if(!i.defined(f)){const t=n.defaultValue(e.granularity,c.CesiumMath.RADIANS_PER_DEGREE);f=c.CesiumMath.chordLength(t,s.maximumRadius)}let g,C=0;for(g=0;g<o-1;g++)C+=h.numberOfPoints(r[g],r[g+1],f);const p=3*(C+1),d=new Array(p);let m=0;for(g=0;g<o-1;g++){m=N(r[g],r[g+1],f,s,u?l[g]:l,u?l[g+1]:l,d,m)}y.length=0;const w=r[o-1],P=s.cartesianToCartographic(w,E);P.height=u?l[o-1]:l;const T=s.cartographicToCartesian(P,R);return t.Cartesian3.pack(T,d,p-3),d};const I=new a.Cartographic,V=new a.Cartographic;h.generateRhumbArc=function(e){i.defined(e)||(e={});const r=e.positions,o=r.length,s=n.defaultValue(e.ellipsoid,a.Ellipsoid.WGS84);let l=n.defaultValue(e.height,0);const u=Array.isArray(l);if(o<1)return[];if(1===o){const e=s.scaleToGeodeticSurface(r[0],S);if(l=u?l[0]:l,0!==l){const a=s.geodeticSurfaceNormal(e,R);t.Cartesian3.multiplyByScalar(a,l,a),t.Cartesian3.add(e,a,e)}return[e.x,e.y,e.z]}const f=n.defaultValue(e.granularity,c.CesiumMath.RADIANS_PER_DEGREE);let g,C,p=0,d=s.cartesianToCartographic(r[0],I);for(g=0;g<o-1;g++)C=s.cartesianToCartographic(r[g+1],V),p+=h.numberOfPointsRhumbLine(d,C,f),d=a.Cartographic.clone(C,I);const m=3*(p+1),w=new Array(m);let P=0;for(g=0;g<o-1;g++){P=G(r[g],r[g+1],f,s,u?l[g]:l,u?l[g+1]:l,w,P)}y.length=0;const T=r[o-1],A=s.cartesianToCartographic(T,E);A.height=u?l[o-1]:l;const M=s.cartographicToCartesian(A,R);return t.Cartesian3.pack(M,w,m-3),w},h.generateCartesianArc=function(e){const a=h.generateArc(e),n=a.length/3,i=new Array(n);for(let e=0;e<n;e++)i[e]=t.Cartesian3.unpack(a,3*e);return i},h.generateCartesianRhumbArc=function(e){const a=h.generateRhumbArc(e),n=a.length/3,i=new Array(n);for(let e=0;e<n;e++)i[e]=t.Cartesian3.unpack(a,3*e);return i};var k=h;e.PolylinePipeline=k}));
