define(["exports","./Transforms-b1e48e05","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./EllipseGeometryLibrary-6f58b026","./Ellipsoid-fa58f06f","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-ed8b21cb","./Math-56779564"],(function(e,t,i,r,n,o,a,s,l,u,d,c,p,f){"use strict";const m=new i.Cartesian3;let h=new i.Cartesian3;const y=new t.BoundingSphere,A=new t.BoundingSphere;function _(e){const t=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).center,r=n.defaultValue(e.ellipsoid,s.Ellipsoid.WGS84),o=e.semiMajorAxis,a=e.semiMinorAxis,l=n.defaultValue(e.granularity,f.CesiumMath.RADIANS_PER_DEGREE),u=n.defaultValue(e.height,0),d=n.defaultValue(e.extrudedHeight,u);this._center=i.Cartesian3.clone(t),this._semiMajorAxis=o,this._semiMinorAxis=a,this._ellipsoid=s.Ellipsoid.clone(r),this._rotation=n.defaultValue(e.rotation,0),this._height=Math.max(d,u),this._granularity=l,this._extrudedHeight=Math.min(d,u),this._numberOfVerticalLines=Math.max(n.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}_.packedLength=i.Cartesian3.packedLength+s.Ellipsoid.packedLength+8,_.pack=function(e,t,r){return r=n.defaultValue(r,0),i.Cartesian3.pack(e._center,t,r),r+=i.Cartesian3.packedLength,s.Ellipsoid.pack(e._ellipsoid,t,r),r+=s.Ellipsoid.packedLength,t[r++]=e._semiMajorAxis,t[r++]=e._semiMinorAxis,t[r++]=e._rotation,t[r++]=e._height,t[r++]=e._granularity,t[r++]=e._extrudedHeight,t[r++]=e._numberOfVerticalLines,t[r]=n.defaultValue(e._offsetAttribute,-1),t};const b=new i.Cartesian3,g=new s.Ellipsoid,x={center:b,ellipsoid:g,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};_.unpack=function(e,t,r){t=n.defaultValue(t,0);const a=i.Cartesian3.unpack(e,t,b);t+=i.Cartesian3.packedLength;const l=s.Ellipsoid.unpack(e,t,g);t+=s.Ellipsoid.packedLength;const u=e[t++],d=e[t++],c=e[t++],p=e[t++],f=e[t++],m=e[t++],h=e[t++],y=e[t];return o.defined(r)?(r._center=i.Cartesian3.clone(a,r._center),r._ellipsoid=s.Ellipsoid.clone(l,r._ellipsoid),r._semiMajorAxis=u,r._semiMinorAxis=d,r._rotation=c,r._height=p,r._granularity=f,r._extrudedHeight=m,r._numberOfVerticalLines=h,r._offsetAttribute=-1===y?void 0:y,r):(x.height=p,x.extrudedHeight=m,x.granularity=f,x.rotation=c,x.semiMajorAxis=u,x.semiMinorAxis=d,x.numberOfVerticalLines=h,x.offsetAttribute=-1===y?void 0:y,new _(x))},_.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const s=e._height,_=e._extrudedHeight,b=!f.CesiumMath.equalsEpsilon(s,_,0,f.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const g={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:s,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let x;if(b)g.extrudedHeight=_,g.offsetAttribute=e._offsetAttribute,x=function(e){const s=e.center,l=e.ellipsoid,h=e.semiMajorAxis;let _=i.Cartesian3.multiplyByScalar(l.geodeticSurfaceNormal(s,m),e.height,m);y.center=i.Cartesian3.add(s,_,y.center),y.radius=h,_=i.Cartesian3.multiplyByScalar(l.geodeticSurfaceNormal(s,_),e.extrudedHeight,_),A.center=i.Cartesian3.add(s,_,A.center),A.radius=h;let b=a.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions;const g=new d.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.EllipseGeometryLibrary.raisePositionsToHeight(b,e,!0)})});b=g.position.values;const x=t.BoundingSphere.union(y,A);let E=b.length/3;if(o.defined(e.offsetAttribute)){let t=new Uint8Array(E);if(e.offsetAttribute===c.GeometryOffsetAttribute.TOP)t=t.fill(1,0,E/2);else{const i=e.offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}g.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let M=n.defaultValue(e.numberOfVerticalLines,16);M=f.CesiumMath.clamp(M,0,E/2);const C=p.IndexDatatype.createTypedArray(E,2*E+2*M);E/=2;let G,L,O=0;for(G=0;G<E;++G)C[O++]=G,C[O++]=(G+1)%E,C[O++]=G+E,C[O++]=(G+1)%E+E;if(M>0){const e=Math.min(M,E);L=Math.round(E/e);const t=Math.min(L*M,E);for(G=0;G<t;G+=L)C[O++]=G,C[O++]=G+E}return{boundingSphere:x,attributes:g,indices:C}}(g);else if(x=function(e){const n=e.center;h=i.Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(n,h),e.height,h),h=i.Cartesian3.add(n,h,h);const o=new t.BoundingSphere(h,e.semiMajorAxis),s=a.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions,l=new d.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.EllipseGeometryLibrary.raisePositionsToHeight(s,e,!1)})}),c=s.length/3,f=p.IndexDatatype.createTypedArray(c,2*c);let m=0;for(let e=0;e<c;++e)f[m++]=e,f[m++]=(e+1)%c;return{boundingSphere:o,attributes:l,indices:f}}(g),o.defined(e._offsetAttribute)){const t=x.attributes.position.values.length,i=e._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(t/3).fill(i);x.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new l.Geometry({attributes:x.attributes,indices:x.indices,primitiveType:l.PrimitiveType.LINES,boundingSphere:x.boundingSphere,offsetAttribute:e._offsetAttribute})},e.EllipseOutlineGeometry=_}));
