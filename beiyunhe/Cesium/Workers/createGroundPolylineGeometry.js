define(["./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./defaultValue-9f6a6288","./defined-64766648","./GeographicTilingScheme-49f4aa7a","./Resource-be841477","./ArcType-26a3f38d","./arrayRemoveDuplicates-d0608faf","./ComponentDatatype-63fd8cd4","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6","./EncodedCartesian3-e0f0a7d1","./GeographicProjection-868b0b16","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./IntersectionTests-39c3b1c1","./Math-56779564","./Matrix3-59918a96","./Plane-f9bf6226","./WebMercatorProjection-78306e76","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93"],(function(e,a,t,n,i,r,s,o,c,l,u,C,p,d,h,g,m,f,w,y,E,M,T,k,P,S,_){"use strict";const O=new t.Cartesian3,A=new t.Cartesian3,x=new n.Cartographic,I=new t.Cartesian3,b=new t.Cartesian3,L=new e.BoundingSphere,N=new s.GeographicTilingScheme,R=[new n.Cartographic,new n.Cartographic,new n.Cartographic,new n.Cartographic],D=new a.Cartesian2,z={};function H(e){n.Cartographic.fromRadians(e.east,e.north,0,R[0]),n.Cartographic.fromRadians(e.west,e.north,0,R[1]),n.Cartographic.fromRadians(e.east,e.south,0,R[2]),n.Cartographic.fromRadians(e.west,e.south,0,R[3]);let a=0,t=0,i=0,r=0;const s=z._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let a=0;a<4;++a){const t=R[a];if(N.positionToTileXY(t,o,D),0===a)i=D.x,r=D.y;else if(i!==D.x||r!==D.y){e=!0;break}}if(e)break;a=i,t=r}if(0!==o)return{x:a,y:t,level:o>s?s:o-1}}z.initialize=function(){let a=z._initPromise;return r.defined(a)||(a=o.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){z._terrainHeights=e})),z._initPromise=a),a},z.getMinimumMaximumHeights=function(e,s){s=i.defaultValue(s,n.Ellipsoid.WGS84);const o=H(e);let c=z._defaultMinTerrainHeight,l=z._defaultMaxTerrainHeight;if(r.defined(o)){const n=`${o.level}-${o.x}-${o.y}`,i=z._terrainHeights[n];r.defined(i)&&(c=i[0],l=i[1]),s.cartographicToCartesian(a.Rectangle.northeast(e,x),O),s.cartographicToCartesian(a.Rectangle.southwest(e,x),A),t.Cartesian3.midpoint(A,O,I);const u=s.scaleToGeodeticSurface(I,b);if(r.defined(u)){const e=t.Cartesian3.distance(I,u);c=Math.min(c,-e)}else c=z._defaultMinTerrainHeight}return c=Math.max(z._defaultMinTerrainHeight,c),{minimumTerrainHeight:c,maximumTerrainHeight:l}},z.getBoundingSphere=function(a,t){t=i.defaultValue(t,n.Ellipsoid.WGS84);const s=H(a);let o=z._defaultMaxTerrainHeight;if(r.defined(s)){const e=`${s.level}-${s.x}-${s.y}`,a=z._terrainHeights[e];r.defined(a)&&(o=a[1])}const c=e.BoundingSphere.fromRectangle3D(a,t,0);return e.BoundingSphere.fromRectangle3D(a,t,o,L),e.BoundingSphere.union(c,L,c)},z._terrainHeightsMaxLevel=6,z._defaultMaxTerrainHeight=9e3,z._defaultMinTerrainHeight=-1e5,z._terrainHeights=void 0,z._initPromise=void 0,Object.defineProperties(z,{initialized:{get:function(){return r.defined(z._terrainHeights)}}});var G=z;const B=[h.GeographicProjection,M.WebMercatorProjection],j=B.length,V=Math.cos(w.CesiumMath.toRadians(30)),q=Math.cos(w.CesiumMath.toRadians(150)),v=0,F=1e3;function W(e){const a=(e=i.defaultValue(e,i.defaultValue.EMPTY_OBJECT)).positions;this.width=i.defaultValue(e.width,1),this._positions=a,this.granularity=i.defaultValue(e.granularity,9999),this.loop=i.defaultValue(e.loop,!1),this.arcType=i.defaultValue(e.arcType,c.ArcType.GEODESIC),this._ellipsoid=n.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(W.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+n.Ellipsoid.packedLength+1+1}}}),W.setProjectionAndEllipsoid=function(e,a){let t=0;for(let e=0;e<j;e++)if(a instanceof B[e]){t=e;break}e._projectionIndex=t,e._ellipsoid=a.ellipsoid};const U=new t.Cartesian3,Y=new t.Cartesian3,$=new t.Cartesian3;function Z(e,a,n,i,r){const s=te(i,e,0,U),o=te(i,e,n,Y),c=te(i,a,0,$),l=ne(o,s,Y),u=ne(c,s,$);return t.Cartesian3.cross(u,l,r),t.Cartesian3.normalize(r,r)}const J=new n.Cartographic,Q=new t.Cartesian3,X=new t.Cartesian3,K=new t.Cartesian3;function ee(e,a,n,i,r,s,o,l,u,d,h){if(0===r)return;let g;s===c.ArcType.GEODESIC?g=new C.EllipsoidGeodesic(e,a,o):s===c.ArcType.RHUMB&&(g=new p.EllipsoidRhumbLine(e,a,o));const m=g.surfaceDistance;if(m<r)return;const f=Z(e,a,i,o,K),w=Math.ceil(m/r),y=m/w;let E=y;const M=w-1;let T=l.length;for(let e=0;e<M;e++){const e=g.interpolateUsingSurfaceDistance(E,J),a=te(o,e,n,Q),r=te(o,e,i,X);t.Cartesian3.pack(f,l,T),t.Cartesian3.pack(a,u,T),t.Cartesian3.pack(r,d,T),h.push(e.latitude),h.push(e.longitude),T+=3,E+=y}}const ae=new n.Cartographic;function te(e,a,t,i){return n.Cartographic.clone(a,ae),ae.height=t,n.Cartographic.toCartesian(ae,e,i)}function ne(e,a,n){return t.Cartesian3.subtract(e,a,n),t.Cartesian3.normalize(n,n),n}function ie(e,a,n,i){return i=ne(e,a,i),i=t.Cartesian3.cross(i,n,i),i=t.Cartesian3.normalize(i,i),i=t.Cartesian3.cross(n,i,i)}W.pack=function(e,a,r){let s=i.defaultValue(r,0);const o=e._positions,c=o.length;a[s++]=c;for(let e=0;e<c;++e){const n=o[e];t.Cartesian3.pack(n,a,s),s+=3}return a[s++]=e.granularity,a[s++]=e.loop?1:0,a[s++]=e.arcType,n.Ellipsoid.pack(e._ellipsoid,a,s),s+=n.Ellipsoid.packedLength,a[s++]=e._projectionIndex,a[s++]=e._scene3DOnly?1:0,a},W.unpack=function(e,a,s){let o=i.defaultValue(a,0);const c=e[o++],l=new Array(c);for(let a=0;a<c;a++)l[a]=t.Cartesian3.unpack(e,o),o+=3;const u=e[o++],C=1===e[o++],p=e[o++],d=n.Ellipsoid.unpack(e,o);o+=n.Ellipsoid.packedLength;const h=e[o++],g=1===e[o++];return r.defined(s)||(s=new W({positions:l})),s._positions=l,s.granularity=u,s.loop=C,s.arcType=p,s._ellipsoid=d,s._projectionIndex=h,s._scene3DOnly=g,s};const re=new t.Cartesian3,se=new t.Cartesian3,oe=new t.Cartesian3,ce=new t.Cartesian3;function le(e,a,n,i,r){const s=ne(n,a,ce),o=ie(e,a,s,re),c=ie(i,a,s,se);if(w.CesiumMath.equalsEpsilon(t.Cartesian3.dot(o,c),-1,w.CesiumMath.EPSILON5))return r=t.Cartesian3.cross(s,o,r),r=t.Cartesian3.normalize(r,r);r=t.Cartesian3.add(c,o,r),r=t.Cartesian3.normalize(r,r);const l=t.Cartesian3.cross(s,r,oe);return t.Cartesian3.dot(c,l)<0&&(r=t.Cartesian3.negate(r,r)),r}const ue=E.Plane.fromPointNormal(t.Cartesian3.ZERO,t.Cartesian3.UNIT_Y),Ce=new t.Cartesian3,pe=new t.Cartesian3,de=new t.Cartesian3,he=new t.Cartesian3,ge=new t.Cartesian3,me=new t.Cartesian3,fe=new n.Cartographic,we=new n.Cartographic,ye=new n.Cartographic;W.createGeometry=function(i){const s=!i._scene3DOnly;let o=i.loop;const C=i._ellipsoid,h=i.granularity,y=i.arcType,E=new B[i._projectionIndex](C),M=v,T=F;let k,P;const S=i._positions,_=S.length;let O,A,x,I;2===_&&(o=!1);const b=new p.EllipsoidRhumbLine(void 0,void 0,C);let L,N,R;const D=[S[0]];for(P=0;P<_-1;P++)O=S[P],A=S[P+1],L=f.IntersectionTests.lineSegmentPlane(O,A,ue,me),!r.defined(L)||t.Cartesian3.equalsEpsilon(L,O,w.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,A,w.CesiumMath.EPSILON7)||(i.arcType===c.ArcType.GEODESIC?D.push(t.Cartesian3.clone(L)):i.arcType===c.ArcType.RHUMB&&(R=C.cartesianToCartographic(L,fe).longitude,x=C.cartesianToCartographic(O,fe),I=C.cartesianToCartographic(A,we),b.setEndPoints(x,I),N=b.findIntersectionWithLongitude(R,ye),L=C.cartographicToCartesian(N,me),!r.defined(L)||t.Cartesian3.equalsEpsilon(L,O,w.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,A,w.CesiumMath.EPSILON7)||D.push(t.Cartesian3.clone(L)))),D.push(A);o&&(O=S[_-1],A=S[0],L=f.IntersectionTests.lineSegmentPlane(O,A,ue,me),!r.defined(L)||t.Cartesian3.equalsEpsilon(L,O,w.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,A,w.CesiumMath.EPSILON7)||(i.arcType===c.ArcType.GEODESIC?D.push(t.Cartesian3.clone(L)):i.arcType===c.ArcType.RHUMB&&(R=C.cartesianToCartographic(L,fe).longitude,x=C.cartesianToCartographic(O,fe),I=C.cartesianToCartographic(A,we),b.setEndPoints(x,I),N=b.findIntersectionWithLongitude(R,ye),L=C.cartographicToCartesian(N,me),!r.defined(L)||t.Cartesian3.equalsEpsilon(L,O,w.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(L,A,w.CesiumMath.EPSILON7)||D.push(t.Cartesian3.clone(L)))));let z=D.length,H=new Array(z);for(P=0;P<z;P++){const e=n.Cartographic.fromCartesian(D[P],C);e.height=0,H[P]=e}if(H=l.arrayRemoveDuplicates(H,n.Cartographic.equalsEpsilon),z=H.length,z<2)return;const j=[],q=[],W=[],U=[];let Y=Ce,$=pe,J=de,Q=he,X=ge;const K=H[0],ae=H[1];for(Y=te(C,H[z-1],M,Y),Q=te(C,ae,M,Q),$=te(C,K,M,$),J=te(C,K,T,J),X=o?le(Y,$,J,Q,X):Z(K,ae,T,C,X),t.Cartesian3.pack(X,q,0),t.Cartesian3.pack($,W,0),t.Cartesian3.pack(J,U,0),j.push(K.latitude),j.push(K.longitude),ee(K,ae,M,T,h,y,C,q,W,U,j),P=1;P<z-1;++P){Y=t.Cartesian3.clone($,Y),$=t.Cartesian3.clone(Q,$);const e=H[P];te(C,e,T,J),te(C,H[P+1],M,Q),le(Y,$,J,Q,X),k=q.length,t.Cartesian3.pack(X,q,k),t.Cartesian3.pack($,W,k),t.Cartesian3.pack(J,U,k),j.push(e.latitude),j.push(e.longitude),ee(H[P],H[P+1],M,T,h,y,C,q,W,U,j)}const ie=H[z-1],re=H[z-2];if($=te(C,ie,M,$),J=te(C,ie,T,J),o){const e=H[0];Y=te(C,re,M,Y),Q=te(C,e,M,Q),X=le(Y,$,J,Q,X)}else X=Z(re,ie,T,C,X);if(k=q.length,t.Cartesian3.pack(X,q,k),t.Cartesian3.pack($,W,k),t.Cartesian3.pack(J,U,k),j.push(ie.latitude),j.push(ie.longitude),o){for(ee(ie,K,M,T,h,y,C,q,W,U,j),k=q.length,P=0;P<3;++P)q[k+P]=q[P],W[k+P]=W[P],U[k+P]=U[P];j.push(K.latitude),j.push(K.longitude)}return function(n,i,r,s,o,c,l){let C,p;const h=i._ellipsoid,f=r.length/3-1,y=8*f,E=4*y,M=36*f,T=y>65535?new Uint32Array(M):new Uint16Array(M),k=new Float64Array(3*y),P=new Float32Array(E),S=new Float32Array(E),_=new Float32Array(E),O=new Float32Array(E),A=new Float32Array(E);let x,I,b,L;l&&(x=new Float32Array(E),I=new Float32Array(E),b=new Float32Array(E),L=new Float32Array(2*y));const N=c.length/2;let R=0;const D=Re;D.height=0;const z=De;z.height=0;let H=ze,B=He;if(l)for(p=0,C=1;C<N;C++)D.latitude=c[p],D.longitude=c[p+1],z.latitude=c[p+2],z.longitude=c[p+3],H=i.project(D,H),B=i.project(z,B),R+=t.Cartesian3.distance(H,B),p+=2;const j=s.length/3;B=t.Cartesian3.unpack(s,0,B);let q,v=0;for(p=3,C=1;C<j;C++)H=t.Cartesian3.clone(B,H),B=t.Cartesian3.unpack(s,p,B),v+=t.Cartesian3.distance(H,B),p+=3;p=3;let F=0,W=0,U=0,Y=0,$=!1,Z=t.Cartesian3.unpack(r,0,Be),J=t.Cartesian3.unpack(s,0,He),Q=t.Cartesian3.unpack(o,0,Ve);if(n){ke(Q,t.Cartesian3.unpack(r,r.length-6,Ge),Z,J)&&(Q=t.Cartesian3.negate(Q,Q))}let X=0,K=0,ee=0;for(C=0;C<f;C++){const e=t.Cartesian3.clone(Z,Ge),n=t.Cartesian3.clone(J,ze);let u,C,g,m,f=t.Cartesian3.clone(Q,je);if($&&(f=t.Cartesian3.negate(f,f)),Z=t.Cartesian3.unpack(r,p,Be),J=t.Cartesian3.unpack(s,p,He),Q=t.Cartesian3.unpack(o,p,Ve),$=ke(Q,e,Z,J),D.latitude=c[F],D.longitude=c[F+1],z.latitude=c[F+2],z.longitude=c[F+3],l){const e=Ne(D,z);u=i.project(D,$e),C=i.project(z,Ze);const a=ne(C,u,sa);a.y=Math.abs(a.y),g=Je,m=Qe,0===e||t.Cartesian3.dot(a,t.Cartesian3.UNIT_Y)>V?(g=Oe(i,D,f,u,Je),m=Oe(i,z,Q,C,Qe)):1===e?(m=Oe(i,z,Q,C,Qe),g.x=0,g.y=w.CesiumMath.sign(D.longitude-Math.abs(z.longitude)),g.z=0):(g=Oe(i,D,f,u,Je),m.x=0,m.y=w.CesiumMath.sign(D.longitude-z.longitude),m.z=0)}const y=t.Cartesian3.distance(n,J),E=d.EncodedCartesian3.fromCartesian(e,ia),M=t.Cartesian3.subtract(Z,e,Xe),T=t.Cartesian3.normalize(M,aa);let N=t.Cartesian3.subtract(n,e,Ke);N=t.Cartesian3.normalize(N,N);let H=t.Cartesian3.cross(T,N,aa);H=t.Cartesian3.normalize(H,H);let B=t.Cartesian3.cross(N,f,ta);B=t.Cartesian3.normalize(B,B);let j=t.Cartesian3.subtract(J,Z,ea);j=t.Cartesian3.normalize(j,j);let ae=t.Cartesian3.cross(Q,j,na);ae=t.Cartesian3.normalize(ae,ae);const te=y/v,ie=X/v;let re,se,oe,ce=0,le=0,ue=0;if(l){ce=t.Cartesian3.distance(u,C),re=d.EncodedCartesian3.fromCartesian(u,ra),se=t.Cartesian3.subtract(C,u,sa),oe=t.Cartesian3.normalize(se,oa);const e=oe.x;oe.x=oe.y,oe.y=-e,le=ce/R,ue=K/R}for(q=0;q<8;q++){const e=Y+4*q,a=W+2*q,n=e+3,i=q<4?1:-1,r=2===q||3===q||6===q||7===q?1:-1;t.Cartesian3.pack(E.high,P,e),P[n]=M.x,t.Cartesian3.pack(E.low,S,e),S[n]=M.y,t.Cartesian3.pack(B,_,e),_[n]=M.z,t.Cartesian3.pack(ae,O,e),O[n]=te*i,t.Cartesian3.pack(H,A,e);let s=ie*r;0===s&&r<0&&(s=9),A[n]=s,l&&(x[e]=re.high.x,x[e+1]=re.high.y,x[e+2]=re.low.x,x[e+3]=re.low.y,b[e]=-g.y,b[e+1]=g.x,b[e+2]=m.y,b[e+3]=-m.x,I[e]=se.x,I[e+1]=se.y,I[e+2]=oe.x,I[e+3]=oe.y,L[a]=le*i,s=ue*r,0===s&&r<0&&(s=9),L[a+1]=s)}const Ce=Ue,pe=Ye,de=Fe,he=We,ge=a.Rectangle.fromCartographicArray(qe,ve),me=G.getMinimumMaximumHeights(ge,h),fe=me.minimumTerrainHeight,we=me.maximumTerrainHeight;ee+=fe,ee+=we,Ie(e,n,fe,we,Ce,de),Ie(Z,J,fe,we,pe,he);let ye=t.Cartesian3.multiplyByScalar(H,w.CesiumMath.EPSILON5,ca);t.Cartesian3.add(Ce,ye,Ce),t.Cartesian3.add(pe,ye,pe),t.Cartesian3.add(de,ye,de),t.Cartesian3.add(he,ye,he),Le(Ce,pe),Le(de,he),t.Cartesian3.pack(Ce,k,U),t.Cartesian3.pack(pe,k,U+3),t.Cartesian3.pack(he,k,U+6),t.Cartesian3.pack(de,k,U+9),ye=t.Cartesian3.multiplyByScalar(H,-2*w.CesiumMath.EPSILON5,ca),t.Cartesian3.add(Ce,ye,Ce),t.Cartesian3.add(pe,ye,pe),t.Cartesian3.add(de,ye,de),t.Cartesian3.add(he,ye,he),Le(Ce,pe),Le(de,he),t.Cartesian3.pack(Ce,k,U+12),t.Cartesian3.pack(pe,k,U+15),t.Cartesian3.pack(he,k,U+18),t.Cartesian3.pack(de,k,U+21),F+=2,p+=3,W+=16,U+=24,Y+=32,X+=y,K+=ce}p=0;let ae=0;for(C=0;C<f;C++){for(q=0;q<Ca;q++)T[p+q]=ua[q]+ae;ae+=8,p+=Ca}const te=la;e.BoundingSphere.fromVertices(r,t.Cartesian3.ZERO,3,te[0]),e.BoundingSphere.fromVertices(s,t.Cartesian3.ZERO,3,te[1]);const ie=e.BoundingSphere.fromBoundingSpheres(te);ie.radius+=ee/(2*f);const re={position:new m.GeometryAttribute({componentDatatype:u.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:k}),startHiAndForwardOffsetX:pa(P),startLoAndForwardOffsetY:pa(S),startNormalAndForwardOffsetZ:pa(_),endNormalAndTextureCoordinateNormalizationX:pa(O),rightNormalAndTextureCoordinateNormalizationY:pa(A)};l&&(re.startHiLo2D=pa(x),re.offsetAndRight2D=pa(I),re.startEndNormals2D=pa(b),re.texcoordNormalization2D=new m.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:L}));return new g.Geometry({attributes:re,indices:T,boundingSphere:ie})}(o,E,W,U,q,j,s)};const Ee=new t.Cartesian3,Me=new y.Matrix3,Te=new e.Quaternion;function ke(a,n,i,r){const s=ne(i,n,Ee),o=t.Cartesian3.dot(s,a);if(o>V||o<q){const t=ne(r,i,ce),n=o<q?w.CesiumMath.PI_OVER_TWO:-w.CesiumMath.PI_OVER_TWO,s=e.Quaternion.fromAxisAngle(t,n,Te),c=y.Matrix3.fromQuaternion(s,Me);return y.Matrix3.multiplyByVector(c,a,a),!0}return!1}const Pe=new n.Cartographic,Se=new t.Cartesian3,_e=new t.Cartesian3;function Oe(e,a,i,r,s){const o=n.Cartographic.toCartesian(a,e._ellipsoid,Se);let c=t.Cartesian3.add(o,i,_e),l=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(c,Pe);Math.abs(a.longitude-C.longitude)>w.CesiumMath.PI_OVER_TWO&&(l=!0,c=t.Cartesian3.subtract(o,i,_e),C=u.cartesianToCartographic(c,Pe)),C.height=0;const p=e.project(C,s);return(s=t.Cartesian3.subtract(p,r,s)).z=0,s=t.Cartesian3.normalize(s,s),l&&t.Cartesian3.negate(s,s),s}const Ae=new t.Cartesian3,xe=new t.Cartesian3;function Ie(e,a,n,i,r,s){const o=t.Cartesian3.subtract(a,e,Ae);t.Cartesian3.normalize(o,o);const c=n-v;let l=t.Cartesian3.multiplyByScalar(o,c,xe);t.Cartesian3.add(e,l,r);const u=i-F;l=t.Cartesian3.multiplyByScalar(o,u,xe),t.Cartesian3.add(a,l,s)}const be=new t.Cartesian3;function Le(e,a){const n=E.Plane.getPointDistance(ue,e),i=E.Plane.getPointDistance(ue,a);let r=be;w.CesiumMath.equalsEpsilon(n,0,w.CesiumMath.EPSILON2)?(r=ne(a,e,r),t.Cartesian3.multiplyByScalar(r,w.CesiumMath.EPSILON2,r),t.Cartesian3.add(e,r,e)):w.CesiumMath.equalsEpsilon(i,0,w.CesiumMath.EPSILON2)&&(r=ne(e,a,r),t.Cartesian3.multiplyByScalar(r,w.CesiumMath.EPSILON2,r),t.Cartesian3.add(a,r,a))}function Ne(e,a){const t=Math.abs(e.longitude),n=Math.abs(a.longitude);if(w.CesiumMath.equalsEpsilon(t,w.CesiumMath.PI,w.CesiumMath.EPSILON11)){const n=w.CesiumMath.sign(a.longitude);return e.longitude=n*(t-w.CesiumMath.EPSILON11),1}if(w.CesiumMath.equalsEpsilon(n,w.CesiumMath.PI,w.CesiumMath.EPSILON11)){const t=w.CesiumMath.sign(e.longitude);return a.longitude=t*(n-w.CesiumMath.EPSILON11),2}return 0}const Re=new n.Cartographic,De=new n.Cartographic,ze=new t.Cartesian3,He=new t.Cartesian3,Ge=new t.Cartesian3,Be=new t.Cartesian3,je=new t.Cartesian3,Ve=new t.Cartesian3,qe=[Re,De],ve=new a.Rectangle,Fe=new t.Cartesian3,We=new t.Cartesian3,Ue=new t.Cartesian3,Ye=new t.Cartesian3,$e=new t.Cartesian3,Ze=new t.Cartesian3,Je=new t.Cartesian3,Qe=new t.Cartesian3,Xe=new t.Cartesian3,Ke=new t.Cartesian3,ea=new t.Cartesian3,aa=new t.Cartesian3,ta=new t.Cartesian3,na=new t.Cartesian3,ia=new d.EncodedCartesian3,ra=new d.EncodedCartesian3,sa=new t.Cartesian3,oa=new t.Cartesian3,ca=new t.Cartesian3,la=[new e.BoundingSphere,new e.BoundingSphere],ua=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],Ca=ua.length;function pa(e){return new m.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return W._projectNormal=Oe,function(e,a){return G.initialize().then((function(){return r.defined(a)&&(e=W.unpack(e,a)),W.createGeometry(e)}))}}));
