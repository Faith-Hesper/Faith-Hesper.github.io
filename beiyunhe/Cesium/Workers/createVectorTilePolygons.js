define(["./AttributeCompression-44abee07","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./Color-cad7c885","./defined-64766648","./IndexDatatype-ed8b21cb","./Math-56779564","./OrientedBoundingBox-fa9d7c73","./Cartesian2-0a34ed75","./createTaskProcessorWorker-03824364","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./WebGLConstants-7f557f93","./Matrix2-e52b9454","./Matrix3-59918a96","./RuntimeError-cfbf2bc8","./Transforms-b1e48e05","./GeographicProjection-868b0b16","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./EllipsoidTangentPlane-8f36a7e0","./AxisAlignedBoundingBox-8b4e9f9c","./IntersectionTests-39c3b1c1","./Plane-f9bf6226"],(function(e,t,n,r,a,o,i,s,c,f,d,l,u,h,g,p,C,b,m,y,I,x,w,A,E){"use strict";const T=new t.Cartesian3,k=new n.Ellipsoid,N=new c.Rectangle,B={min:void 0,max:void 0,indexBytesPerElement:void 0};function L(e,t,n){const a=t.length,o=2+a*s.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let n=0;for(let a=0;a<t;++a)n+=r.Color.packedLength+3+e[a].batchIds.length;return n}(n),i=new Float64Array(o);let c=0;i[c++]=e,i[c++]=a;for(let e=0;e<a;++e)s.OrientedBoundingBox.pack(t[e],i,c),c+=s.OrientedBoundingBox.packedLength;const f=n.length;i[c++]=f;for(let e=0;e<f;++e){const t=n[e];r.Color.pack(t.color,i,c),c+=r.Color.packedLength,i[c++]=t.offset,i[c++]=t.count;const a=t.batchIds,o=a.length;i[c++]=o;for(let e=0;e<o;++e)i[c++]=a[e]}return i}const O=new t.Cartesian3,P=new t.Cartesian3,U=new t.Cartesian3,F=new t.Cartesian3,M=new t.Cartesian3,R=new n.Cartographic,S=new c.Rectangle;return f.createTaskProcessorWorker((function(f,d){let l;!function(e){const r=new Float64Array(e);let a=0;B.indexBytesPerElement=r[a++],B.min=r[a++],B.max=r[a++],t.Cartesian3.unpack(r,a,T),a+=t.Cartesian3.packedLength,n.Ellipsoid.unpack(r,a,k),a+=n.Ellipsoid.packedLength,c.Rectangle.unpack(r,a,N)}(f.packedBuffer),l=2===B.indexBytesPerElement?new Uint16Array(f.indices):new Uint32Array(f.indices);const u=new Uint16Array(f.positions),h=new Uint32Array(f.counts),g=new Uint32Array(f.indexCounts),p=new Uint32Array(f.batchIds),C=new Uint32Array(f.batchTableColors),b=new Array(h.length),m=T,y=k;let I=N;const x=B.min,w=B.max;let A,E,D,G=f.minimumHeights,_=f.maximumHeights;a.defined(G)&&a.defined(_)&&(G=new Float32Array(G),_=new Float32Array(_));const V=u.length/2,Y=u.subarray(0,V),H=u.subarray(V,2*V);e.AttributeCompression.zigZagDeltaDecode(Y,H);const W=new Float64Array(3*V);for(A=0;A<V;++A){const e=Y[A],r=H[A],a=i.CesiumMath.lerp(I.west,I.east,e/32767),o=i.CesiumMath.lerp(I.south,I.north,r/32767),s=n.Cartographic.fromRadians(a,o,0,R),c=y.cartographicToCartesian(s,O);t.Cartesian3.pack(c,W,3*A)}const v=h.length,j=new Array(v),q=new Array(v);let z=0,Z=0;for(A=0;A<v;++A)j[A]=z,q[A]=Z,z+=h[A],Z+=g[A];const J=new Float32Array(3*V*2),K=new Uint16Array(2*V),Q=new Uint32Array(q.length),X=new Uint32Array(g.length);let $=[];const ee={};for(A=0;A<v;++A)D=C[A],a.defined(ee[D])?(ee[D].positionLength+=h[A],ee[D].indexLength+=g[A],ee[D].batchIds.push(A)):ee[D]={positionLength:h[A],indexLength:g[A],offset:0,indexOffset:0,batchIds:[A]};let te,ne=0,re=0;for(D in ee)if(ee.hasOwnProperty(D)){te=ee[D],te.offset=ne,te.indexOffset=re;const e=2*te.positionLength,t=2*te.indexLength+6*te.positionLength;ne+=e,re+=t,te.indexLength=t}const ae=[];for(D in ee)ee.hasOwnProperty(D)&&(te=ee[D],ae.push({color:r.Color.fromRgba(parseInt(D)),offset:te.indexOffset,count:te.indexLength,batchIds:te.batchIds}));for(A=0;A<v;++A){D=C[A],te=ee[D];const e=te.offset;let n=3*e,r=e;const o=j[A],i=h[A],c=p[A];let f=x,d=w;a.defined(G)&&a.defined(_)&&(f=G[A],d=_[A]);let u=Number.POSITIVE_INFINITY,T=Number.NEGATIVE_INFINITY,k=Number.POSITIVE_INFINITY,N=Number.NEGATIVE_INFINITY;for(E=0;E<i;++E){const e=t.Cartesian3.unpack(W,3*o+3*E,O);y.scaleToGeodeticSurface(e,e);const a=y.cartesianToCartographic(e,R),i=a.latitude,s=a.longitude;u=Math.min(i,u),T=Math.max(i,T),k=Math.min(s,k),N=Math.max(s,N);const l=y.geodeticSurfaceNormal(e,P);let h=t.Cartesian3.multiplyByScalar(l,f,U);const g=t.Cartesian3.add(e,h,F);h=t.Cartesian3.multiplyByScalar(l,d,h);const p=t.Cartesian3.add(e,h,M);t.Cartesian3.subtract(p,m,p),t.Cartesian3.subtract(g,m,g),t.Cartesian3.pack(p,J,n),t.Cartesian3.pack(g,J,n+3),K[r]=c,K[r+1]=c,n+=6,r+=2}I=S,I.west=k,I.east=N,I.south=u,I.north=T,b[A]=s.OrientedBoundingBox.fromRectangle(I,x,w,y);let B=te.indexOffset;const L=q[A],V=g[A];for(Q[A]=B,E=0;E<V;E+=3){const t=l[L+E]-o,n=l[L+E+1]-o,r=l[L+E+2]-o;$[B++]=2*t+e,$[B++]=2*n+e,$[B++]=2*r+e,$[B++]=2*r+1+e,$[B++]=2*n+1+e,$[B++]=2*t+1+e}for(E=0;E<i;++E){const t=E,n=(E+1)%i;$[B++]=2*t+1+e,$[B++]=2*n+e,$[B++]=2*t+e,$[B++]=2*t+1+e,$[B++]=2*n+1+e,$[B++]=2*n+e}te.offset+=2*i,te.indexOffset=B,X[A]=B-Q[A]}$=o.IndexDatatype.createTypedArray(J.length/3,$);const oe=ae.length;for(let e=0;e<oe;++e){const t=ae[e].batchIds;let n=0;const r=t.length;for(let e=0;e<r;++e)n+=X[t[e]];ae[e].count=n}const ie=L(2===$.BYTES_PER_ELEMENT?o.IndexDatatype.UNSIGNED_SHORT:o.IndexDatatype.UNSIGNED_INT,b,ae);return d.push(J.buffer,$.buffer,Q.buffer,X.buffer,K.buffer,ie.buffer),{positions:J.buffer,indices:$.buffer,indexOffsets:Q.buffer,indexCounts:X.buffer,batchIds:K.buffer,packedBuffer:ie.buffer}}))}));
