define(["exports","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./defaultValue-9f6a6288","./defined-64766648","./EllipsoidTangentPlane-8f36a7e0","./Math-56779564","./Matrix3-59918a96","./Matrix2-e52b9454","./Plane-f9bf6226"],(function(a,t,e,n,r,i,s,o,C,c,u,l){"use strict";function d(a,t){this.center=n.Cartesian3.clone(i.defaultValue(a,n.Cartesian3.ZERO)),this.halfAxes=c.Matrix3.clone(i.defaultValue(t,c.Matrix3.ZERO))}d.packedLength=n.Cartesian3.packedLength+c.Matrix3.packedLength,d.pack=function(a,t,e){return e=i.defaultValue(e,0),n.Cartesian3.pack(a.center,t,e),c.Matrix3.pack(a.halfAxes,t,e+n.Cartesian3.packedLength),t},d.unpack=function(a,t,e){return t=i.defaultValue(t,0),s.defined(e)||(e=new d),n.Cartesian3.unpack(a,t,e.center),c.Matrix3.unpack(a,t+n.Cartesian3.packedLength,e.halfAxes),e};const h=new n.Cartesian3,x=new n.Cartesian3,m=new n.Cartesian3,M=new n.Cartesian3,f=new n.Cartesian3,p=new n.Cartesian3,w=new c.Matrix3,g={unitary:new c.Matrix3,diagonal:new c.Matrix3};d.fromPoints=function(a,t){if(s.defined(t)||(t=new d),!s.defined(a)||0===a.length)return t.halfAxes=c.Matrix3.ZERO,t.center=n.Cartesian3.ZERO,t;let e;const r=a.length,i=n.Cartesian3.clone(a[0],h);for(e=1;e<r;e++)n.Cartesian3.add(i,a[e],i);const o=1/r;n.Cartesian3.multiplyByScalar(i,o,i);let C,u=0,l=0,y=0,b=0,N=0,T=0;for(e=0;e<r;e++)C=n.Cartesian3.subtract(a[e],i,x),u+=C.x*C.x,l+=C.x*C.y,y+=C.x*C.z,b+=C.y*C.y,N+=C.y*C.z,T+=C.z*C.z;u*=o,l*=o,y*=o,b*=o,N*=o,T*=o;const O=w;O[0]=u,O[1]=l,O[2]=y,O[3]=l,O[4]=b,O[5]=N,O[6]=y,O[7]=N,O[8]=T;const A=c.Matrix3.computeEigenDecomposition(O,g),P=c.Matrix3.clone(A.unitary,t.halfAxes);let I=c.Matrix3.getColumn(P,0,M),R=c.Matrix3.getColumn(P,1,f),E=c.Matrix3.getColumn(P,2,p),S=-Number.MAX_VALUE,U=-Number.MAX_VALUE,L=-Number.MAX_VALUE,z=Number.MAX_VALUE,B=Number.MAX_VALUE,V=Number.MAX_VALUE;for(e=0;e<r;e++)C=a[e],S=Math.max(n.Cartesian3.dot(I,C),S),U=Math.max(n.Cartesian3.dot(R,C),U),L=Math.max(n.Cartesian3.dot(E,C),L),z=Math.min(n.Cartesian3.dot(I,C),z),B=Math.min(n.Cartesian3.dot(R,C),B),V=Math.min(n.Cartesian3.dot(E,C),V);I=n.Cartesian3.multiplyByScalar(I,.5*(z+S),I),R=n.Cartesian3.multiplyByScalar(R,.5*(B+U),R),E=n.Cartesian3.multiplyByScalar(E,.5*(V+L),E);const _=n.Cartesian3.add(I,R,t.center);n.Cartesian3.add(_,E,_);const k=m;return k.x=S-z,k.y=U-B,k.z=L-V,n.Cartesian3.multiplyByScalar(k,.5,k),c.Matrix3.multiplyByScale(t.halfAxes,k,t.halfAxes),t};const y=new n.Cartesian3,b=new n.Cartesian3;function N(a,t,e,r,i,o,C,u,l,h,x){s.defined(x)||(x=new d);const m=x.halfAxes;c.Matrix3.setColumn(m,0,t,m),c.Matrix3.setColumn(m,1,e,m),c.Matrix3.setColumn(m,2,r,m);let M=y;M.x=(i+o)/2,M.y=(C+u)/2,M.z=(l+h)/2;const f=b;f.x=(o-i)/2,f.y=(u-C)/2,f.z=(h-l)/2;const p=x.center;return M=c.Matrix3.multiplyByVector(m,M,M),n.Cartesian3.add(a,M,p),c.Matrix3.multiplyByScale(m,f,m),x}const T=new r.Cartographic,O=new n.Cartesian3,A=new r.Cartographic,P=new r.Cartographic,I=new r.Cartographic,R=new r.Cartographic,E=new r.Cartographic,S=new n.Cartesian3,U=new n.Cartesian3,L=new n.Cartesian3,z=new n.Cartesian3,B=new n.Cartesian3,V=new e.Cartesian2,_=new e.Cartesian2,k=new e.Cartesian2,W=new e.Cartesian2,X=new e.Cartesian2,q=new n.Cartesian3,D=new n.Cartesian3,j=new n.Cartesian3,Z=new n.Cartesian3,v=new e.Cartesian2,G=new n.Cartesian3,Y=new n.Cartesian3,F=new n.Cartesian3,H=new l.Plane(n.Cartesian3.UNIT_X,0);d.fromRectangle=function(a,t,s,c,u){let d,h,x,m,M,f,p;if(t=i.defaultValue(t,0),s=i.defaultValue(s,0),c=i.defaultValue(c,r.Ellipsoid.WGS84),a.width<=C.CesiumMath.PI){const n=e.Rectangle.center(a,T),i=c.cartographicToCartesian(n,O),C=new o.EllipsoidTangentPlane(i,c);p=C.plane;const w=n.longitude,g=a.south<0&&a.north>0?0:n.latitude,y=r.Cartographic.fromRadians(w,a.north,s,A),b=r.Cartographic.fromRadians(a.west,a.north,s,P),q=r.Cartographic.fromRadians(a.west,g,s,I),D=r.Cartographic.fromRadians(a.west,a.south,s,R),j=r.Cartographic.fromRadians(w,a.south,s,E),Z=c.cartographicToCartesian(y,S);let v=c.cartographicToCartesian(b,U);const G=c.cartographicToCartesian(q,L);let Y=c.cartographicToCartesian(D,z);const F=c.cartographicToCartesian(j,B),H=C.projectPointToNearestOnPlane(Z,V),J=C.projectPointToNearestOnPlane(v,_),K=C.projectPointToNearestOnPlane(G,k),Q=C.projectPointToNearestOnPlane(Y,W),$=C.projectPointToNearestOnPlane(F,X);return d=Math.min(J.x,K.x,Q.x),h=-d,m=Math.max(J.y,H.y),x=Math.min(Q.y,$.y),b.height=D.height=t,v=c.cartographicToCartesian(b,U),Y=c.cartographicToCartesian(D,z),M=Math.min(l.Plane.getPointDistance(p,v),l.Plane.getPointDistance(p,Y)),f=s,N(C.origin,C.xAxis,C.yAxis,C.zAxis,d,h,x,m,M,f,u)}const w=a.south>0,g=a.north<0,y=w?a.south:g?a.north:0,b=e.Rectangle.center(a,T).longitude,J=n.Cartesian3.fromRadians(b,y,s,c,q);J.z=0;const K=Math.abs(J.x)<C.CesiumMath.EPSILON10&&Math.abs(J.y)<C.CesiumMath.EPSILON10?n.Cartesian3.UNIT_X:n.Cartesian3.normalize(J,D),Q=n.Cartesian3.UNIT_Z,$=n.Cartesian3.cross(K,Q,j);p=l.Plane.fromPointNormal(J,K,H);const aa=n.Cartesian3.fromRadians(b+C.CesiumMath.PI_OVER_TWO,y,s,c,Z);h=n.Cartesian3.dot(l.Plane.projectPointOntoPlane(p,aa,v),$),d=-h,m=n.Cartesian3.fromRadians(0,a.north,g?t:s,c,G).z,x=n.Cartesian3.fromRadians(0,a.south,w?t:s,c,Y).z;const ta=n.Cartesian3.fromRadians(a.east,y,s,c,F);return M=l.Plane.getPointDistance(p,ta),f=0,N(J,$,Q,K,d,h,x,m,M,f,u)},d.fromTransformation=function(a,t){return s.defined(t)||(t=new d),t.center=u.Matrix4.getTranslation(a,t.center),t.halfAxes=u.Matrix4.getMatrix3(a,t.halfAxes),t.halfAxes=c.Matrix3.multiplyByScalar(t.halfAxes,.5,t.halfAxes),t},d.clone=function(a,t){if(s.defined(a))return s.defined(t)?(n.Cartesian3.clone(a.center,t.center),c.Matrix3.clone(a.halfAxes,t.halfAxes),t):new d(a.center,a.halfAxes)},d.intersectPlane=function(a,e){const r=a.center,i=e.normal,s=a.halfAxes,o=i.x,C=i.y,u=i.z,l=Math.abs(o*s[c.Matrix3.COLUMN0ROW0]+C*s[c.Matrix3.COLUMN0ROW1]+u*s[c.Matrix3.COLUMN0ROW2])+Math.abs(o*s[c.Matrix3.COLUMN1ROW0]+C*s[c.Matrix3.COLUMN1ROW1]+u*s[c.Matrix3.COLUMN1ROW2])+Math.abs(o*s[c.Matrix3.COLUMN2ROW0]+C*s[c.Matrix3.COLUMN2ROW1]+u*s[c.Matrix3.COLUMN2ROW2]),d=n.Cartesian3.dot(i,r)+e.distance;return d<=-l?t.Intersect.OUTSIDE:d>=l?t.Intersect.INSIDE:t.Intersect.INTERSECTING};const J=new n.Cartesian3,K=new n.Cartesian3,Q=new n.Cartesian3,$=new n.Cartesian3,aa=new n.Cartesian3,ta=new n.Cartesian3;d.distanceSquaredTo=function(a,t){const e=n.Cartesian3.subtract(t,a.center,y),r=a.halfAxes;let i=c.Matrix3.getColumn(r,0,J),s=c.Matrix3.getColumn(r,1,K),o=c.Matrix3.getColumn(r,2,Q);const u=n.Cartesian3.magnitude(i),l=n.Cartesian3.magnitude(s),d=n.Cartesian3.magnitude(o);let h=!0,x=!0,m=!0;u>0?n.Cartesian3.divideByScalar(i,u,i):h=!1,l>0?n.Cartesian3.divideByScalar(s,l,s):x=!1,d>0?n.Cartesian3.divideByScalar(o,d,o):m=!1;const M=!h+!x+!m;let f,p,w;if(1===M){let a=i;f=s,p=o,x?m||(a=o,p=i):(a=s,f=i),w=n.Cartesian3.cross(f,p,aa),a===i?i=w:a===s?s=w:a===o&&(o=w)}else if(2===M){f=i,x?f=s:m&&(f=o);let a=n.Cartesian3.UNIT_Y;a.equalsEpsilon(f,C.CesiumMath.EPSILON3)&&(a=n.Cartesian3.UNIT_X),p=n.Cartesian3.cross(f,a,$),n.Cartesian3.normalize(p,p),w=n.Cartesian3.cross(f,p,aa),n.Cartesian3.normalize(w,w),f===i?(s=p,o=w):f===s?(o=p,i=w):f===o&&(i=p,s=w)}else 3===M&&(i=n.Cartesian3.UNIT_X,s=n.Cartesian3.UNIT_Y,o=n.Cartesian3.UNIT_Z);const g=ta;g.x=n.Cartesian3.dot(e,i),g.y=n.Cartesian3.dot(e,s),g.z=n.Cartesian3.dot(e,o);let b,N=0;return g.x<-u?(b=g.x+u,N+=b*b):g.x>u&&(b=g.x-u,N+=b*b),g.y<-l?(b=g.y+l,N+=b*b):g.y>l&&(b=g.y-l,N+=b*b),g.z<-d?(b=g.z+d,N+=b*b):g.z>d&&(b=g.z-d,N+=b*b),N};const ea=new n.Cartesian3,na=new n.Cartesian3;d.computePlaneDistances=function(a,e,r,i){s.defined(i)||(i=new t.Interval);let o=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY;const u=a.center,l=a.halfAxes,d=c.Matrix3.getColumn(l,0,J),h=c.Matrix3.getColumn(l,1,K),x=c.Matrix3.getColumn(l,2,Q),m=n.Cartesian3.add(d,h,ea);n.Cartesian3.add(m,x,m),n.Cartesian3.add(m,u,m);const M=n.Cartesian3.subtract(m,e,na);let f=n.Cartesian3.dot(r,M);return o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.add(u,d,m),n.Cartesian3.add(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.add(u,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.add(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.add(u,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.subtract(u,d,m),n.Cartesian3.add(m,h,m),n.Cartesian3.add(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.subtract(u,d,m),n.Cartesian3.add(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.subtract(u,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.add(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),n.Cartesian3.subtract(u,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,e,M),f=n.Cartesian3.dot(r,M),o=Math.min(f,o),C=Math.max(f,C),i.start=o,i.stop=C,i};const ra=new n.Cartesian3,ia=new n.Cartesian3,sa=new n.Cartesian3;d.computeCorners=function(a,t){s.defined(t)||(t=[new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3]);const e=a.center,r=a.halfAxes,i=c.Matrix3.getColumn(r,0,ra),o=c.Matrix3.getColumn(r,1,ia),C=c.Matrix3.getColumn(r,2,sa);return n.Cartesian3.clone(e,t[0]),n.Cartesian3.subtract(t[0],i,t[0]),n.Cartesian3.subtract(t[0],o,t[0]),n.Cartesian3.subtract(t[0],C,t[0]),n.Cartesian3.clone(e,t[1]),n.Cartesian3.subtract(t[1],i,t[1]),n.Cartesian3.subtract(t[1],o,t[1]),n.Cartesian3.add(t[1],C,t[1]),n.Cartesian3.clone(e,t[2]),n.Cartesian3.subtract(t[2],i,t[2]),n.Cartesian3.add(t[2],o,t[2]),n.Cartesian3.subtract(t[2],C,t[2]),n.Cartesian3.clone(e,t[3]),n.Cartesian3.subtract(t[3],i,t[3]),n.Cartesian3.add(t[3],o,t[3]),n.Cartesian3.add(t[3],C,t[3]),n.Cartesian3.clone(e,t[4]),n.Cartesian3.add(t[4],i,t[4]),n.Cartesian3.subtract(t[4],o,t[4]),n.Cartesian3.subtract(t[4],C,t[4]),n.Cartesian3.clone(e,t[5]),n.Cartesian3.add(t[5],i,t[5]),n.Cartesian3.subtract(t[5],o,t[5]),n.Cartesian3.add(t[5],C,t[5]),n.Cartesian3.clone(e,t[6]),n.Cartesian3.add(t[6],i,t[6]),n.Cartesian3.add(t[6],o,t[6]),n.Cartesian3.subtract(t[6],C,t[6]),n.Cartesian3.clone(e,t[7]),n.Cartesian3.add(t[7],i,t[7]),n.Cartesian3.add(t[7],o,t[7]),n.Cartesian3.add(t[7],C,t[7]),t};const oa=new c.Matrix3;d.computeTransformation=function(a,t){s.defined(t)||(t=new u.Matrix4);const e=a.center,n=c.Matrix3.multiplyByUniformScale(a.halfAxes,2,oa);return u.Matrix4.fromRotationTranslation(n,e,t)};const Ca=new t.BoundingSphere;d.isOccluded=function(a,e){const n=t.BoundingSphere.fromOrientedBoundingBox(a,Ca);return!e.isBoundingSphereVisible(n)},d.prototype.intersectPlane=function(a){return d.intersectPlane(this,a)},d.prototype.distanceSquaredTo=function(a){return d.distanceSquaredTo(this,a)},d.prototype.computePlaneDistances=function(a,t,e){return d.computePlaneDistances(this,a,t,e)},d.prototype.computeCorners=function(a){return d.computeCorners(this,a)},d.prototype.computeTransformation=function(a){return d.computeTransformation(this,a)},d.prototype.isOccluded=function(a){return d.isOccluded(this,a)},d.equals=function(a,t){return a===t||s.defined(a)&&s.defined(t)&&n.Cartesian3.equals(a.center,t.center)&&c.Matrix3.equals(a.halfAxes,t.halfAxes)},d.prototype.clone=function(a){return d.clone(this,a)},d.prototype.equals=function(a){return d.equals(this,a)},a.OrientedBoundingBox=d}));
