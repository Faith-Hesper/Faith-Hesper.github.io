define(["./CodeTool","./ZstdLoader","./Buffer","./zstd_wasm","./base64","./ieee754","./isArray"],(function(e,t,r,s,i,a,n){"use strict";class l{constructor(e,t,r,s,i){this.type=e,this.buffer=t,this.featureNum=r,this.start=s,this.end=i,this.isInit=!1,this.readIndex=-1,this.notNullIndex=0}get(e){if(this.isInit||this._init(),this.readIndex++,this.test(e))return null;let t=null;if(e==this.readIndex)t=this.view[this.notNullIndex++];else{let r=e-this.cardinality(e);this.notNullIndex=r+1,this.readIndex=e,t=this.view[r]}return t}reset(){this.readIndex=-1,this.notNullIndex=0}test(e){let t=e>>3;return t<this.nullSetBuffer.length&&0!=(this.nullSetBuffer[t]>>(7&e)&1)}cardinality(e){let t=e>>3,r=0;for(let e=0;e<t;e++)r+=this._bitCountByte(this.nullSetBuffer[e]);let s=7&e;for(let t=0;t<s;t++)r+=this.test(e-t);return r}_bitCountByte(e){return e=(e=(51&(e-=e>>>1&85))+(e>>>2&51))+(e>>>4)&15}_init(){let e=this.start,t=this.buffer.readInt32LE(e);e+=4,this.nullSetBuffer=this.buffer.slice(e,e+t),e+=t;let s=this.buffer,i=this.end-e;switch(this.type){case"integer":if(e%4==0)this.view=new Int32Array(s.buffer,e,i/4);else{let t=s.slice(e,this.end),a=r.from(t),n=a.offset;this.view=new Int32Array(a.buffer.slice(n),0,i/4)}break;case"timestamp":if(e%8==0)this.view=new BigInt64Array(s.buffer,e,i/8);else{let t=s.slice(e,this.end),a=r.from(t),n=a.offset;this.view=new BigInt64Array(a.buffer.slice(n),0,i/8)}break;case"short":if(e%2==0)this.view=new Int16Array(s.buffer,e,i/2);else{let t=s.slice(e,this.end),a=r.from(t),n=a.offset;this.view=new Int16Array(a.buffer.slice(n),0,i/2)}break;case"long":if(e%8==0)this.view=new BigInt64Array(s.buffer,e,i/8);else{let t=s.slice(e,this.end),a=r.from(t),n=a.offset;this.view=new BigInt64Array(a.buffer.slice(n),0,i/8)}break;case"float":if(e%4==0)this.view=new Float32Array(s.buffer,e,i/4);else{let t=s.slice(e,this.end),a=r.from(t),n=a.offset;this.view=new Float32Array(a.buffer.slice(n),0,i/4)}break;case"double":if(e%8==0)this.view=new Float64Array(s.buffer,e,i/8);else{let t=s.slice(e,this.end),a=r.from(t),n=a.offset;this.view=new Float64Array(a.buffer.slice(n),0,i/8)}break;default:throw"Unsupported data type: "+this.type}this.isInit=!0}static convert2Buffer(e,t){let s=e.length,i=Math.ceil(s/8),a=r.alloc(i);for(let t=0;t<s;t++){const r=t>>3,s=7&t;null!=e[t]?a[r]|=1<<s:a[r]&=~(1<<s)}let n=l._getTypeArrayByType(t,s),f=0;for(let t=0;t<s;t++){let r=e[t];null!=r&&(n[f++]=r)}let h=r.alloc(4);return h.writeInt32LE(i,0),r.concat([h,a,r.from(n.buffer)])}static _getTypeArrayByType(e,t){let r=null;switch(e){case"integer":r=new Int32Array(t);break;case"timestamp":case"long":r=new BigInt64Array(t);break;case"short":r=new Int16Array(t);break;case"float":r=new Float32Array(t);break;case"double":r=new Float64Array(t);break;default:throw"Unsupported data type: "+e}return r}}var f=l;const h="utf8",o="#@";var u=class{constructor(e,t,r){this.buffer=e,this.isInit=!1,this.start=t,this.end=r,this.dictionarys=null,this.view=null,this.values=null}static convert2Buffer(e){let t=new Set,s=e.length;for(let r=0;r<s;r++)t.add(e[r]);if(s/t.size<3){let t=e.join(o),s=r.from(t,h),i=r.alloc(4);return i.writeInt32LE(-1,0),r.concat([i,s])}{let i=Array.from(t),a=i.join(o),n=r.from(a,h),l=new Map,f=i.length;for(let e=0;e<f;e++)l[i[e]]=e;let u=1;f>65535?u=4:f>255&&(u=2);let c=r.alloc(5);c.writeInt32LE(n.length,0),c.writeInt8(u,4);let p=null;p=1==u?new Int8Array(s):2==u?new Int16Array(s):new Int32Array(s);for(let t=0;t<s;t++){let r=l[e[t]];p[t]=r}return r.concat([c,n,r.from(p.buffer)])}}_init(){let e=this.start,t=this.buffer.readInt32LE(e);e+=4;let s=null;if(-1!=t){s=this.buffer.readInt8(e),e++;let i=this.buffer.slice(e,e+t).toString(h);this.dictionarys=i.split(o),e+=t;let a=this.buffer.slice(e,this.end),n=a.length;1==s?this.view=new Int8Array(a.buffer,e,n/s):2==s?this.view=e%2==0?new Int16Array(a.buffer,e,n/s):new Int16Array(r.from(a).buffer,0,n/s):4==s&&(this.view=e%4==0?new Int32Array(a.buffer,e,n/s):new Int32Array(r.from(a).buffer,0,n/s))}else{let t=this.buffer.slice(e,this.end).toString(h);this.values=t.split(o)}this.buffer=null,this.isInit=!0}get(e){return this.isInit||this._init(),null==this.values?this.dictionarys[this.view[e]]:this.values[e]}};const c="utf8";var p=class{constructor(e,t,r){this.buffer=e,this.start=t,this.end=r,this.isInit=!1,this.values=null}static convert2Buffer(e){let t=e.join("#@");return r.from(t,c)}_init(){let e=this.start,t=this.buffer.slice(e,this.end).toString(c);this.values=t.split("#@"),this.buffer=null,this.isInit=!0}get(e){return this.isInit||this._init(),this.values[e]}};var y=class{static getColumnHolderByType(e,t,r,s,i){switch(e){case"integer":case"timestamp":case"short":case"long":case"float":case"double":return new f(e,t,r,s,i);case"string":return new u(t,s,i);case"bigdecimal":return new p(t,s,i);default:throw"Unsupported data type: "+e}}static convert2Buffer(e,t){switch(t){case"integer":case"timestamp":case"short":case"long":case"float":case"double":return f.convert2Buffer(e,t);case"string":return u.convert2Buffer(e);case"bigdecimal":return p.convert2Buffer(e);default:throw"Unsupported data type: "+t}}};const d="utf8";return class{constructor(e,t,r){this.headerLength=t,this.propertyConfigMap=r,this.intLength=4,this.vectorVarintBuffer=e,this.layerMap=new Object,this.vectorHeaderProMap=new Object,this.layerHeaderProMap=new Object,this.layerHeaderProBuffer=new Object,this.geometyTypeMap=new Object,this.featureNumMap=new Object,this.featureMap=new Object,this.columnHolderArrayMap=new Object,this.offsetBufferMap=new Object,this.offsetArrayMap=new Object,this.varintMap=new Object,this.zipType=null}getAllLayerNames(){let e=[];for(let t in this.layerMap)e.push(t);return e}getGeometryType(e){return this.geometyTypeMap[e]}async getLayerPro(e){let t=this.columnHolderArrayMap[e];if(null==t){if(!(this.featureMap[e].length>0))return this.columnHolderArrayMap[e]=[],[];t=await this._lazyInitColumns(e)}else for(let e=0;e<t.length;e++)t[e].reset&&t[e].reset();let r=this.featureNumMap[e],s=this.propertyConfigMap[e].fields.length,i=new Array(r);for(let e=0;e<r;e++){let r=new Array(s);for(let i=0;i<s;i++)r[i]=t[i].get(e);i[e]=r}return i}getOffsetByIndex(e,t){let r=this.offsetArrayMap[e],s=[];return s.push(r[2*t]),s.push(r[2*t+1]),s}getAllCoordinates(e,t){let r,s,i,a=this.offsetArrayMap[e],n=this.varintMap[e],l=[];for(let e=0;e<a.length/2;e++)r=a[2*e],s=a[2*e+1],i=n.slice(r,r+s),l.push(this._bufferToDoubleArray(i,t));return l}getCoordinatesByIndex(e,t,r){let s=this.getOffsetByIndex(e,t),i=this.varintMap[e],a=s[0],n=s[1],l=i.slice(a,a+n);return this._bufferToDoubleArray(l,r)}async _parseVector(e){let t=this.headerLength;e.readInt16BE(t),t+=2;let r=e.readInt16BE(t);t+=2;let s=e.readInt16BE(t);t+=2;let{headerMap:i}=await this._parseHeaderPro(e,t,r,"none");this.vectorHeaderProMap=i,this.zipType=this.vectorHeaderProMap.zipType,t+=r;let a=e.slice(t,t+s);t+=s;let n,l,f,h=e.slice(t,this.vectorVarintBuffer.length),o=0,u=0,c=0,p=0;for(let e=0;e<a.length;)c=e,o=a.readInt32BE(c),c+=this.intLength,p=c+o,n=a.toString(d,c,p),c=p,l=a.readInt32BE(c),c+=this.intLength,f=h.slice(u,u+l),u+=l,this.layerMap[n]=f,await this._parseLayer(n,f,this.zipType),e=c}async _parseLayer(e,t,r){if(0===t.length)return;let s=0,i=t.readInt32BE(s);this.featureNumMap[e]=i,s+=4;let a=t.readInt16BE(s);s+=2;let n=t.readInt32BE(s);s+=4;let l=t.readInt32BE(s);s+=4,t.readInt32BE(s),s+=4;let{headerMap:f,headerBuffer:h}=await this._parseHeaderPro(t,s,a,r);s+=a,this.layerHeaderProMap[e]=f,this.layerHeaderProBuffer[e]=h;let o=this.layerHeaderProMap[e].gType;this.geometyTypeMap[e]=o;let u=await this._parseIndex(t,s,n);s+=n,this.offsetBufferMap[e]=u.buffer,this.offsetArrayMap[e]=u.array;let c=t.slice(s,s+l);this.varintMap[e]=c,s+=l;let p=t.slice(s);this.featureMap[e]=p}async _parseHeaderPro(e,s,i,a){let n=await t.getDecompress(),l=new Object,f=e.slice(s,s+i);if(s+=i,0==i)return[s,l];"zstd"==a&&(f=r.from(n(f)));let h=f.toString(d).split(":");for(let e=0;e<h.length/2;e++)l[h[2*e]]=h[2*e+1];return{headerMap:l,headerBuffer:f}}async _parseIndex(e,s,i){let a=await t.getDecompress(),n=e.slice(s,s+i);n=r.from(a(n));let l=n.length/4;const f=new Int32Array(2*l);let h=0;for(let e=0;e<l;e++)f[2*e+1]=n.readInt32BE(h),h+=4;let o=0;for(let e=0;e<l;e++){let t=2*e;f[t]=o,o+=f[t+1]}return{buffer:n,array:f}}async _lazyInitColumns(e){let s=await t.getDecompress(),i=this.featureMap[e],a=this.propertyConfigMap[e].fields,n=a.length,l=s(i);i=r.from(l);let f=new Array(n),h=0;for(let t=0;t<n;t++){let r=i.readInt32BE(h);h+=4;let s=y.getColumnHolderByType(a[t].type,i,this.featureNumMap[e],h,h+r);h+=r,f[t]=s}return this.columnHolderArrayMap[e]=f,f}_bufferToDoubleArray(t,r){let s,i,a,n=[],l=[],f=0,h=[],o=0,u=0,c=!0;for(let p=0;p<=t.length;p++)s=0|t[p]>>7&1,0===s&&f>0&&(f>0&&f<=5?(c?(i=e.varintToInt(n)+o,l.push(i/r),c=!1,o=i):(a=e.varintToInt(n)+u,l.push(a/r),c=!0,u=a),f=0,n=[]):f>5&&(o=0,u=0,f=0,n=[],h.push(l),l=[])),p!==t.length?(n.push(t[p]),f++):l.length>0&&h.push(l);return h}isEmpty(e){return null==this.offsetArrayMap[e]||0===this.offsetArrayMap[e].length}}}));
