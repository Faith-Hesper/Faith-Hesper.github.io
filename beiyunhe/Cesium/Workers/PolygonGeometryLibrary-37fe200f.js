define(["exports","./ArcType-26a3f38d","./arrayRemoveDuplicates-d0608faf","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./EllipsoidRhumbLine-cea00df6","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryPipeline-92c34dd1","./IndexDatatype-ed8b21cb","./Math-56779564","./Matrix3-59918a96","./PolygonPipeline-d79010c3","./Transforms-b1e48e05"],(function(e,t,n,i,o,r,a,s,c,l,u,h,p,d,f,y,g,m,C){"use strict";function b(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(b.prototype,{length:{get:function(){return this._length}}}),b.prototype.enqueue=function(e){this._array.push(e),this._length++},b.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},b.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},b.prototype.contains=function(e){return-1!==this._array.indexOf(e)},b.prototype.clear=function(){this._array.length=this._offset=this._length=0},b.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};const T={computeHierarchyPackedLength:function(e,t){let n=0;const i=[e];for(;i.length>0;){const e=i.pop();if(!c.defined(e))continue;n+=2;const o=e.positions,r=e.holes;if(c.defined(o)&&o.length>0&&(n+=o.length*t.packedLength),c.defined(r)){const e=r.length;for(let t=0;t<e;++t)i.push(r[t])}}return n},packPolygonHierarchy:function(e,t,n,i){const o=[e];for(;o.length>0;){const e=o.pop();if(!c.defined(e))continue;const r=e.positions,a=e.holes;if(t[n++]=c.defined(r)?r.length:0,t[n++]=c.defined(a)?a.length:0,c.defined(r)){const e=r.length;for(let o=0;o<e;++o,n+=i.packedLength)i.pack(r[o],t,n)}if(c.defined(a)){const e=a.length;for(let t=0;t<e;++t)o.push(a[t])}}return n},unpackPolygonHierarchy:function(e,t,n){const i=e[t++],o=e[t++],r=new Array(i),a=o>0?new Array(o):void 0;for(let o=0;o<i;++o,t+=n.packedLength)r[o]=n.unpack(e,t);for(let i=0;i<o;++i)a[i]=T.unpackPolygonHierarchy(e,t,n),t=a[i].startingIndex,delete a[i].startingIndex;return{positions:r,holes:a,startingIndex:t}}},x=new i.Cartesian2;function v(e,t,n,o){return i.Cartesian2.subtract(t,e,x),i.Cartesian2.multiplyByScalar(x,n/o,x),i.Cartesian2.add(e,x,x),[x.x,x.y]}const w=new o.Cartesian3;function A(e,t,n,i){return o.Cartesian3.subtract(t,e,w),o.Cartesian3.multiplyByScalar(w,n/i,w),o.Cartesian3.add(e,w,w),[w.x,w.y,w.z]}T.subdivideLineCount=function(e,t,n){const i=o.Cartesian3.distance(e,t)/n,r=Math.max(0,Math.ceil(y.CesiumMath.log2(i)));return Math.pow(2,r)};const L=new r.Cartographic,E=new r.Cartographic,I=new r.Cartographic,P=new o.Cartesian3,M=new l.EllipsoidRhumbLine;T.subdivideRhumbLineCount=function(e,t,n,i){const o=e.cartesianToCartographic(t,L),r=e.cartesianToCartographic(n,E),a=new l.EllipsoidRhumbLine(o,r,e).surfaceDistance/i,s=Math.max(0,Math.ceil(y.CesiumMath.log2(a)));return Math.pow(2,s)},T.subdivideTexcoordLine=function(e,t,n,o,r,a){const s=T.subdivideLineCount(n,o,r),c=i.Cartesian2.distance(e,t),l=c/s,u=a;u.length=2*s;let h=0;for(let n=0;n<s;n++){const i=v(e,t,n*l,c);u[h++]=i[0],u[h++]=i[1]}return u},T.subdivideLine=function(e,t,n,i){const r=T.subdivideLineCount(e,t,n),a=o.Cartesian3.distance(e,t),s=a/r;c.defined(i)||(i=[]);const l=i;l.length=3*r;let u=0;for(let n=0;n<r;n++){const i=A(e,t,n*s,a);l[u++]=i[0],l[u++]=i[1],l[u++]=i[2]}return l},T.subdivideTexcoordRhumbLine=function(e,t,n,o,r,a,s){const c=n.cartesianToCartographic(o,L),l=n.cartesianToCartographic(r,E);M.setEndPoints(c,l);const u=M.surfaceDistance/a,h=Math.max(0,Math.ceil(y.CesiumMath.log2(u))),p=Math.pow(2,h),d=i.Cartesian2.distance(e,t),f=d/p,g=s;g.length=2*p;let m=0;for(let n=0;n<p;n++){const i=v(e,t,n*f,d);g[m++]=i[0],g[m++]=i[1]}return g},T.subdivideRhumbLine=function(e,t,n,i,o){const r=e.cartesianToCartographic(t,L),a=e.cartesianToCartographic(n,E),s=new l.EllipsoidRhumbLine(r,a,e),u=s.surfaceDistance/i,h=Math.max(0,Math.ceil(y.CesiumMath.log2(u))),p=Math.pow(2,h),d=s.surfaceDistance/p;c.defined(o)||(o=[]);const f=o;f.length=3*p;let g=0;for(let t=0;t<p;t++){const n=s.interpolateUsingSurfaceDistance(t*d,I),i=e.cartographicToCartesian(n,P);f[g++]=i.x,f[g++]=i.y,f[g++]=i.z}return f};const D=new o.Cartesian3,G=new o.Cartesian3,_=new o.Cartesian3,S=new o.Cartesian3;T.scaleToGeodeticHeightExtruded=function(e,t,n,i,a){i=s.defaultValue(i,r.Ellipsoid.WGS84);const l=D;let u=G;const h=_;let p=S;if(c.defined(e)&&c.defined(e.attributes)&&c.defined(e.attributes.position)){const r=e.attributes.position.values,s=r.length/2;for(let e=0;e<s;e+=3)o.Cartesian3.fromArray(r,e,h),i.geodeticSurfaceNormal(h,l),p=i.scaleToGeodeticSurface(h,p),u=o.Cartesian3.multiplyByScalar(l,n,u),u=o.Cartesian3.add(p,u,u),r[e+s]=u.x,r[e+1+s]=u.y,r[e+2+s]=u.z,a&&(p=o.Cartesian3.clone(h,p)),u=o.Cartesian3.multiplyByScalar(l,t,u),u=o.Cartesian3.add(p,u,u),r[e]=u.x,r[e+1]=u.y,r[e+2]=u.z}return e},T.polygonOutlinesFromHierarchy=function(e,t,i){const r=[],a=new b;let s,l,u;for(a.enqueue(e);0!==a.length;){const e=a.dequeue();let h=e.positions;if(t)for(u=h.length,s=0;s<u;s++)i.scaleToGeodeticSurface(h[s],h[s]);if(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0),h.length<3)continue;const p=e.holes?e.holes.length:0;for(s=0;s<p;s++){const h=e.holes[s];let p=h.positions;if(t)for(u=p.length,l=0;l<u;++l)i.scaleToGeodeticSurface(p[l],p[l]);if(p=n.arrayRemoveDuplicates(p,o.Cartesian3.equalsEpsilon,!0),p.length<3)continue;r.push(p);let d=0;for(c.defined(h.holes)&&(d=h.holes.length),l=0;l<d;l++)a.enqueue(h.holes[l])}r.push(h)}return r},T.polygonsFromHierarchy=function(e,t,i,r,a){const s=[],l=[],u=new b;for(u.enqueue(e);0!==u.length;){const e=u.dequeue();let h=e.positions;const p=e.holes;let d,f;if(r)for(f=h.length,d=0;d<f;d++)a.scaleToGeodeticSurface(h[d],h[d]);if(t||(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0)),h.length<3)continue;let y=i(h);if(!c.defined(y))continue;const g=[];let C=m.PolygonPipeline.computeWindingOrder2D(y);C===m.WindingOrder.CLOCKWISE&&(y.reverse(),h=h.slice().reverse());let b=h.slice();const T=c.defined(p)?p.length:0,x=[];let v;for(d=0;d<T;d++){const e=p[d];let s=e.positions;if(r)for(f=s.length,v=0;v<f;++v)a.scaleToGeodeticSurface(s[v],s[v]);if(t||(s=n.arrayRemoveDuplicates(s,o.Cartesian3.equalsEpsilon,!0)),s.length<3)continue;const l=i(s);if(!c.defined(l))continue;C=m.PolygonPipeline.computeWindingOrder2D(l),C===m.WindingOrder.CLOCKWISE&&(l.reverse(),s=s.slice().reverse()),x.push(s),g.push(b.length),b=b.concat(s),y=y.concat(l);let h=0;for(c.defined(e.holes)&&(h=e.holes.length),v=0;v<h;v++)u.enqueue(e.holes[v])}s.push({outerRing:h,holes:x}),l.push({positions:b,positions2D:y,holes:g})}return{hierarchy:s,polygons:l}};const R=new i.Cartesian2,N=new o.Cartesian3,O=new C.Quaternion,q=new g.Matrix3;T.computeBoundingRectangle=function(e,t,n,i,r){const a=C.Quaternion.fromAxisAngle(e,i,O),s=g.Matrix3.fromQuaternion(a,q);let l=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,p=Number.NEGATIVE_INFINITY;const d=n.length;for(let e=0;e<d;++e){const i=o.Cartesian3.clone(n[e],N);g.Matrix3.multiplyByVector(s,i,i);const r=t(i,R);c.defined(r)&&(l=Math.min(l,r.x),u=Math.max(u,r.x),h=Math.min(h,r.y),p=Math.max(p,r.y))}return r.x=l,r.y=h,r.width=u-l,r.height=p-h,r},T.createGeometryFromPositions=function(e,n,o,r,s,l,p){let f=m.PolygonPipeline.triangulate(n.positions2D,n.holes);f.length<3&&(f=[0,1,2]);const y=n.positions,g=c.defined(o),C=g?o.positions:void 0;if(s){const e=y.length,t=new Array(3*e);let n=0;for(let i=0;i<e;i++){const e=y[i];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const o={attributes:{position:new h.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})},indices:f,primitiveType:u.PrimitiveType.TRIANGLES};g&&(o.attributes.st=new h.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i.Cartesian2.packArray(C)}));const r=new u.Geometry(o);return l.normal?d.GeometryPipeline.computeNormal(r):r}return p===t.ArcType.GEODESIC?m.PolygonPipeline.computeSubdivision(e,y,f,C,r):p===t.ArcType.RHUMB?m.PolygonPipeline.computeRhumbLineSubdivision(e,y,f,C,r):void 0};const k=[],B=[],H=new o.Cartesian3,z=new o.Cartesian3;T.computeWallGeometry=function(e,n,i,r,s,l){let d,g,m,C,b,x,v,w,A,L=e.length,E=0,I=0;const P=c.defined(n),M=P?n.positions:void 0;if(s)for(g=3*L*2,d=new Array(2*g),P&&(A=2*L*2,w=new Array(2*A)),m=0;m<L;m++)C=e[m],b=e[(m+1)%L],d[E]=d[E+g]=C.x,++E,d[E]=d[E+g]=C.y,++E,d[E]=d[E+g]=C.z,++E,d[E]=d[E+g]=b.x,++E,d[E]=d[E+g]=b.y,++E,d[E]=d[E+g]=b.z,++E,P&&(x=M[m],v=M[(m+1)%L],w[I]=w[I+A]=x.x,++I,w[I]=w[I+A]=x.y,++I,w[I]=w[I+A]=v.x,++I,w[I]=w[I+A]=v.y,++I);else{const n=y.CesiumMath.chordLength(r,i.maximumRadius);let o=0;if(l===t.ArcType.GEODESIC)for(m=0;m<L;m++)o+=T.subdivideLineCount(e[m],e[(m+1)%L],n);else if(l===t.ArcType.RHUMB)for(m=0;m<L;m++)o+=T.subdivideRhumbLineCount(i,e[m],e[(m+1)%L],n);for(g=3*(o+L),d=new Array(2*g),P&&(A=2*(o+L),w=new Array(2*A)),m=0;m<L;m++){let o,r;C=e[m],b=e[(m+1)%L],P&&(x=M[m],v=M[(m+1)%L]),l===t.ArcType.GEODESIC?(o=T.subdivideLine(C,b,n,B),P&&(r=T.subdivideTexcoordLine(x,v,C,b,n,k))):l===t.ArcType.RHUMB&&(o=T.subdivideRhumbLine(i,C,b,n,B),P&&(r=T.subdivideTexcoordRhumbLine(x,v,i,C,b,n,k)));const a=o.length;for(let e=0;e<a;++e,++E)d[E]=o[e],d[E+g]=o[e];if(d[E]=b.x,d[E+g]=b.x,++E,d[E]=b.y,d[E+g]=b.y,++E,d[E]=b.z,d[E+g]=b.z,++E,P){const e=r.length;for(let t=0;t<e;++t,++I)w[I]=r[t],w[I+A]=r[t];w[I]=v.x,w[I+A]=v.x,++I,w[I]=v.y,w[I+A]=v.y,++I}}}L=d.length;const D=f.IndexDatatype.createTypedArray(L/3,L-6*e.length);let G=0;for(L/=6,m=0;m<L;m++){const e=m,t=e+1,n=e+L,i=n+1;C=o.Cartesian3.fromArray(d,3*e,H),b=o.Cartesian3.fromArray(d,3*t,z),o.Cartesian3.equalsEpsilon(C,b,y.CesiumMath.EPSILON10,y.CesiumMath.EPSILON10)||(D[G++]=e,D[G++]=n,D[G++]=t,D[G++]=t,D[G++]=n,D[G++]=i)}const _={attributes:new p.GeometryAttributes({position:new h.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})}),indices:D,primitiveType:u.PrimitiveType.TRIANGLES};P&&(_.attributes.st=new h.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w}));return new u.Geometry(_)};var F=T;e.PolygonGeometryLibrary=F}));
