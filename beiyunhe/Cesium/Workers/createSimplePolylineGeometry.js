define(["./defined-64766648","./Ellipsoid-fa58f06f","./ArcType-26a3f38d","./Transforms-b1e48e05","./Cartesian3-e96ac170","./Color-cad7c885","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./IndexDatatype-ed8b21cb","./Math-56779564","./PolylinePipeline-206d6e54","./GeographicProjection-868b0b16","./Matrix3-59918a96","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./Cartesian2-0a34ed75","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6","./IntersectionTests-39c3b1c1","./Plane-f9bf6226"],(function(e,o,t,r,l,n,i,a,s,p,c,d,y,u,f,h,C,g,T,m,P,_,B,E,A,b,k){"use strict";function G(e,o,t,r,l,i,a){const s=u.PolylinePipeline.numberOfPoints(e,o,l);let p;const c=t.red,d=t.green,y=t.blue,f=t.alpha,h=r.red,C=r.green,g=r.blue,T=r.alpha;if(n.Color.equals(t,r)){for(p=0;p<s;p++)i[a++]=n.Color.floatToByte(c),i[a++]=n.Color.floatToByte(d),i[a++]=n.Color.floatToByte(y),i[a++]=n.Color.floatToByte(f);return a}const m=(h-c)/s,P=(C-d)/s,_=(g-y)/s,B=(T-f)/s;let E=a;for(p=0;p<s;p++)i[E++]=n.Color.floatToByte(c+p*m),i[E++]=n.Color.floatToByte(d+p*P),i[E++]=n.Color.floatToByte(y+p*_),i[E++]=n.Color.floatToByte(f+p*B);return E}function D(r){const i=(r=a.defaultValue(r,a.defaultValue.EMPTY_OBJECT)).positions,s=r.colors,p=a.defaultValue(r.colorsPerVertex,!1);this._positions=i,this._colors=s,this._colorsPerVertex=p,this._arcType=a.defaultValue(r.arcType,t.ArcType.GEODESIC),this._granularity=a.defaultValue(r.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=a.defaultValue(r.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let c=1+i.length*l.Cartesian3.packedLength;c+=e.defined(s)?1+s.length*n.Color.packedLength:1,this.packedLength=c+o.Ellipsoid.packedLength+3}D.pack=function(t,r,i){let s;i=a.defaultValue(i,0);const p=t._positions;let c=p.length;for(r[i++]=c,s=0;s<c;++s,i+=l.Cartesian3.packedLength)l.Cartesian3.pack(p[s],r,i);const d=t._colors;for(c=e.defined(d)?d.length:0,r[i++]=c,s=0;s<c;++s,i+=n.Color.packedLength)n.Color.pack(d[s],r,i);return o.Ellipsoid.pack(t._ellipsoid,r,i),i+=o.Ellipsoid.packedLength,r[i++]=t._colorsPerVertex?1:0,r[i++]=t._arcType,r[i]=t._granularity,r},D.unpack=function(t,r,i){let s;r=a.defaultValue(r,0);let p=t[r++];const c=new Array(p);for(s=0;s<p;++s,r+=l.Cartesian3.packedLength)c[s]=l.Cartesian3.unpack(t,r);p=t[r++];const d=p>0?new Array(p):void 0;for(s=0;s<p;++s,r+=n.Color.packedLength)d[s]=n.Color.unpack(t,r);const y=o.Ellipsoid.unpack(t,r);r+=o.Ellipsoid.packedLength;const u=1===t[r++],f=t[r++],h=t[r];return e.defined(i)?(i._positions=c,i._colors=d,i._ellipsoid=y,i._colorsPerVertex=u,i._arcType=f,i._granularity=h,i):new D({positions:c,colors:d,ellipsoid:y,colorsPerVertex:u,arcType:f,granularity:h})};const L=new Array(2),w=new Array(2),V={positions:L,height:w,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return D.createGeometry=function(o){const a=o._positions,f=o._colors,h=o._colorsPerVertex,C=o._arcType,g=o._granularity,T=o._ellipsoid,m=y.CesiumMath.chordLength(g,T.maximumRadius),P=e.defined(f)&&!h;let _;const B=a.length;let E,A,b,k,D=0;if(C===t.ArcType.GEODESIC||C===t.ArcType.RHUMB){let o,r,l;C===t.ArcType.GEODESIC?(o=y.CesiumMath.chordLength(g,T.maximumRadius),r=u.PolylinePipeline.numberOfPoints,l=u.PolylinePipeline.generateArc):(o=g,r=u.PolylinePipeline.numberOfPointsRhumbLine,l=u.PolylinePipeline.generateRhumbArc);const i=u.PolylinePipeline.extractHeights(a,T),s=V;if(C===t.ArcType.GEODESIC?s.minDistance=m:s.granularity=g,s.ellipsoid=T,P){let t=0;for(_=0;_<B-1;_++)t+=r(a[_],a[_+1],o)+1;E=new Float64Array(3*t),b=new Uint8Array(4*t),s.positions=L,s.height=w;let p=0;for(_=0;_<B-1;++_){L[0]=a[_],L[1]=a[_+1],w[0]=i[_],w[1]=i[_+1];const o=l(s);if(e.defined(f)){const e=o.length/3;k=f[_];for(let o=0;o<e;++o)b[p++]=n.Color.floatToByte(k.red),b[p++]=n.Color.floatToByte(k.green),b[p++]=n.Color.floatToByte(k.blue),b[p++]=n.Color.floatToByte(k.alpha)}E.set(o,D),D+=o.length}}else if(s.positions=a,s.height=i,E=new Float64Array(l(s)),e.defined(f)){for(b=new Uint8Array(E.length/3*4),_=0;_<B-1;++_){D=G(a[_],a[_+1],f[_],f[_+1],m,b,D)}const e=f[B-1];b[D++]=n.Color.floatToByte(e.red),b[D++]=n.Color.floatToByte(e.green),b[D++]=n.Color.floatToByte(e.blue),b[D++]=n.Color.floatToByte(e.alpha)}}else{A=P?2*B-2:B,E=new Float64Array(3*A),b=e.defined(f)?new Uint8Array(4*A):void 0;let o=0,t=0;for(_=0;_<B;++_){const r=a[_];if(P&&_>0&&(l.Cartesian3.pack(r,E,o),o+=3,k=f[_-1],b[t++]=n.Color.floatToByte(k.red),b[t++]=n.Color.floatToByte(k.green),b[t++]=n.Color.floatToByte(k.blue),b[t++]=n.Color.floatToByte(k.alpha)),P&&_===B-1)break;l.Cartesian3.pack(r,E,o),o+=3,e.defined(f)&&(k=f[_],b[t++]=n.Color.floatToByte(k.red),b[t++]=n.Color.floatToByte(k.green),b[t++]=n.Color.floatToByte(k.blue),b[t++]=n.Color.floatToByte(k.alpha))}}const x=new c.GeometryAttributes;x.position=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:E}),e.defined(f)&&(x.color=new p.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:b,normalize:!0})),A=E.length/3;const I=2*(A-1),R=d.IndexDatatype.createTypedArray(A,I);let S=0;for(_=0;_<A-1;++_)R[S++]=_,R[S++]=_+1;return new s.Geometry({attributes:x,indices:R,primitiveType:s.PrimitiveType.LINES,boundingSphere:r.BoundingSphere.fromPoints(a)})},function(t,r){return e.defined(r)&&(t=D.unpack(t,r)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),D.createGeometry(t)}}));
