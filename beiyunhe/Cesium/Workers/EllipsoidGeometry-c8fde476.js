define(["exports","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./Ellipsoid-fa58f06f","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-ed8b21cb","./Math-56779564","./VertexFormat-01d05a0d"],(function(t,e,a,n,i,r,o,s,m,u,l,c,f,d,C){"use strict";const p=new n.Cartesian3,y=new n.Cartesian3,_=new n.Cartesian3,h=new n.Cartesian3,A=new n.Cartesian3,x=new n.Cartesian3(1,1,1),k=Math.cos,b=Math.sin;function w(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT);const e=r.defaultValue(t.radii,x),a=r.defaultValue(t.innerRadii,e),i=r.defaultValue(t.minimumClock,0),o=r.defaultValue(t.maximumClock,d.CesiumMath.TWO_PI),s=r.defaultValue(t.minimumCone,0),m=r.defaultValue(t.maximumCone,d.CesiumMath.PI),u=Math.round(r.defaultValue(t.stackPartitions,64)),l=Math.round(r.defaultValue(t.slicePartitions,64)),c=r.defaultValue(t.vertexFormat,C.VertexFormat.DEFAULT);this._radii=n.Cartesian3.clone(e),this._innerRadii=n.Cartesian3.clone(a),this._minimumClock=i,this._maximumClock=o,this._minimumCone=s,this._maximumCone=m,this._stackPartitions=u,this._slicePartitions=l,this._vertexFormat=C.VertexFormat.clone(c),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}w.packedLength=2*n.Cartesian3.packedLength+C.VertexFormat.packedLength+7,w.pack=function(t,e,a){return a=r.defaultValue(a,0),n.Cartesian3.pack(t._radii,e,a),a+=n.Cartesian3.packedLength,n.Cartesian3.pack(t._innerRadii,e,a),a+=n.Cartesian3.packedLength,C.VertexFormat.pack(t._vertexFormat,e,a),a+=C.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=r.defaultValue(t._offsetAttribute,-1),e};const P=new n.Cartesian3,g=new n.Cartesian3,v=new C.VertexFormat,F={radii:P,innerRadii:g,vertexFormat:v,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let V;w.unpack=function(t,e,a){e=r.defaultValue(e,0);const i=n.Cartesian3.unpack(t,e,P);e+=n.Cartesian3.packedLength;const s=n.Cartesian3.unpack(t,e,g);e+=n.Cartesian3.packedLength;const m=C.VertexFormat.unpack(t,e,v);e+=C.VertexFormat.packedLength;const u=t[e++],l=t[e++],c=t[e++],f=t[e++],d=t[e++],p=t[e++],y=t[e];return o.defined(a)?(a._radii=n.Cartesian3.clone(i,a._radii),a._innerRadii=n.Cartesian3.clone(s,a._innerRadii),a._vertexFormat=C.VertexFormat.clone(m,a._vertexFormat),a._minimumClock=u,a._maximumClock=l,a._minimumCone=c,a._maximumCone=f,a._stackPartitions=d,a._slicePartitions=p,a._offsetAttribute=-1===y?void 0:y,a):(F.minimumClock=u,F.maximumClock=l,F.minimumCone=c,F.maximumCone=f,F.stackPartitions=d,F.slicePartitions=p,F.offsetAttribute=-1===y?void 0:y,new w(F))},w.createGeometry=function(t){const r=t._radii;if(r.x<=0||r.y<=0||r.z<=0)return;const C=t._innerRadii;if(C.x<=0||C.y<=0||C.z<=0)return;const x=t._minimumClock,w=t._maximumClock,P=t._minimumCone,g=t._maximumCone,v=t._vertexFormat;let F,V,M=t._slicePartitions+1,T=t._stackPartitions+1;M=Math.round(M*Math.abs(w-x)/d.CesiumMath.TWO_PI),T=Math.round(T*Math.abs(g-P)/d.CesiumMath.PI),M<2&&(M=2),T<2&&(T=2);let G=0;const D=[P],L=[x];for(F=0;F<T;F++)D.push(P+F*(g-P)/(T-1));for(D.push(g),V=0;V<M;V++)L.push(x+V*(w-x)/(M-1));L.push(w);const O=D.length,I=L.length;let E=0,z=1;const N=C.x!==r.x||C.y!==r.y||C.z!==r.z;let R=!1,U=!1,S=!1;N&&(z=2,P>0&&(R=!0,E+=M-1),g<Math.PI&&(U=!0,E+=M-1),(w-x)%d.CesiumMath.TWO_PI?(S=!0,E+=2*(T-1)+1):E+=1);const B=I*O*z,W=new Float64Array(3*B),Y=new Array(B).fill(!1),j=new Array(B).fill(!1),J=M*T*z,X=6*(J+E+1-(M+T)*z),Z=f.IndexDatatype.createTypedArray(J,X),q=v.normal?new Float32Array(3*B):void 0,H=v.tangent?new Float32Array(3*B):void 0,K=v.bitangent?new Float32Array(3*B):void 0,Q=v.st?new Float32Array(2*B):void 0,$=new Array(O),tt=new Array(O);for(F=0;F<O;F++)$[F]=b(D[F]),tt[F]=k(D[F]);const et=new Array(I),at=new Array(I);for(V=0;V<I;V++)at[V]=k(L[V]),et[V]=b(L[V]);for(F=0;F<O;F++)for(V=0;V<I;V++)W[G++]=r.x*$[F]*at[V],W[G++]=r.y*$[F]*et[V],W[G++]=r.z*tt[F];let nt,it,rt,ot,st=B/2;if(N)for(F=0;F<O;F++)for(V=0;V<I;V++)W[G++]=C.x*$[F]*at[V],W[G++]=C.y*$[F]*et[V],W[G++]=C.z*tt[F],Y[st]=!0,F>0&&F!==O-1&&0!==V&&V!==I-1&&(j[st]=!0),st++;for(G=0,F=1;F<O-2;F++)for(nt=F*I,it=(F+1)*I,V=1;V<I-2;V++)Z[G++]=it+V,Z[G++]=it+V+1,Z[G++]=nt+V+1,Z[G++]=it+V,Z[G++]=nt+V+1,Z[G++]=nt+V;if(N){const t=O*I;for(F=1;F<O-2;F++)for(nt=t+F*I,it=t+(F+1)*I,V=1;V<I-2;V++)Z[G++]=it+V,Z[G++]=nt+V,Z[G++]=nt+V+1,Z[G++]=it+V,Z[G++]=nt+V+1,Z[G++]=it+V+1}if(N){if(R)for(ot=O*I,F=1;F<I-2;F++)Z[G++]=F,Z[G++]=F+1,Z[G++]=ot+F+1,Z[G++]=F,Z[G++]=ot+F+1,Z[G++]=ot+F;if(U)for(rt=O*I-I,ot=O*I*z-I,F=1;F<I-2;F++)Z[G++]=rt+F+1,Z[G++]=rt+F,Z[G++]=ot+F,Z[G++]=rt+F+1,Z[G++]=ot+F,Z[G++]=ot+F+1}if(S){for(F=1;F<O-2;F++)ot=I*O+I*F,rt=I*F,Z[G++]=ot,Z[G++]=rt+I,Z[G++]=rt,Z[G++]=ot,Z[G++]=ot+I,Z[G++]=rt+I;for(F=1;F<O-2;F++)ot=I*O+I*(F+1)-1,rt=I*(F+1)-1,Z[G++]=rt+I,Z[G++]=ot,Z[G++]=rt,Z[G++]=rt+I,Z[G++]=ot+I,Z[G++]=ot}const mt=new l.GeometryAttributes;v.position&&(mt.position=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:W}));let ut=0,lt=0,ct=0,ft=0;const dt=B/2;let Ct;const pt=s.Ellipsoid.fromCartesian3(r),yt=s.Ellipsoid.fromCartesian3(C);if(v.st||v.normal||v.tangent||v.bitangent){for(F=0;F<B;F++){Ct=Y[F]?yt:pt;const t=n.Cartesian3.fromArray(W,3*F,p),e=Ct.geodeticSurfaceNormal(t,y);if(j[F]&&n.Cartesian3.negate(e,e),v.st){const t=a.Cartesian2.negate(e,A);Q[ut++]=Math.atan2(t.y,t.x)/d.CesiumMath.TWO_PI+.5,Q[ut++]=Math.asin(e.z)/Math.PI+.5}if(v.normal&&(q[lt++]=e.x,q[lt++]=e.y,q[lt++]=e.z),v.tangent||v.bitangent){const t=_;let a,i=0;if(Y[F]&&(i=dt),a=!R&&F>=i&&F<i+2*I?n.Cartesian3.UNIT_X:n.Cartesian3.UNIT_Z,n.Cartesian3.cross(a,e,t),n.Cartesian3.normalize(t,t),v.tangent&&(H[ct++]=t.x,H[ct++]=t.y,H[ct++]=t.z),v.bitangent){const a=n.Cartesian3.cross(e,t,h);n.Cartesian3.normalize(a,a),K[ft++]=a.x,K[ft++]=a.y,K[ft++]=a.z}}}v.st&&(mt.st=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Q})),v.normal&&(mt.normal=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:q})),v.tangent&&(mt.tangent=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:H})),v.bitangent&&(mt.bitangent=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:K}))}if(o.defined(t._offsetAttribute)){const e=W.length,a=t._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(e/3).fill(a);mt.applyOffset=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new m.Geometry({attributes:mt,indices:Z,primitiveType:m.PrimitiveType.TRIANGLES,boundingSphere:e.BoundingSphere.fromEllipsoid(pt),offsetAttribute:t._offsetAttribute})},w.getUnitEllipsoid=function(){return o.defined(V)||(V=w.createGeometry(new w({radii:new n.Cartesian3(1,1,1),vertexFormat:C.VertexFormat.POSITION_ONLY}))),V},t.EllipsoidGeometry=w}));
