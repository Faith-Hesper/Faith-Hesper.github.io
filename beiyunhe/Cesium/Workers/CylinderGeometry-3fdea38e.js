define(["exports","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./CylinderGeometryLibrary-ae3f9c2b","./defaultValue-9f6a6288","./defined-64766648","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-ed8b21cb","./Math-56779564","./VertexFormat-01d05a0d"],(function(t,e,n,a,o,r,i,s,u,m,l,c,p,y,d){"use strict";const f=new n.Cartesian2,b=new a.Cartesian3,A=new a.Cartesian3,g=new a.Cartesian3,x=new a.Cartesian3;function _(t){const e=(t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT)).length,n=t.topRadius,a=t.bottomRadius,o=i.defaultValue(t.vertexFormat,d.VertexFormat.DEFAULT),r=i.defaultValue(t.slices,128);this._length=e,this._topRadius=n,this._bottomRadius=a,this._vertexFormat=d.VertexFormat.clone(o),this._slices=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}_.packedLength=d.VertexFormat.packedLength+5,_.pack=function(t,e,n){return n=i.defaultValue(n,0),d.VertexFormat.pack(t._vertexFormat,e,n),n+=d.VertexFormat.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=i.defaultValue(t._offsetAttribute,-1),e};const h=new d.VertexFormat,C={vertexFormat:h,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let v;_.unpack=function(t,e,n){e=i.defaultValue(e,0);const a=d.VertexFormat.unpack(t,e,h);e+=d.VertexFormat.packedLength;const o=t[e++],r=t[e++],u=t[e++],m=t[e++],l=t[e];return s.defined(n)?(n._vertexFormat=d.VertexFormat.clone(a,n._vertexFormat),n._length=o,n._topRadius=r,n._bottomRadius=u,n._slices=m,n._offsetAttribute=-1===l?void 0:l,n):(C.length=o,C.topRadius=r,C.bottomRadius=u,C.slices=m,C.offsetAttribute=-1===l?void 0:l,new _(C))},_.createGeometry=function(t){let i=t._length;const d=t._topRadius,_=t._bottomRadius,h=t._vertexFormat,C=t._slices;if(i<=0||d<0||_<0||0===d&&0===_)return;const v=C+C,F=C+v,w=v+v,G=r.CylinderGeometryLibrary.computePositions(i,d,_,C,!0),V=h.st?new Float32Array(2*w):void 0,D=h.normal?new Float32Array(3*w):void 0,R=h.tangent?new Float32Array(3*w):void 0,T=h.bitangent?new Float32Array(3*w):void 0;let O;const L=h.normal||h.tangent||h.bitangent;if(L){const t=h.tangent||h.bitangent;let e=0,n=0,o=0;const r=Math.atan2(_-d,i),s=b;s.z=Math.sin(r);const u=Math.cos(r);let m=g,l=A;for(O=0;O<C;O++){const r=O/C*y.CesiumMath.TWO_PI,i=u*Math.cos(r),c=u*Math.sin(r);L&&(s.x=i,s.y=c,t&&(m=a.Cartesian3.normalize(a.Cartesian3.cross(a.Cartesian3.UNIT_Z,s,m),m)),h.normal&&(D[e++]=s.x,D[e++]=s.y,D[e++]=s.z,D[e++]=s.x,D[e++]=s.y,D[e++]=s.z),h.tangent&&(R[n++]=m.x,R[n++]=m.y,R[n++]=m.z,R[n++]=m.x,R[n++]=m.y,R[n++]=m.z),h.bitangent&&(l=a.Cartesian3.normalize(a.Cartesian3.cross(s,m,l),l),T[o++]=l.x,T[o++]=l.y,T[o++]=l.z,T[o++]=l.x,T[o++]=l.y,T[o++]=l.z))}for(O=0;O<C;O++)h.normal&&(D[e++]=0,D[e++]=0,D[e++]=-1),h.tangent&&(R[n++]=1,R[n++]=0,R[n++]=0),h.bitangent&&(T[o++]=0,T[o++]=-1,T[o++]=0);for(O=0;O<C;O++)h.normal&&(D[e++]=0,D[e++]=0,D[e++]=1),h.tangent&&(R[n++]=1,R[n++]=0,R[n++]=0),h.bitangent&&(T[o++]=0,T[o++]=1,T[o++]=0)}const P=12*C-12,k=p.IndexDatatype.createTypedArray(w,P);let M=0,z=0;for(O=0;O<C-1;O++)k[M++]=z,k[M++]=z+2,k[M++]=z+3,k[M++]=z,k[M++]=z+3,k[M++]=z+1,z+=2;for(k[M++]=v-2,k[M++]=0,k[M++]=1,k[M++]=v-2,k[M++]=1,k[M++]=v-1,O=1;O<C-1;O++)k[M++]=v+O+1,k[M++]=v+O,k[M++]=v;for(O=1;O<C-1;O++)k[M++]=F,k[M++]=F+O,k[M++]=F+O+1;let E=0;if(h.st){const t=Math.max(d,_);for(O=0;O<w;O++){const e=a.Cartesian3.fromArray(G,3*O,x);V[E++]=(e.x+t)/(2*t),V[E++]=(e.y+t)/(2*t)}}const N=new l.GeometryAttributes;h.position&&(N.position=new m.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G})),h.normal&&(N.normal=new m.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),h.tangent&&(N.tangent=new m.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),h.bitangent&&(N.bitangent=new m.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),h.st&&(N.st=new m.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:V})),f.x=.5*i,f.y=Math.max(_,d);const I=new e.BoundingSphere(a.Cartesian3.ZERO,n.Cartesian2.magnitude(f));if(s.defined(t._offsetAttribute)){i=G.length;const e=t._offsetAttribute===c.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(i/3).fill(e);N.applyOffset=new m.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new u.Geometry({attributes:N,indices:k,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:I,offsetAttribute:t._offsetAttribute})},_.getUnitCylinder=function(){return s.defined(v)||(v=_.createGeometry(new _({topRadius:1,bottomRadius:1,length:1,vertexFormat:d.VertexFormat.POSITION_ONLY}))),v},t.CylinderGeometry=_}));
