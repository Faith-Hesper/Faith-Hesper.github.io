define(["exports","./Transforms-b1e48e05","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./defined-64766648","./Ellipsoid-fa58f06f","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-ed8b21cb","./Math-56779564"],(function(t,i,e,n,a,o,r,s,u,m,l,f,c){"use strict";const d=new e.Cartesian3(1,1,1),C=Math.cos,_=Math.sin;function p(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT);const i=a.defaultValue(t.radii,d),n=a.defaultValue(t.innerRadii,i),o=a.defaultValue(t.minimumClock,0),r=a.defaultValue(t.maximumClock,c.CesiumMath.TWO_PI),s=a.defaultValue(t.minimumCone,0),u=a.defaultValue(t.maximumCone,c.CesiumMath.PI),m=Math.round(a.defaultValue(t.stackPartitions,10)),l=Math.round(a.defaultValue(t.slicePartitions,8)),f=Math.round(a.defaultValue(t.subdivisions,128));this._radii=e.Cartesian3.clone(i),this._innerRadii=e.Cartesian3.clone(n),this._minimumClock=o,this._maximumClock=r,this._minimumCone=s,this._maximumCone=u,this._stackPartitions=m,this._slicePartitions=l,this._subdivisions=f,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}p.packedLength=2*e.Cartesian3.packedLength+8,p.pack=function(t,i,n){return n=a.defaultValue(n,0),e.Cartesian3.pack(t._radii,i,n),n+=e.Cartesian3.packedLength,e.Cartesian3.pack(t._innerRadii,i,n),n+=e.Cartesian3.packedLength,i[n++]=t._minimumClock,i[n++]=t._maximumClock,i[n++]=t._minimumCone,i[n++]=t._maximumCone,i[n++]=t._stackPartitions,i[n++]=t._slicePartitions,i[n++]=t._subdivisions,i[n]=a.defaultValue(t._offsetAttribute,-1),i};const h=new e.Cartesian3,y=new e.Cartesian3,k={radii:h,innerRadii:y,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};p.unpack=function(t,i,n){i=a.defaultValue(i,0);const r=e.Cartesian3.unpack(t,i,h);i+=e.Cartesian3.packedLength;const s=e.Cartesian3.unpack(t,i,y);i+=e.Cartesian3.packedLength;const u=t[i++],m=t[i++],l=t[i++],f=t[i++],c=t[i++],d=t[i++],C=t[i++],_=t[i];return o.defined(n)?(n._radii=e.Cartesian3.clone(r,n._radii),n._innerRadii=e.Cartesian3.clone(s,n._innerRadii),n._minimumClock=u,n._maximumClock=m,n._minimumCone=l,n._maximumCone=f,n._stackPartitions=c,n._slicePartitions=d,n._subdivisions=C,n._offsetAttribute=-1===_?void 0:_,n):(k.minimumClock=u,k.maximumClock=m,k.minimumCone=l,k.maximumCone=f,k.stackPartitions=c,k.slicePartitions=d,k.subdivisions=C,k.offsetAttribute=-1===_?void 0:_,new p(k))},p.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const a=t._innerRadii;if(a.x<=0||a.y<=0||a.z<=0)return;const d=t._minimumClock,p=t._maximumClock,h=t._minimumCone,y=t._maximumCone,k=t._subdivisions,b=r.Ellipsoid.fromCartesian3(e);let A=t._slicePartitions+1,x=t._stackPartitions+1;A=Math.round(A*Math.abs(p-d)/c.CesiumMath.TWO_PI),x=Math.round(x*Math.abs(y-h)/c.CesiumMath.PI),A<2&&(A=2),x<2&&(x=2);let P=0,v=1;const M=a.x!==e.x||a.y!==e.y||a.z!==e.z;let w=!1,V=!1;M&&(v=2,h>0&&(w=!0,P+=A),y<Math.PI&&(V=!0,P+=A));const g=k*v*(x+A),G=new Float64Array(3*g),E=2*(g+P-(A+x)*v),O=f.IndexDatatype.createTypedArray(g,E);let D,I,T,z,L=0;const R=new Array(x),N=new Array(x);for(D=0;D<x;D++)z=h+D*(y-h)/(x-1),R[D]=_(z),N[D]=C(z);const B=new Array(k),S=new Array(k);for(D=0;D<k;D++)T=d+D*(p-d)/(k-1),B[D]=_(T),S[D]=C(T);for(D=0;D<x;D++)for(I=0;I<k;I++)G[L++]=e.x*R[D]*S[I],G[L++]=e.y*R[D]*B[I],G[L++]=e.z*N[D];if(M)for(D=0;D<x;D++)for(I=0;I<k;I++)G[L++]=a.x*R[D]*S[I],G[L++]=a.y*R[D]*B[I],G[L++]=a.z*N[D];for(R.length=k,N.length=k,D=0;D<k;D++)z=h+D*(y-h)/(k-1),R[D]=_(z),N[D]=C(z);for(B.length=A,S.length=A,D=0;D<A;D++)T=d+D*(p-d)/(A-1),B[D]=_(T),S[D]=C(T);for(D=0;D<k;D++)for(I=0;I<A;I++)G[L++]=e.x*R[D]*S[I],G[L++]=e.y*R[D]*B[I],G[L++]=e.z*N[D];if(M)for(D=0;D<k;D++)for(I=0;I<A;I++)G[L++]=a.x*R[D]*S[I],G[L++]=a.y*R[D]*B[I],G[L++]=a.z*N[D];for(L=0,D=0;D<x*v;D++){const t=D*k;for(I=0;I<k-1;I++)O[L++]=t+I,O[L++]=t+I+1}let U=x*k*v;for(D=0;D<A;D++)for(I=0;I<k-1;I++)O[L++]=U+D+I*A,O[L++]=U+D+(I+1)*A;if(M)for(U=x*k*v+A*k,D=0;D<A;D++)for(I=0;I<k-1;I++)O[L++]=U+D+I*A,O[L++]=U+D+(I+1)*A;if(M){let t=x*k*v,i=t+k*A;if(w)for(D=0;D<A;D++)O[L++]=t+D,O[L++]=i+D;if(V)for(t+=k*A-A,i+=k*A-A,D=0;D<A;D++)O[L++]=t+D,O[L++]=i+D}const W=new m.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G})});if(o.defined(t._offsetAttribute)){const i=G.length,e=t._offsetAttribute===l.GeometryOffsetAttribute.NONE?0:1,a=new Uint8Array(i/3).fill(e);W.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new s.Geometry({attributes:W,indices:O,primitiveType:s.PrimitiveType.LINES,boundingSphere:i.BoundingSphere.fromEllipsoid(b),offsetAttribute:t._offsetAttribute})},t.EllipsoidOutlineGeometry=p}));
