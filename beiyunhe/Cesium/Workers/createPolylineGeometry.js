define(["./defined-64766648","./Ellipsoid-fa58f06f","./ArcType-26a3f38d","./arrayRemoveDuplicates-d0608faf","./Transforms-b1e48e05","./Cartesian3-e96ac170","./Color-cad7c885","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./IndexDatatype-ed8b21cb","./Math-56779564","./PolylinePipeline-206d6e54","./VertexFormat-01d05a0d","./GeographicProjection-868b0b16","./Matrix3-59918a96","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./Cartesian2-0a34ed75","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6","./IntersectionTests-39c3b1c1","./Plane-f9bf6226"],(function(e,t,o,r,n,a,i,l,s,c,p,d,u,y,m,h,f,C,g,_,A,E,P,x,w,T,b,k,D){"use strict";const v=[];function V(e,t,o,r,n){const a=v;let l;a.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,y=r.green,m=r.blue,h=r.alpha;if(i.Color.equals(o,r)){for(l=0;l<n;l++)a[l]=i.Color.clone(o);return a}const f=(u-s)/n,C=(y-c)/n,g=(m-p)/n,_=(h-d)/n;for(l=0;l<n;l++)a[l]=new i.Color(s+l*f,c+l*C,p+l*g,d+l*_);return a}function G(r){const n=(r=s.defaultValue(r,s.defaultValue.EMPTY_OBJECT)).positions,l=r.colors,c=s.defaultValue(r.width,1),p=s.defaultValue(r.colorsPerVertex,!1);this._positions=n,this._colors=l,this._width=c,this._colorsPerVertex=p,this._vertexFormat=h.VertexFormat.clone(s.defaultValue(r.vertexFormat,h.VertexFormat.DEFAULT)),this._arcType=s.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=s.defaultValue(r.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(s.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let d=1+n.length*a.Cartesian3.packedLength;d+=e.defined(l)?1+l.length*i.Color.packedLength:1,this.packedLength=d+t.Ellipsoid.packedLength+h.VertexFormat.packedLength+4}G.pack=function(o,r,n){let l;n=s.defaultValue(n,0);const c=o._positions;let p=c.length;for(r[n++]=p,l=0;l<p;++l,n+=a.Cartesian3.packedLength)a.Cartesian3.pack(c[l],r,n);const d=o._colors;for(p=e.defined(d)?d.length:0,r[n++]=p,l=0;l<p;++l,n+=i.Color.packedLength)i.Color.pack(d[l],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,h.VertexFormat.pack(o._vertexFormat,r,n),n+=h.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const L=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),F=new h.VertexFormat,R={positions:void 0,colors:void 0,ellipsoid:L,vertexFormat:F,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};G.unpack=function(o,r,n){let l;r=s.defaultValue(r,0);let c=o[r++];const p=new Array(c);for(l=0;l<c;++l,r+=a.Cartesian3.packedLength)p[l]=a.Cartesian3.unpack(o,r);c=o[r++];const d=c>0?new Array(c):void 0;for(l=0;l<c;++l,r+=i.Color.packedLength)d[l]=i.Color.unpack(o,r);const u=t.Ellipsoid.unpack(o,r,L);r+=t.Ellipsoid.packedLength;const y=h.VertexFormat.unpack(o,r,F);r+=h.VertexFormat.packedLength;const m=o[r++],f=1===o[r++],C=o[r++],g=o[r];return e.defined(n)?(n._positions=p,n._colors=d,n._ellipsoid=t.Ellipsoid.clone(u,n._ellipsoid),n._vertexFormat=h.VertexFormat.clone(y,n._vertexFormat),n._width=m,n._colorsPerVertex=f,n._arcType=C,n._granularity=g,n):(R.positions=p,R.colors=d,R.width=m,R.colorsPerVertex=f,R.arcType=C,R.granularity=g,new G(R))};const I=new a.Cartesian3,O=new a.Cartesian3,S=new a.Cartesian3,B=new a.Cartesian3;return G.createGeometry=function(t){const s=t._width,h=t._vertexFormat;let f=t._colors;const C=t._colorsPerVertex,g=t._arcType,_=t._granularity,A=t._ellipsoid;let E,P,x;const w=[];let T=r.arrayRemoveDuplicates(t._positions,a.Cartesian3.equalsEpsilon,!1,w);if(e.defined(f)&&w.length>0){let e=0,t=w[0];f=f.filter((function(o,r){let n=!1;return n=C?r===t||0===r&&1===t:r+1===t,!n||(e++,t=w[e],!1)}))}let b=T.length;if(b<2||s<=0)return;if(g===o.ArcType.GEODESIC||g===o.ArcType.RHUMB){let t,r;g===o.ArcType.GEODESIC?(t=y.CesiumMath.chordLength(_,A.maximumRadius),r=m.PolylinePipeline.numberOfPoints):(t=_,r=m.PolylinePipeline.numberOfPointsRhumbLine);const n=m.PolylinePipeline.extractHeights(T,A);if(e.defined(f)){let e=1;for(E=0;E<b-1;++E)e+=r(T[E],T[E+1],t);const o=new Array(e);let n=0;for(E=0;E<b-1;++E){const a=T[E],l=T[E+1],s=f[E],c=r(a,l,t);if(C&&E<e){const e=V(0,0,s,f[E+1],c),t=e.length;for(P=0;P<t;++P)o[n++]=e[P]}else for(P=0;P<c;++P)o[n++]=i.Color.clone(s)}o[n]=i.Color.clone(f[f.length-1]),f=o,v.length=0}T=g===o.ArcType.GEODESIC?m.PolylinePipeline.generateCartesianArc({positions:T,minDistance:t,ellipsoid:A,height:n}):m.PolylinePipeline.generateCartesianRhumbArc({positions:T,granularity:t,ellipsoid:A,height:n})}b=T.length;const k=4*b-4,D=new Float64Array(3*k),G=new Float64Array(3*k),L=new Float64Array(3*k),F=new Float32Array(2*k),R=h.st?new Float32Array(2*k):void 0,M=e.defined(f)?new Uint8Array(4*k):void 0;let N,U=0,W=0,q=0,H=0;for(P=0;P<b;++P){let t,o;0===P?(N=I,a.Cartesian3.subtract(T[0],T[1],N),a.Cartesian3.add(T[0],N,N)):N=T[P-1],a.Cartesian3.clone(N,S),a.Cartesian3.clone(T[P],O),P===b-1?(N=I,a.Cartesian3.subtract(T[b-1],T[b-2],N),a.Cartesian3.add(T[b-1],N,N)):N=T[P+1],a.Cartesian3.clone(N,B),e.defined(M)&&(t=0===P||C?f[P]:f[P-1],P!==b-1&&(o=f[P]));const r=P===b-1?2:4;for(x=0===P?2:0;x<r;++x){a.Cartesian3.pack(O,D,U),a.Cartesian3.pack(S,G,U),a.Cartesian3.pack(B,L,U),U+=3;const r=x-2<0?-1:1;if(F[W++]=x%2*2-1,F[W++]=r*s,h.st&&(R[q++]=P/(b-1),R[q++]=Math.max(F[W-2],0)),e.defined(M)){const e=x<2?t:o;M[H++]=i.Color.floatToByte(e.red),M[H++]=i.Color.floatToByte(e.green),M[H++]=i.Color.floatToByte(e.blue),M[H++]=i.Color.floatToByte(e.alpha)}}}const Y=new d.GeometryAttributes;Y.position=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D}),Y.prevPosition=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),Y.nextPosition=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:L}),Y.expandAndWidth=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F}),h.st&&(Y.st=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R})),e.defined(M)&&(Y.color=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:M,normalize:!0}));const j=u.IndexDatatype.createTypedArray(k,6*b-6);let J=0,z=0;const K=b-1;for(P=0;P<K;++P)j[z++]=J,j[z++]=J+2,j[z++]=J+1,j[z++]=J+1,j[z++]=J+2,j[z++]=J+3,J+=4;return new c.Geometry({attributes:Y,indices:j,primitiveType:c.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(T),geometryType:c.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=G.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),G.createGeometry(o)}}));
