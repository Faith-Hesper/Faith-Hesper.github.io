define(["exports","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./Ellipsoid-fa58f06f","./defaultValue-9f6a6288","./defined-64766648","./Matrix2-e52b9454","./Matrix3-59918a96","./WebGLConstants-7f557f93","./Transforms-b1e48e05"],(function(t,e,n,i,a,r,s,o,u,I){"use strict";var N=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const T={POINTS:u.WebGLConstants.POINTS,LINES:u.WebGLConstants.LINES,LINE_LOOP:u.WebGLConstants.LINE_LOOP,LINE_STRIP:u.WebGLConstants.LINE_STRIP,TRIANGLES:u.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:u.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:u.WebGLConstants.TRIANGLE_FAN,isLines:function(t){return t===T.LINES||t===T.LINE_LOOP||t===T.LINE_STRIP},isTriangles:function(t){return t===T.TRIANGLES||t===T.TRIANGLE_STRIP||t===T.TRIANGLE_FAN},validate:function(t){return t===T.POINTS||t===T.LINES||t===T.LINE_LOOP||t===T.LINE_STRIP||t===T.TRIANGLES||t===T.TRIANGLE_STRIP||t===T.TRIANGLE_FAN}};var L=Object.freeze(T);function c(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=a.defaultValue(t.primitiveType,L.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=a.defaultValue(t.geometryType,N.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}c.computeNumberOfVertices=function(t){let e=-1;for(const n in t.attributes)if(t.attributes.hasOwnProperty(n)&&r.defined(t.attributes[n])&&r.defined(t.attributes[n].values)){const i=t.attributes[n];e=i.values.length/i.componentsPerAttribute}return e};const E=new i.Cartographic,l=new n.Cartesian3,C=new s.Matrix4,f=[new i.Cartographic,new i.Cartographic,new i.Cartographic],y=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],p=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],b=new n.Cartesian3,x=new I.Quaternion,S=new s.Matrix4,d=new s.Matrix2;c._textureCoordinateRotationPoints=function(t,a,r,u){let N;const T=e.Rectangle.center(u,E),L=i.Cartographic.toCartesian(T,r,l),c=I.Transforms.eastNorthUpToFixedFrame(L,r,C),h=s.Matrix4.inverse(c,C),m=y,A=f;A[0].longitude=u.west,A[0].latitude=u.south,A[1].longitude=u.west,A[1].latitude=u.north,A[2].longitude=u.east,A[2].latitude=u.south;let G=b;for(N=0;N<3;N++)i.Cartographic.toCartesian(A[N],r,G),G=s.Matrix4.multiplyByPointAsVector(h,G,G),m[N].x=G.x,m[N].y=G.y;const P=I.Quaternion.fromAxisAngle(n.Cartesian3.UNIT_Z,-a,x),R=o.Matrix3.fromQuaternion(P,S),_=t.length;let O=Number.POSITIVE_INFINITY,g=Number.POSITIVE_INFINITY,w=Number.NEGATIVE_INFINITY,M=Number.NEGATIVE_INFINITY;for(N=0;N<_;N++)G=s.Matrix4.multiplyByPointAsVector(h,t[N],G),G=o.Matrix3.multiplyByVector(R,G,G),O=Math.min(O,G.x),g=Math.min(g,G.y),w=Math.max(w,G.x),M=Math.max(M,G.y);const V=s.Matrix2.fromRotation(a,d),F=p;F[0].x=O,F[0].y=g,F[1].x=O,F[1].y=M,F[2].x=w,F[2].y=g;const v=m[0],W=m[2].x-v.x,Y=m[1].y-v.y;for(N=0;N<3;N++){const t=F[N];s.Matrix2.multiplyByVector(V,t,t),t.x=(t.x-v.x)/W,t.y=(t.y-v.y)/Y}const B=F[0],k=F[1],Q=F[2],j=new Array(6);return e.Cartesian2.pack(B,j),e.Cartesian2.pack(k,j,2),e.Cartesian2.pack(Q,j,4),j},t.Geometry=c,t.GeometryType=N,t.PrimitiveType=L}));
