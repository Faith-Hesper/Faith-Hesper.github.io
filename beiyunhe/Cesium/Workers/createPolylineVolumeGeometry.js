define(["./defined-64766648","./Ellipsoid-fa58f06f","./arrayRemoveDuplicates-d0608faf","./BoundingRectangle-3100662d","./Transforms-b1e48e05","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./PolylineVolumeGeometryLibrary-b5caf6df","./defaultValue-9f6a6288","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryPipeline-92c34dd1","./IndexDatatype-ed8b21cb","./Math-56779564","./PolygonPipeline-d79010c3","./VertexFormat-01d05a0d","./GeographicProjection-868b0b16","./Matrix3-59918a96","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93","./EllipsoidTangentPlane-8f36a7e0","./AxisAlignedBoundingBox-8b4e9f9c","./IntersectionTests-39c3b1c1","./Plane-f9bf6226","./PolylinePipeline-206d6e54","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6","./AttributeCompression-44abee07","./EncodedCartesian3-e0f0a7d1"],(function(e,t,n,o,i,r,a,l,s,p,c,u,d,m,y,g,h,f,E,P,_,b,k,v,C,V,x,G,L,A,F,T,D,R,w){"use strict";function B(e){const n=(e=p.defaultValue(e,p.defaultValue.EMPTY_OBJECT)).polylinePositions,o=e.shapePositions;this._positions=n,this._shape=o,this._ellipsoid=t.Ellipsoid.clone(p.defaultValue(e.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=p.defaultValue(e.cornerType,s.CornerType.ROUNDED),this._vertexFormat=f.VertexFormat.clone(p.defaultValue(e.vertexFormat,f.VertexFormat.DEFAULT)),this._granularity=p.defaultValue(e.granularity,g.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let i=1+n.length*a.Cartesian3.packedLength;i+=1+o.length*r.Cartesian2.packedLength,this.packedLength=i+t.Ellipsoid.packedLength+f.VertexFormat.packedLength+2}B.pack=function(e,n,o){let i;o=p.defaultValue(o,0);const l=e._positions;let s=l.length;for(n[o++]=s,i=0;i<s;++i,o+=a.Cartesian3.packedLength)a.Cartesian3.pack(l[i],n,o);const c=e._shape;for(s=c.length,n[o++]=s,i=0;i<s;++i,o+=r.Cartesian2.packedLength)r.Cartesian2.pack(c[i],n,o);return t.Ellipsoid.pack(e._ellipsoid,n,o),o+=t.Ellipsoid.packedLength,f.VertexFormat.pack(e._vertexFormat,n,o),o+=f.VertexFormat.packedLength,n[o++]=e._cornerType,n[o]=e._granularity,n};const S=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),I=new f.VertexFormat,N={polylinePositions:void 0,shapePositions:void 0,ellipsoid:S,vertexFormat:I,cornerType:void 0,granularity:void 0};B.unpack=function(n,o,i){let l;o=p.defaultValue(o,0);let s=n[o++];const c=new Array(s);for(l=0;l<s;++l,o+=a.Cartesian3.packedLength)c[l]=a.Cartesian3.unpack(n,o);s=n[o++];const u=new Array(s);for(l=0;l<s;++l,o+=r.Cartesian2.packedLength)u[l]=r.Cartesian2.unpack(n,o);const d=t.Ellipsoid.unpack(n,o,S);o+=t.Ellipsoid.packedLength;const m=f.VertexFormat.unpack(n,o,I);o+=f.VertexFormat.packedLength;const y=n[o++],g=n[o];return e.defined(i)?(i._positions=c,i._shape=u,i._ellipsoid=t.Ellipsoid.clone(d,i._ellipsoid),i._vertexFormat=f.VertexFormat.clone(m,i._vertexFormat),i._cornerType=y,i._granularity=g,i):(N.polylinePositions=c,N.shapePositions=u,N.cornerType=y,N.granularity=g,new B(N))};const O=new o.BoundingRectangle;return B.createGeometry=function(e){const t=e._positions,r=n.arrayRemoveDuplicates(t,a.Cartesian3.equalsEpsilon);let p=e._shape;if(p=s.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(p),r.length<2||p.length<3)return;h.PolygonPipeline.computeWindingOrder2D(p)===h.WindingOrder.CLOCKWISE&&p.reverse();const g=o.BoundingRectangle.fromPoints(p,O);return function(e,t,n,o){const r=new d.GeometryAttributes;o.position&&(r.position=new u.GeometryAttribute({componentDatatype:l.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));const a=t.length,p=e.length/3,g=(p-2*a)/(2*a),f=h.PolygonPipeline.triangulate(t),E=(g-1)*a*6+2*f.length,P=y.IndexDatatype.createTypedArray(p,E);let _,b,k,v,C,V;const x=2*a;let G=0;for(_=0;_<g-1;_++){for(b=0;b<a-1;b++)k=2*b+_*a*2,V=k+x,v=k+1,C=v+x,P[G++]=v,P[G++]=k,P[G++]=C,P[G++]=C,P[G++]=k,P[G++]=V;k=2*a-2+_*a*2,v=k+1,C=v+x,V=k+x,P[G++]=v,P[G++]=k,P[G++]=C,P[G++]=C,P[G++]=k,P[G++]=V}if(o.st||o.tangent||o.bitangent){const e=new Float32Array(2*p),o=1/(g-1),i=1/n.height,s=n.height/2;let c,d,m=0;for(_=0;_<g;_++){for(c=_*o,d=i*(t[0].y+s),e[m++]=c,e[m++]=d,b=1;b<a;b++)d=i*(t[b].y+s),e[m++]=c,e[m++]=d,e[m++]=c,e[m++]=d;d=i*(t[0].y+s),e[m++]=c,e[m++]=d}for(b=0;b<a;b++)c=0,d=i*(t[b].y+s),e[m++]=c,e[m++]=d;for(b=0;b<a;b++)c=(g-1)*o,d=i*(t[b].y+s),e[m++]=c,e[m++]=d;r.st=new u.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const L=p-2*a;for(_=0;_<f.length;_+=3){const e=f[_]+L,t=f[_+1]+L,n=f[_+2]+L;P[G++]=e,P[G++]=t,P[G++]=n,P[G++]=n+a,P[G++]=t+a,P[G++]=e+a}let A=new c.Geometry({attributes:r,indices:P,boundingSphere:i.BoundingSphere.fromVertices(e),primitiveType:c.PrimitiveType.TRIANGLES});if(o.normal&&(A=m.GeometryPipeline.computeNormal(A)),o.tangent||o.bitangent){try{A=m.GeometryPipeline.computeTangentAndBitangent(A)}catch(e){s.oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}o.tangent||(A.attributes.tangent=void 0),o.bitangent||(A.attributes.bitangent=void 0),o.st||(A.attributes.st=void 0)}return A}(s.PolylineVolumeGeometryLibrary.computePositions(r,p,g,e,!0),p,g,e._vertexFormat)},function(n,o){return e.defined(o)&&(n=B.unpack(n,o)),n._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),B.createGeometry(n)}}));
