define(["./arrayRemoveDuplicates-d0608faf","./Transforms-b1e48e05","./Cartesian3-e96ac170","./ComponentDatatype-63fd8cd4","./PolylineVolumeGeometryLibrary-b5caf6df","./CorridorGeometryLibrary-5378285c","./defaultValue-9f6a6288","./defined-64766648","./Ellipsoid-fa58f06f","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./GeometryAttributes-3de79df5","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-ed8b21cb","./Math-56779564","./PolygonPipeline-d79010c3","./GeographicProjection-868b0b16","./Matrix3-59918a96","./Matrix2-e52b9454","./RuntimeError-cfbf2bc8","./Cartesian2-0a34ed75","./Resource-be841477","./combine-ac72e009","./defer-7878b392","./WebGLConstants-7f557f93","./EllipsoidTangentPlane-8f36a7e0","./AxisAlignedBoundingBox-8b4e9f9c","./IntersectionTests-39c3b1c1","./Plane-f9bf6226","./PolylinePipeline-206d6e54","./EllipsoidGeodesic-9e013872","./EllipsoidRhumbLine-cea00df6"],(function(e,t,i,r,o,n,s,a,l,d,u,p,f,h,c,y,g,b,m,A,_,E,C,G,P,T,v,w,L,D,x,k){"use strict";const N=new i.Cartesian3,V=new i.Cartesian3,H=new i.Cartesian3;function O(e,t){const s=[],l=e.positions,d=e.corners,f=e.endPositions,c=new p.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<l.length;g+=2)b=l[g].length-3,m+=b,_+=b/3*4,A+=l[g+1].length-3;for(m+=3,A+=3,g=0;g<d.length;g++){y=d[g];const e=d[g].leftPositions;a.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=d[g].rightPositions.length,A+=b,_+=b/3*2)}const E=a.defined(f);let C;E&&(C=f[0].length-3,m+=C,A+=C,C/=3,_+=4*C);const G=m+A,P=new Float64Array(G);let T,v,w,L,D,x,k=0,O=G-1;const I=C/2,M=h.IndexDatatype.createTypedArray(G/3,_+4);let R=0;if(M[R++]=k/3,M[R++]=(O-2)/3,E){s.push(k/3),x=N,D=V;const e=f[0];for(g=0;g<I;g++)x=i.Cartesian3.fromArray(e,3*(I-1-g),x),D=i.Cartesian3.fromArray(e,3*(I+g),D),n.CorridorGeometryLibrary.addAttribute(P,D,k),n.CorridorGeometryLibrary.addAttribute(P,x,void 0,O),v=k/3,L=v+1,T=(O-2)/3,w=T-1,M[R++]=T,M[R++]=w,M[R++]=v,M[R++]=L,k+=3,O-=3}let S=0,B=l[S++],U=l[S++];for(P.set(B,k),P.set(U,O-U.length+1),b=U.length-3,s.push(k/3,(O-2)/3),g=0;g<b;g+=3)v=k/3,L=v+1,T=(O-2)/3,w=T-1,M[R++]=T,M[R++]=w,M[R++]=v,M[R++]=L,k+=3,O-=3;for(g=0;g<d.length;g++){let e;y=d[g];const r=y.leftPositions,u=y.rightPositions;let p,f=H;if(a.defined(r)){for(O-=3,p=w,s.push(L),e=0;e<r.length/3;e++)f=i.Cartesian3.fromArray(r,3*e,f),M[R++]=p-e-1,M[R++]=p-e,n.CorridorGeometryLibrary.addAttribute(P,f,void 0,O),O-=3;s.push(p-Math.floor(r.length/6)),t===o.CornerType.BEVELED&&s.push((O-2)/3+1),k+=3}else{for(k+=3,p=L,s.push(w),e=0;e<u.length/3;e++)f=i.Cartesian3.fromArray(u,3*e,f),M[R++]=p+e,M[R++]=p+e+1,n.CorridorGeometryLibrary.addAttribute(P,f,k),k+=3;s.push(p+Math.floor(u.length/6)),t===o.CornerType.BEVELED&&s.push(k/3-1),O-=3}for(B=l[S++],U=l[S++],B.splice(0,3),U.splice(U.length-3,3),P.set(B,k),P.set(U,O-U.length+1),b=U.length-3,e=0;e<U.length;e+=3)L=k/3,v=L-1,w=(O-2)/3,T=w+1,M[R++]=T,M[R++]=w,M[R++]=v,M[R++]=L,k+=3,O-=3;k-=3,O+=3,s.push(k/3,(O-2)/3)}if(E){k+=3,O-=3,x=N,D=V;const e=f[1];for(g=0;g<I;g++)x=i.Cartesian3.fromArray(e,3*(C-g-1),x),D=i.Cartesian3.fromArray(e,3*g,D),n.CorridorGeometryLibrary.addAttribute(P,x,void 0,O),n.CorridorGeometryLibrary.addAttribute(P,D,k),L=k/3,v=L-1,w=(O-2)/3,T=w+1,M[R++]=T,M[R++]=w,M[R++]=v,M[R++]=L,k+=3,O-=3;s.push(k/3)}else s.push(k/3,(O-2)/3);return M[R++]=k/3,M[R++]=(O-2)/3,c.position=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:P}),{attributes:c,indices:M,wallIndices:s}}function I(e){const t=(e=s.defaultValue(e,s.defaultValue.EMPTY_OBJECT)).positions,r=e.width,n=s.defaultValue(e.height,0),a=s.defaultValue(e.extrudedHeight,n);this._positions=t,this._ellipsoid=l.Ellipsoid.clone(s.defaultValue(e.ellipsoid,l.Ellipsoid.WGS84)),this._width=r,this._height=Math.max(n,a),this._extrudedHeight=Math.min(n,a),this._cornerType=s.defaultValue(e.cornerType,o.CornerType.ROUNDED),this._granularity=s.defaultValue(e.granularity,c.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*i.Cartesian3.packedLength+l.Ellipsoid.packedLength+6}I.pack=function(e,t,r){r=s.defaultValue(r,0);const o=e._positions,n=o.length;t[r++]=n;for(let e=0;e<n;++e,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(o[e],t,r);return l.Ellipsoid.pack(e._ellipsoid,t,r),r+=l.Ellipsoid.packedLength,t[r++]=e._width,t[r++]=e._height,t[r++]=e._extrudedHeight,t[r++]=e._cornerType,t[r++]=e._granularity,t[r]=s.defaultValue(e._offsetAttribute,-1),t};const M=l.Ellipsoid.clone(l.Ellipsoid.UNIT_SPHERE),R={positions:void 0,ellipsoid:M,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return I.unpack=function(e,t,r){t=s.defaultValue(t,0);const o=e[t++],n=new Array(o);for(let r=0;r<o;++r,t+=i.Cartesian3.packedLength)n[r]=i.Cartesian3.unpack(e,t);const d=l.Ellipsoid.unpack(e,t,M);t+=l.Ellipsoid.packedLength;const u=e[t++],p=e[t++],f=e[t++],h=e[t++],c=e[t++],y=e[t];return a.defined(r)?(r._positions=n,r._ellipsoid=l.Ellipsoid.clone(d,r._ellipsoid),r._width=u,r._height=p,r._extrudedHeight=f,r._cornerType=h,r._granularity=c,r._offsetAttribute=-1===y?void 0:y,r):(R.positions=n,R.width=u,R.height=p,R.extrudedHeight=f,R.cornerType=h,R.granularity=c,R.offsetAttribute=-1===y?void 0:y,new I(R))},I.createGeometry=function(o){let s=o._positions;const l=o._width,p=o._ellipsoid;s=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(s,p);const g=e.arrayRemoveDuplicates(s,i.Cartesian3.equalsEpsilon);if(g.length<2||l<=0)return;const b=o._height,m=o._extrudedHeight,A=!c.CesiumMath.equalsEpsilon(b,m,0,c.CesiumMath.EPSILON2),_={ellipsoid:p,positions:g,width:l,cornerType:o._cornerType,granularity:o._granularity,saveAttributes:!1};let E;if(A)_.height=b,_.extrudedHeight=m,_.offsetAttribute=o._offsetAttribute,E=function(e){const t=e.ellipsoid,i=O(n.CorridorGeometryLibrary.computePositions(e),e.cornerType),o=i.wallIndices,s=e.height,l=e.extrudedHeight,d=i.attributes,p=i.indices;let c=d.position.values,g=c.length,b=new Float64Array(g);b.set(c);const m=new Float64Array(2*g);if(c=y.PolygonPipeline.scaleToGeodeticHeight(c,s,t),b=y.PolygonPipeline.scaleToGeodeticHeight(b,l,t),m.set(c),m.set(b,g),d.position.values=m,g/=3,a.defined(e.offsetAttribute)){let t=new Uint8Array(2*g);if(e.offsetAttribute===f.GeometryOffsetAttribute.TOP)t=t.fill(1,0,g);else{const i=e.offsetAttribute===f.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}d.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let A;const _=p.length,E=h.IndexDatatype.createTypedArray(m.length/3,2*(_+o.length));E.set(p);let C,G,P=_;for(A=0;A<_;A+=2){const e=p[A],t=p[A+1];E[P++]=e+g,E[P++]=t+g}for(A=0;A<o.length;A++)C=o[A],G=C+g,E[P++]=C,E[P++]=G;return{attributes:d,indices:E}}(_);else{if(E=O(n.CorridorGeometryLibrary.computePositions(_),_.cornerType),E.attributes.position.values=y.PolygonPipeline.scaleToGeodeticHeight(E.attributes.position.values,b,p),a.defined(o._offsetAttribute)){const e=E.attributes.position.values.length,t=o._offsetAttribute===f.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(t);E.attributes.applyOffset=new u.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}const C=E.attributes,G=t.BoundingSphere.fromVertices(C.position.values,void 0,3);return new d.Geometry({attributes:C,indices:E.indices,primitiveType:d.PrimitiveType.LINES,boundingSphere:G,offsetAttribute:o._offsetAttribute})},function(e,t){return a.defined(t)&&(e=I.unpack(e,t)),e._ellipsoid=l.Ellipsoid.clone(e._ellipsoid),I.createGeometry(e)}}));
