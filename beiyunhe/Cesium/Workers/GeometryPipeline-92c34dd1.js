define(["exports","./AttributeCompression-44abee07","./Cartesian2-0a34ed75","./Cartesian3-e96ac170","./defined-64766648","./Math-56779564","./Transforms-b1e48e05","./Matrix2-e52b9454","./Ellipsoid-fa58f06f","./ComponentDatatype-63fd8cd4","./defaultValue-9f6a6288","./EncodedCartesian3-e0f0a7d1","./GeographicProjection-868b0b16","./Geometry-dd0ae099","./GeometryAttribute-5ac032ac","./IndexDatatype-ed8b21cb","./IntersectionTests-39c3b1c1","./Matrix3-59918a96","./Plane-f9bf6226"],(function(e,t,n,i,r,a,s,o,u,c,l,p,d,y,f,m,C,h,v){"use strict";const b=new i.Cartesian3,g=new i.Cartesian3,A=new i.Cartesian3;const T={calculateACMR:function(e){const t=(e=l.defaultValue(e,l.defaultValue.EMPTY_OBJECT)).indices;let n=e.maximumIndex;const i=l.defaultValue(e.cacheSize,24),a=t.length;if(!r.defined(n)){n=0;let e=0,i=t[e];for(;e<a;)i>n&&(n=i),++e,i=t[e]}const s=[];for(let e=0;e<n+1;e++)s[e]=0;let o=i+1;for(let e=0;e<a;++e)o-s[t[e]]>i&&(s[t[e]]=o,++o);return(o-i+1)/(a/3)}};T.tipsify=function(e){const t=(e=l.defaultValue(e,l.defaultValue.EMPTY_OBJECT)).indices,n=e.maximumIndex,i=l.defaultValue(e.cacheSize,24);let a;function s(e,t,n,i,r,s,o){let u,c=-1,l=-1,p=0;for(;p<n.length;){const e=n[p];i[e].numLiveTriangles&&(u=0,r-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(u=r-i[e].timeStamp),(u>l||-1===l)&&(l=u,c=e)),++p}return-1===c?function(e,t,n,i){for(;t.length>=1;){const n=t[t.length-1];if(t.splice(t.length-1,1),e[n].numLiveTriangles>0)return n}for(;a<i;){if(e[a].numLiveTriangles>0)return++a,a-1;++a}return-1}(i,s,0,o):c}const o=t.length;let u=0,c=0,p=t[c];const d=o;if(r.defined(n))u=n+1;else{for(;c<d;)p>u&&(u=p),++c,p=t[c];if(-1===u)return 0;++u}const y=[];let f;for(f=0;f<u;f++)y[f]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};c=0;let m=0;for(;c<d;)y[t[c]].vertexTriangles.push(m),++y[t[c]].numLiveTriangles,y[t[c+1]].vertexTriangles.push(m),++y[t[c+1]].numLiveTriangles,y[t[c+2]].vertexTriangles.push(m),++y[t[c+2]].numLiveTriangles,++m,c+=3;let C=0,h=i+1;a=1;let v=[];const b=[];let g,A,T=0;const x=[],P=o/3,w=[];for(f=0;f<P;f++)w[f]=!1;let S,I;for(;-1!==C;){v=[],A=y[C],I=A.vertexTriangles.length;for(let e=0;e<I;++e)if(m=A.vertexTriangles[e],!w[m]){w[m]=!0,c=m+m+m;for(let e=0;e<3;++e)S=t[c],v.push(S),b.push(S),x[T]=S,++T,g=y[S],--g.numLiveTriangles,h-g.timeStamp>i&&(g.timeStamp=h,++h),++c}C=s(0,i,v,y,h,b,u)}return x};var x=T;const P={};function w(e,t,n,i,r){e[t++]=n,e[t++]=i,e[t++]=i,e[t++]=r,e[t++]=r,e[t]=n}function S(e){const t={};for(const n in e)if(e.hasOwnProperty(n)&&r.defined(e[n])&&r.defined(e[n].values)){const i=e[n];t[n]=new f.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}function I(e,t,n){for(const i in t)if(t.hasOwnProperty(i)&&r.defined(t[i])&&r.defined(t[i].values)){const r=t[i];for(let t=0;t<r.componentsPerAttribute;++t)e[i].values.push(r.values[n*r.componentsPerAttribute+t])}}P.toWireframe=function(e){const t=e.indices;if(r.defined(t)){switch(e.primitiveType){case y.PrimitiveType.TRIANGLES:e.indices=function(e){const t=e.length,n=t/3*6,i=m.IndexDatatype.createTypedArray(t,n);let r=0;for(let n=0;n<t;n+=3,r+=6)w(i,r,e[n],e[n+1],e[n+2]);return i}(t);break;case y.PrimitiveType.TRIANGLE_STRIP:e.indices=function(e){const t=e.length;if(t>=3){const n=6*(t-2),i=m.IndexDatatype.createTypedArray(t,n);w(i,0,e[0],e[1],e[2]);let r=6;for(let n=3;n<t;++n,r+=6)w(i,r,e[n-1],e[n],e[n-2]);return i}return new Uint16Array}(t);break;case y.PrimitiveType.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){const t=e.length-1,n=6*(t-1),i=m.IndexDatatype.createTypedArray(t,n),r=e[0];let a=0;for(let n=1;n<t;++n,a+=6)w(i,a,r,e[n],e[n+1]);return i}return new Uint16Array}(t)}e.primitiveType=y.PrimitiveType.LINES}return e},P.createLineSegmentsForVectors=function(e,t,n){t=l.defaultValue(t,"normal"),n=l.defaultValue(n,1e4);const i=e.attributes.position.values,a=e.attributes[t].values,o=i.length,u=new Float64Array(2*o);let p,d=0;for(let e=0;e<o;e+=3)u[d++]=i[e],u[d++]=i[e+1],u[d++]=i[e+2],u[d++]=i[e]+a[e]*n,u[d++]=i[e+1]+a[e+1]*n,u[d++]=i[e+2]+a[e+2]*n;const m=e.boundingSphere;return r.defined(m)&&(p=new s.BoundingSphere(m.center,m.radius+n)),new y.Geometry({attributes:{position:new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u})},primitiveType:y.PrimitiveType.LINES,boundingSphere:p})},P.createAttributeLocations=function(e){const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,i={};let a,s=0;const o=t.length;for(a=0;a<o;++a){const e=t[a];r.defined(n[e])&&(i[e]=s++)}for(const e in n)n.hasOwnProperty(e)&&!r.defined(i[e])&&(i[e]=s++);return i},P.reorderForPreVertexCache=function(e){const t=y.Geometry.computeNumberOfVertices(e),n=e.indices;if(r.defined(n)){const i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;const a=n,s=a.length,o=m.IndexDatatype.createTypedArray(t,s);let u,l=0,p=0,d=0;for(;l<s;)u=i[a[l]],-1!==u?o[p]=u:(u=a[l],i[u]=d,o[p]=d,++d),++l,++p;e.indices=o;const y=e.attributes;for(const e in y)if(y.hasOwnProperty(e)&&r.defined(y[e])&&r.defined(y[e].values)){const n=y[e],r=n.values;let a=0;const s=n.componentsPerAttribute,o=c.ComponentDatatype.createTypedArray(n.componentDatatype,d*s);for(;a<t;){const e=i[a];if(-1!==e)for(let t=0;t<s;t++)o[s*e+t]=r[s*a+t];++a}n.values=o}}return e},P.reorderForPostVertexCache=function(e,t){const n=e.indices;if(e.primitiveType===y.PrimitiveType.TRIANGLES&&r.defined(n)){const i=n.length;let r=0;for(let e=0;e<i;e++)n[e]>r&&(r=n[e]);e.indices=x.tipsify({indices:n,maximumIndex:r,cacheSize:t})}return e},P.fitToUnsignedShortIndices=function(e){const t=[],n=y.Geometry.computeNumberOfVertices(e);if(r.defined(e.indices)&&n>=a.CesiumMath.SIXTY_FOUR_KILOBYTES){let n=[],i=[],s=0,o=S(e.attributes);const u=e.indices,c=u.length;let l;e.primitiveType===y.PrimitiveType.TRIANGLES?l=3:e.primitiveType===y.PrimitiveType.LINES?l=2:e.primitiveType===y.PrimitiveType.POINTS&&(l=1);for(let p=0;p<c;p+=l){for(let t=0;t<l;++t){const a=u[p+t];let c=n[a];r.defined(c)||(c=s++,n[a]=c,I(o,e.attributes,a)),i.push(c)}s+l>=a.CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new y.Geometry({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],i=[],s=0,o=S(e.attributes))}0!==i.length&&t.push(new y.Geometry({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const O=new i.Cartesian3,E=new u.Cartographic;P.projectTo2D=function(e,t,n,a,s){const o=e.attributes[t],u=(s=r.defined(s)?s:new d.GeographicProjection).ellipsoid,l=o.values,p=new Float64Array(l.length);let y=0;for(let e=0;e<l.length;e+=3){const t=i.Cartesian3.fromArray(l,e,O),n=u.cartesianToCartographic(t,E),r=s.project(n,O);p[y++]=r.x,p[y++]=r.y,p[y++]=r.z}return e.attributes[n]=o,e.attributes[a]=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:p}),delete e.attributes[t],e};const N={high:0,low:0};P.encodeAttribute=function(e,t,n,i){const r=e.attributes[t],a=r.values,s=a.length,o=new Float32Array(s),u=new Float32Array(s);for(let e=0;e<s;++e)p.EncodedCartesian3.encode(a[e],N),o[e]=N.high,u[e]=N.low;const l=r.componentsPerAttribute;return e.attributes[n]=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:l,values:o}),e.attributes[i]=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:l,values:u}),delete e.attributes[t],e};let L=new i.Cartesian3;function M(e,t){if(r.defined(t)){const n=t.values,r=n.length;for(let t=0;t<r;t+=3)i.Cartesian3.unpack(n,t,L),o.Matrix4.multiplyByPoint(e,L,L),i.Cartesian3.pack(L,n,t)}}function z(e,t){if(r.defined(t)){const n=t.values,r=n.length;for(let t=0;t<r;t+=3)i.Cartesian3.unpack(n,t,L),h.Matrix3.multiplyByVector(e,L,L),L=i.Cartesian3.normalize(L,L),i.Cartesian3.pack(L,n,t)}}const D=new o.Matrix4,G=new h.Matrix3;P.transformToWorldCoordinates=function(e){const t=e.modelMatrix;if(o.Matrix4.equals(t,o.Matrix4.IDENTITY))return e;const n=e.geometry.attributes;M(t,n.position),M(t,n.prevPosition),M(t,n.nextPosition),(r.defined(n.normal)||r.defined(n.tangent)||r.defined(n.bitangent))&&(o.Matrix4.inverse(t,D),o.Matrix4.transpose(D,D),o.Matrix4.getMatrix3(D,G),z(G,n.normal),z(G,n.tangent),z(G,n.bitangent));const i=e.geometry.boundingSphere;return r.defined(i)&&(e.geometry.boundingSphere=s.BoundingSphere.transform(i,t,i)),e.modelMatrix=o.Matrix4.clone(o.Matrix4.IDENTITY),e};const V=new i.Cartesian3;function R(e,t){const n=e.length;let a,o,u,l;e[0].modelMatrix;const p=r.defined(e[0][t].indices),d=e[0][t].primitiveType,C=function(e,t){const n=e.length,i={},a=e[0][t].attributes;let s;for(s in a)if(a.hasOwnProperty(s)&&r.defined(a[s])&&r.defined(a[s].values)){const o=a[s];let u=o.values.length,l=!0;for(let i=1;i<n;++i){const n=e[i][t].attributes[s];if(!r.defined(n)||o.componentDatatype!==n.componentDatatype||o.componentsPerAttribute!==n.componentsPerAttribute||o.normalize!==n.normalize){l=!1;break}u+=n.values.length}l&&(i[s]=new f.GeometryAttribute({componentDatatype:o.componentDatatype,componentsPerAttribute:o.componentsPerAttribute,normalize:o.normalize,values:c.ComponentDatatype.createTypedArray(o.componentDatatype,u)}))}return i}(e,t);let h,v,b,g;for(a in C)if(C.hasOwnProperty(a))for(h=C[a].values,l=0,o=0;o<n;++o)for(v=e[o][t].attributes[a].values,b=v.length,u=0;u<b;++u)h[l++]=v[u];if(p){let i=0;for(o=0;o<n;++o)i+=e[o][t].indices.length;const r=y.Geometry.computeNumberOfVertices(new y.Geometry({attributes:C,primitiveType:y.PrimitiveType.POINTS})),a=m.IndexDatatype.createTypedArray(r,i);let s=0,u=0;for(o=0;o<n;++o){const n=e[o][t].indices,i=n.length;for(l=0;l<i;++l)a[s++]=u+n[l];u+=y.Geometry.computeNumberOfVertices(e[o][t])}g=a}let A,T=new i.Cartesian3,x=0;for(o=0;o<n;++o){if(A=e[o][t].boundingSphere,!r.defined(A)){T=void 0;break}i.Cartesian3.add(A.center,T,T)}if(r.defined(T))for(i.Cartesian3.divideByScalar(T,n,T),o=0;o<n;++o){A=e[o][t].boundingSphere;const n=i.Cartesian3.magnitude(i.Cartesian3.subtract(A.center,T,V))+A.radius;n>x&&(x=n)}return new y.Geometry({attributes:C,indices:g,primitiveType:d,boundingSphere:r.defined(T)?new s.BoundingSphere(T,x):void 0})}P.combineInstances=function(e){const t=[],n=[],i=e.length;for(let a=0;a<i;++a){const i=e[a];r.defined(i.geometry)?t.push(i):r.defined(i.westHemisphereGeometry)&&r.defined(i.eastHemisphereGeometry)&&n.push(i)}const a=[];return t.length>0&&a.push(R(t,"geometry")),n.length>0&&(a.push(R(n,"westHemisphereGeometry")),a.push(R(n,"eastHemisphereGeometry"))),a};const F=new i.Cartesian3,B=new i.Cartesian3,k=new i.Cartesian3,_=new i.Cartesian3;P.computeNormal=function(e){const t=e.indices,n=e.attributes,r=n.position.values,s=n.position.values.length/3,o=t.length,u=new Array(s),l=new Array(o/3),p=new Array(o);let d;for(d=0;d<s;d++)u[d]={indexOffset:0,count:0,currentCount:0};let y=0;for(d=0;d<o;d+=3){const e=t[d],n=t[d+1],a=t[d+2],s=3*e,o=3*n,c=3*a;B.x=r[s],B.y=r[s+1],B.z=r[s+2],k.x=r[o],k.y=r[o+1],k.z=r[o+2],_.x=r[c],_.y=r[c+1],_.z=r[c+2],u[e].count++,u[n].count++,u[a].count++,i.Cartesian3.subtract(k,B,k),i.Cartesian3.subtract(_,B,_),l[y]=i.Cartesian3.cross(k,_,new i.Cartesian3),y++}let m,C=0;for(d=0;d<s;d++)u[d].indexOffset+=C,C+=u[d].count;for(y=0,d=0;d<o;d+=3){m=u[t[d]];let e=m.indexOffset+m.currentCount;p[e]=y,m.currentCount++,m=u[t[d+1]],e=m.indexOffset+m.currentCount,p[e]=y,m.currentCount++,m=u[t[d+2]],e=m.indexOffset+m.currentCount,p[e]=y,m.currentCount++,y++}const h=new Float32Array(3*s);for(d=0;d<s;d++){const e=3*d;if(m=u[d],i.Cartesian3.clone(i.Cartesian3.ZERO,F),m.count>0){for(y=0;y<m.count;y++)i.Cartesian3.add(F,l[p[m.indexOffset+y]],F);i.Cartesian3.equalsEpsilon(i.Cartesian3.ZERO,F,a.CesiumMath.EPSILON10)&&i.Cartesian3.clone(l[p[m.indexOffset]],F)}i.Cartesian3.equalsEpsilon(i.Cartesian3.ZERO,F,a.CesiumMath.EPSILON10)&&(F.z=1),i.Cartesian3.normalize(F,F),h[e]=F.x,h[e+1]=F.y,h[e+2]=F.z}return e.attributes.normal=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:h}),e};const q=new i.Cartesian3,U=new i.Cartesian3,Y=new i.Cartesian3;P.computeTangentAndBitangent=function(e){e.attributes;const t=e.indices,n=e.attributes.position.values,r=e.attributes.normal.values,a=e.attributes.st.values,s=e.attributes.position.values.length/3,o=t.length,u=new Array(3*s);let l,p,d,y;for(l=0;l<u.length;l++)u[l]=0;for(l=0;l<o;l+=3){const e=t[l],i=t[l+1],r=t[l+2];p=3*e,d=3*i,y=3*r;const s=2*e,o=2*i,c=2*r,f=n[p],m=n[p+1],C=n[p+2],h=a[s],v=a[s+1],b=a[o+1]-v,g=a[c+1]-v,A=1/((a[o]-h)*g-(a[c]-h)*b),T=(g*(n[d]-f)-b*(n[y]-f))*A,x=(g*(n[d+1]-m)-b*(n[y+1]-m))*A,P=(g*(n[d+2]-C)-b*(n[y+2]-C))*A;u[p]+=T,u[p+1]+=x,u[p+2]+=P,u[d]+=T,u[d+1]+=x,u[d+2]+=P,u[y]+=T,u[y+1]+=x,u[y+2]+=P}const m=new Float32Array(3*s),C=new Float32Array(3*s);for(l=0;l<s;l++){p=3*l,d=p+1,y=p+2;const e=i.Cartesian3.fromArray(r,p,q),t=i.Cartesian3.fromArray(u,p,Y),n=i.Cartesian3.dot(e,t);i.Cartesian3.multiplyByScalar(e,n,U),i.Cartesian3.normalize(i.Cartesian3.subtract(t,U,t),t),m[p]=t.x,m[d]=t.y,m[y]=t.z,i.Cartesian3.normalize(i.Cartesian3.cross(e,t,t),t),C[p]=t.x,C[d]=t.y,C[y]=t.z}return e.attributes.tangent=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m}),e.attributes.bitangent=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e};const Z=new n.Cartesian2,H=new i.Cartesian3,W=new i.Cartesian3,j=new i.Cartesian3;let X=new n.Cartesian2;function J(e){switch(e.primitiveType){case y.PrimitiveType.TRIANGLE_FAN:return function(e){const t=y.Geometry.computeNumberOfVertices(e),n=m.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let e=3;e<t;++e)n[i++]=e-1,n[i++]=0,n[i++]=e;return e.indices=n,e.primitiveType=y.PrimitiveType.TRIANGLES,e}(e);case y.PrimitiveType.TRIANGLE_STRIP:return function(e){const t=y.Geometry.computeNumberOfVertices(e),n=m.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,t>3&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let e=3;e<t-1;e+=2)n[i++]=e,n[i++]=e-1,n[i++]=e+1,e+2<t&&(n[i++]=e,n[i++]=e+1,n[i++]=e+2);return e.indices=n,e.primitiveType=y.PrimitiveType.TRIANGLES,e}(e);case y.PrimitiveType.TRIANGLES:return function(e){if(r.defined(e.indices))return e;const t=y.Geometry.computeNumberOfVertices(e),n=m.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e);case y.PrimitiveType.LINE_STRIP:return function(e){const t=y.Geometry.computeNumberOfVertices(e),n=m.IndexDatatype.createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return e.indices=n,e.primitiveType=y.PrimitiveType.LINES,e}(e);case y.PrimitiveType.LINE_LOOP:return function(e){const t=y.Geometry.computeNumberOfVertices(e),n=m.IndexDatatype.createTypedArray(t,2*t);n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return n[i++]=t-1,n[i]=0,e.indices=n,e.primitiveType=y.PrimitiveType.LINES,e}(e);case y.PrimitiveType.LINES:return function(e){if(r.defined(e.indices))return e;const t=y.Geometry.computeNumberOfVertices(e),n=m.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e)}return e}function K(e,t){Math.abs(e.y)<a.CesiumMath.EPSILON6&&(e.y=t?-a.CesiumMath.EPSILON6:a.CesiumMath.EPSILON6)}P.compressVertices=function(e){const a=e.attributes.extrudeDirection;let s,o;if(r.defined(a)){const n=a.values;o=n.length/3;const r=new Float32Array(2*o);let u=0;for(s=0;s<o;++s)i.Cartesian3.fromArray(n,3*s,H),i.Cartesian3.equals(H,i.Cartesian3.ZERO)?u+=2:(X=t.AttributeCompression.octEncodeInRange(H,65535,X),r[u++]=X.x,r[u++]=X.y);return e.attributes.compressedAttributes=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:r}),delete e.attributes.extrudeDirection,e}const u=e.attributes.normal,l=e.attributes.st,p=r.defined(u),d=r.defined(l);if(!p&&!d)return e;const y=e.attributes.tangent,m=e.attributes.bitangent,C=r.defined(y),h=r.defined(m);let v,b,g,A;p&&(v=u.values),d&&(b=l.values),C&&(g=y.values),h&&(A=m.values);o=(p?v.length:b.length)/(p?3:2);let T=o,x=d&&p?2:1;x+=C||h?1:0,T*=x;const P=new Float32Array(T);let w=0;for(s=0;s<o;++s){d&&(n.Cartesian2.fromArray(b,2*s,Z),P[w++]=t.AttributeCompression.compressTextureCoordinates(Z));const e=3*s;p&&r.defined(g)&&r.defined(A)?(i.Cartesian3.fromArray(v,e,H),i.Cartesian3.fromArray(g,e,W),i.Cartesian3.fromArray(A,e,j),t.AttributeCompression.octPack(H,W,j,Z),P[w++]=Z.x,P[w++]=Z.y):(p&&(i.Cartesian3.fromArray(v,e,H),P[w++]=t.AttributeCompression.octEncodeFloat(H)),C&&(i.Cartesian3.fromArray(g,e,H),P[w++]=t.AttributeCompression.octEncodeFloat(H)),h&&(i.Cartesian3.fromArray(A,e,H),P[w++]=t.AttributeCompression.octEncodeFloat(H)))}return e.attributes.compressedAttributes=new f.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:x,values:P}),p&&delete e.attributes.normal,d&&delete e.attributes.st,h&&delete e.attributes.bitangent,C&&delete e.attributes.tangent,e};const Q=new i.Cartesian3;function $(e,t,n,r){i.Cartesian3.add(e,i.Cartesian3.multiplyByScalar(i.Cartesian3.subtract(t,e,Q),e.y/(e.y-t.y),Q),n),i.Cartesian3.clone(n,r),K(n,!0),K(r,!1)}const ee=new i.Cartesian3,te=new i.Cartesian3,ne=new i.Cartesian3,ie=new i.Cartesian3,re={positions:new Array(7),indices:new Array(9)};function ae(e,t,n){if(e.x>=0||t.x>=0||n.x>=0)return;!function(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return K(e,e.y<0),K(t,t.y<0),void K(n,n.y<0);const i=Math.abs(e.y),r=Math.abs(t.y),s=Math.abs(n.y);let o;o=i>r?i>s?a.CesiumMath.sign(e.y):a.CesiumMath.sign(n.y):r>s?a.CesiumMath.sign(t.y):a.CesiumMath.sign(n.y);const u=o<0;K(e,u),K(t,u),K(n,u)}(e,t,n);const i=e.y<0,r=t.y<0,s=n.y<0;let o=0;o+=i?1:0,o+=r?1:0,o+=s?1:0;const u=re.indices;1===o?(u[1]=3,u[2]=4,u[5]=6,u[7]=6,u[8]=5,i?($(e,t,ee,ne),$(e,n,te,ie),u[0]=0,u[3]=1,u[4]=2,u[6]=1):r?($(t,n,ee,ne),$(t,e,te,ie),u[0]=1,u[3]=2,u[4]=0,u[6]=2):s&&($(n,e,ee,ne),$(n,t,te,ie),u[0]=2,u[3]=0,u[4]=1,u[6]=0)):2===o&&(u[2]=4,u[4]=4,u[5]=3,u[7]=5,u[8]=6,i?r?s||($(n,e,ee,ne),$(n,t,te,ie),u[0]=0,u[1]=1,u[3]=0,u[6]=2):($(t,n,ee,ne),$(t,e,te,ie),u[0]=2,u[1]=0,u[3]=2,u[6]=1):($(e,t,ee,ne),$(e,n,te,ie),u[0]=1,u[1]=2,u[3]=1,u[6]=0));const c=re.positions;return c[0]=e,c[1]=t,c[2]=n,c.length=3,1!==o&&2!==o||(c[3]=ee,c[4]=te,c[5]=ne,c[6]=ie,c.length=7),re}function se(e,t){const n=e.attributes;if(0===n.position.values.length)return;for(const e in n)if(n.hasOwnProperty(e)&&r.defined(n[e])&&r.defined(n[e].values)){const t=n[e];t.values=c.ComponentDatatype.createTypedArray(t.componentDatatype,t.values)}const i=y.Geometry.computeNumberOfVertices(e);return e.indices=m.IndexDatatype.createTypedArray(i,e.indices),t&&(e.boundingSphere=s.BoundingSphere.fromVertices(n.position.values)),e}function oe(e){const t=e.attributes,n={};for(const e in t)if(t.hasOwnProperty(e)&&r.defined(t[e])&&r.defined(t[e].values)){const i=t[e];n[e]=new f.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new y.Geometry({attributes:n,indices:[],primitiveType:e.primitiveType})}function ue(e,t,n){const i=r.defined(e.geometry.boundingSphere);t=se(t,i),n=se(n,i),r.defined(n)&&!r.defined(t)?e.geometry=n:!r.defined(n)&&r.defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function ce(e,t){const n=new e,i=new e,r=new e;return function(a,s,o,u,c,l,p,d){const y=e.fromArray(c,a*t,n),f=e.fromArray(c,s*t,i),m=e.fromArray(c,o*t,r);e.multiplyByScalar(y,u.x,y),e.multiplyByScalar(f,u.y,f),e.multiplyByScalar(m,u.z,m);const C=e.add(y,f,y);e.add(C,m,C),d&&e.normalize(C,C),e.pack(C,l,p*t)}}const le=ce(o.Cartesian4,4),pe=ce(i.Cartesian3,3),de=ce(n.Cartesian2,2),ye=function(e,t,n,i,r,s,o){const u=r[e]*i.x,c=r[t]*i.y,l=r[n]*i.z;s[o]=u+c+l>a.CesiumMath.EPSILON6?1:0},fe=new i.Cartesian3,me=new i.Cartesian3,Ce=new i.Cartesian3,he=new i.Cartesian3;function ve(e,t,s,o,u,c,l,p,d,y,f,m,C,h,v,T){if(!(r.defined(c)||r.defined(l)||r.defined(p)||r.defined(d)||r.defined(y)||0!==h))return;const x=function(e,t,s,o,u){let c,l,p,d,y,f,m,C;if(r.defined(u)||(u=new i.Cartesian3),r.defined(t.z)){if(i.Cartesian3.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_X,u);if(i.Cartesian3.equalsEpsilon(e,s,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Y,u);if(i.Cartesian3.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Z,u);c=i.Cartesian3.subtract(s,t,b),l=i.Cartesian3.subtract(o,t,g),p=i.Cartesian3.subtract(e,t,A),d=i.Cartesian3.dot(c,c),y=i.Cartesian3.dot(c,l),f=i.Cartesian3.dot(c,p),m=i.Cartesian3.dot(l,l),C=i.Cartesian3.dot(l,p)}else{if(n.Cartesian2.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_X,u);if(n.Cartesian2.equalsEpsilon(e,s,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Y,u);if(n.Cartesian2.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Z,u);c=n.Cartesian2.subtract(s,t,b),l=n.Cartesian2.subtract(o,t,g),p=n.Cartesian2.subtract(e,t,A),d=n.Cartesian2.dot(c,c),y=n.Cartesian2.dot(c,l),f=n.Cartesian2.dot(c,p),m=n.Cartesian2.dot(l,l),C=n.Cartesian2.dot(l,p)}u.y=m*f-y*C,u.z=d*C-y*f;const h=d*m-y*y;if(0!==h)return u.y/=h,u.z/=h,u.x=1-u.y-u.z,u}(o,i.Cartesian3.fromArray(u,3*e,fe),i.Cartesian3.fromArray(u,3*t,me),i.Cartesian3.fromArray(u,3*s,Ce),he);if(r.defined(x)){if(r.defined(c)&&pe(e,t,s,x,c,m.normal.values,T,!0),r.defined(y)){const n=i.Cartesian3.fromArray(y,3*e,fe),r=i.Cartesian3.fromArray(y,3*t,me),a=i.Cartesian3.fromArray(y,3*s,Ce);let o;i.Cartesian3.multiplyByScalar(n,x.x,n),i.Cartesian3.multiplyByScalar(r,x.y,r),i.Cartesian3.multiplyByScalar(a,x.z,a),i.Cartesian3.equals(n,i.Cartesian3.ZERO)&&i.Cartesian3.equals(r,i.Cartesian3.ZERO)&&i.Cartesian3.equals(a,i.Cartesian3.ZERO)?(o=fe,o.x=0,o.y=0,o.z=0):(o=i.Cartesian3.add(n,r,n),i.Cartesian3.add(o,a,o),i.Cartesian3.normalize(o,o)),i.Cartesian3.pack(o,m.extrudeDirection.values,3*T)}if(r.defined(f)&&ye(e,t,s,x,f,m.applyOffset.values,T),r.defined(l)&&pe(e,t,s,x,l,m.tangent.values,T,!0),r.defined(p)&&pe(e,t,s,x,p,m.bitangent.values,T,!0),r.defined(d)&&de(e,t,s,x,d,m.st.values,T),h>0)for(let n=0;n<h;n++){const i=C[n];be(e,t,s,x,T,v[i],m[i])}}}function be(e,t,n,i,r,a,s){const o=a.componentsPerAttribute,u=a.values,c=s.values;switch(o){case 4:le(e,t,n,i,u,c,r,!1);break;case 3:pe(e,t,n,i,u,c,r,!1);break;case 2:de(e,t,n,i,u,c,r,!1);break;default:c[r]=u[e]*i.x+u[t]*i.y+u[n]*i.z}}function ge(e,t,n,i,r,a){const s=e.position.values.length/3;if(-1!==r){const o=i[r],u=n[o];return-1===u?(n[o]=s,e.position.values.push(a.x,a.y,a.z),t.push(s),s):(t.push(u),u)}return e.position.values.push(a.x,a.y,a.z),t.push(s),s}const Ae={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function Te(e){const t=e.geometry,n=t.attributes,a=n.position.values,s=r.defined(n.normal)?n.normal.values:void 0,o=r.defined(n.bitangent)?n.bitangent.values:void 0,u=r.defined(n.tangent)?n.tangent.values:void 0,c=r.defined(n.st)?n.st.values:void 0,l=r.defined(n.extrudeDirection)?n.extrudeDirection.values:void 0,p=r.defined(n.applyOffset)?n.applyOffset.values:void 0,d=t.indices,y=[];for(const e in n)n.hasOwnProperty(e)&&!Ae[e]&&r.defined(n[e])&&y.push(e);const f=y.length,m=oe(t),C=oe(t);let h,v,b,g,A;const T=[];T.length=a.length/3;const x=[];for(x.length=a.length/3,A=0;A<T.length;++A)T[A]=-1,x[A]=-1;const P=d.length;for(A=0;A<P;A+=3){const e=d[A],t=d[A+1],P=d[A+2];let w=i.Cartesian3.fromArray(a,3*e),S=i.Cartesian3.fromArray(a,3*t),I=i.Cartesian3.fromArray(a,3*P);const O=ae(w,S,I);if(r.defined(O)&&O.positions.length>3){const i=O.positions,r=O.indices,w=r.length;for(let S=0;S<w;++S){const w=r[S],I=i[w];I.y<0?(h=C.attributes,v=C.indices,b=T):(h=m.attributes,v=m.indices,b=x),g=ge(h,v,b,d,w<3?A+w:-1,I),ve(e,t,P,I,a,s,u,o,c,l,p,h,y,f,n,g)}}else r.defined(O)&&(w=O.positions[0],S=O.positions[1],I=O.positions[2]),w.y<0?(h=C.attributes,v=C.indices,b=T):(h=m.attributes,v=m.indices,b=x),g=ge(h,v,b,d,A,w),ve(e,t,P,w,a,s,u,o,c,l,p,h,y,f,n,g),g=ge(h,v,b,d,A+1,S),ve(e,t,P,S,a,s,u,o,c,l,p,h,y,f,n,g),g=ge(h,v,b,d,A+2,I),ve(e,t,P,I,a,s,u,o,c,l,p,h,y,f,n,g)}ue(e,C,m)}const xe=v.Plane.fromPointNormal(i.Cartesian3.ZERO,i.Cartesian3.UNIT_Y),Pe=new i.Cartesian3,we=new i.Cartesian3;function Se(e,t,n,s,o,u,c){if(!r.defined(c))return;const l=i.Cartesian3.fromArray(s,3*e,fe);i.Cartesian3.equalsEpsilon(l,n,a.CesiumMath.EPSILON10)?u.applyOffset.values[o]=c[e]:u.applyOffset.values[o]=c[t]}function Ie(e){const t=e.geometry,n=t.attributes,s=n.position.values,o=r.defined(n.applyOffset)?n.applyOffset.values:void 0,u=t.indices,c=oe(t),l=oe(t);let p;const d=u.length,y=[];y.length=s.length/3;const f=[];for(f.length=s.length/3,p=0;p<y.length;++p)y[p]=-1,f[p]=-1;for(p=0;p<d;p+=2){const e=u[p],t=u[p+1],n=i.Cartesian3.fromArray(s,3*e,fe),d=i.Cartesian3.fromArray(s,3*t,me);let m;Math.abs(n.y)<a.CesiumMath.EPSILON6&&(n.y<0?n.y=-a.CesiumMath.EPSILON6:n.y=a.CesiumMath.EPSILON6),Math.abs(d.y)<a.CesiumMath.EPSILON6&&(d.y<0?d.y=-a.CesiumMath.EPSILON6:d.y=a.CesiumMath.EPSILON6);let h=c.attributes,v=c.indices,b=f,g=l.attributes,A=l.indices,T=y;const x=C.IntersectionTests.lineSegmentPlane(n,d,xe,Ce);if(r.defined(x)){const r=i.Cartesian3.multiplyByScalar(i.Cartesian3.UNIT_Y,5*a.CesiumMath.EPSILON9,Pe);n.y<0&&(i.Cartesian3.negate(r,r),h=l.attributes,v=l.indices,b=y,g=c.attributes,A=c.indices,T=f);const C=i.Cartesian3.add(x,r,we);m=ge(h,v,b,u,p,n),Se(e,t,n,s,m,h,o),m=ge(h,v,b,u,-1,C),Se(e,t,C,s,m,h,o),i.Cartesian3.negate(r,r),i.Cartesian3.add(x,r,C),m=ge(g,A,T,u,-1,C),Se(e,t,C,s,m,g,o),m=ge(g,A,T,u,p+1,d),Se(e,t,d,s,m,g,o)}else{let i,r,a;n.y<0?(i=l.attributes,r=l.indices,a=y):(i=c.attributes,r=c.indices,a=f),m=ge(i,r,a,u,p,n),Se(e,t,n,s,m,i,o),m=ge(i,r,a,u,p+1,d),Se(e,t,d,s,m,i,o)}}ue(e,l,c)}const Oe=new n.Cartesian2,Ee=new n.Cartesian2,Ne=new i.Cartesian3,Le=new i.Cartesian3,Me=new i.Cartesian3,ze=new i.Cartesian3,De=new i.Cartesian3,Ge=new i.Cartesian3,Ve=new o.Cartesian4;function Re(e){const t=e.attributes,n=t.position.values,r=t.prevPosition.values,a=t.nextPosition.values,s=n.length;for(let e=0;e<s;e+=3){const t=i.Cartesian3.unpack(n,e,Ne);if(t.x>0)continue;const o=i.Cartesian3.unpack(r,e,Le);(t.y<0&&o.y>0||t.y>0&&o.y<0)&&(e-3>0?(r[e]=n[e-3],r[e+1]=n[e-2],r[e+2]=n[e-1]):i.Cartesian3.pack(t,r,e));const u=i.Cartesian3.unpack(a,e,Me);(t.y<0&&u.y>0||t.y>0&&u.y<0)&&(e+3<s?(a[e]=n[e+3],a[e+1]=n[e+4],a[e+2]=n[e+5]):i.Cartesian3.pack(t,a,e))}}const Fe=5*a.CesiumMath.EPSILON9,Be=a.CesiumMath.EPSILON6;P.splitLongitude=function(e){const t=e.geometry,u=t.boundingSphere;if(r.defined(u)){if(u.center.x-u.radius>0||s.BoundingSphere.intersectPlane(u,v.Plane.ORIGIN_ZX_PLANE)!==s.Intersect.INTERSECTING)return e}if(t.geometryType!==y.GeometryType.NONE)switch(t.geometryType){case y.GeometryType.POLYLINES:!function(e){const t=e.geometry,s=t.attributes,u=s.position.values,c=s.prevPosition.values,l=s.nextPosition.values,p=s.expandAndWidth.values,d=r.defined(s.st)?s.st.values:void 0,y=r.defined(s.color)?s.color.values:void 0,f=oe(t),m=oe(t);let h,v,b,g=!1;const A=u.length/3;for(h=0;h<A;h+=4){const e=h,t=h+2,s=i.Cartesian3.fromArray(u,3*e,Ne),A=i.Cartesian3.fromArray(u,3*t,Le);if(Math.abs(s.y)<Be)for(s.y=Be*(A.y<0?-1:1),u[3*h+1]=s.y,u[3*(h+1)+1]=s.y,v=3*e;v<3*e+12;v+=3)c[v]=u[3*h],c[v+1]=u[3*h+1],c[v+2]=u[3*h+2];if(Math.abs(A.y)<Be)for(A.y=Be*(s.y<0?-1:1),u[3*(h+2)+1]=A.y,u[3*(h+3)+1]=A.y,v=3*e;v<3*e+12;v+=3)l[v]=u[3*(h+2)],l[v+1]=u[3*(h+2)+1],l[v+2]=u[3*(h+2)+2];let T=f.attributes,x=f.indices,P=m.attributes,w=m.indices;const S=C.IntersectionTests.lineSegmentPlane(s,A,xe,ze);if(r.defined(S)){g=!0;const u=i.Cartesian3.multiplyByScalar(i.Cartesian3.UNIT_Y,Fe,De);s.y<0&&(i.Cartesian3.negate(u,u),T=m.attributes,x=m.indices,P=f.attributes,w=f.indices);const C=i.Cartesian3.add(S,u,Ge);T.position.values.push(s.x,s.y,s.z,s.x,s.y,s.z),T.position.values.push(C.x,C.y,C.z),T.position.values.push(C.x,C.y,C.z),T.prevPosition.values.push(c[3*e],c[3*e+1],c[3*e+2]),T.prevPosition.values.push(c[3*e+3],c[3*e+4],c[3*e+5]),T.prevPosition.values.push(s.x,s.y,s.z,s.x,s.y,s.z),T.nextPosition.values.push(C.x,C.y,C.z),T.nextPosition.values.push(C.x,C.y,C.z),T.nextPosition.values.push(C.x,C.y,C.z),T.nextPosition.values.push(C.x,C.y,C.z),i.Cartesian3.negate(u,u),i.Cartesian3.add(S,u,C),P.position.values.push(C.x,C.y,C.z),P.position.values.push(C.x,C.y,C.z),P.position.values.push(A.x,A.y,A.z,A.x,A.y,A.z),P.prevPosition.values.push(C.x,C.y,C.z),P.prevPosition.values.push(C.x,C.y,C.z),P.prevPosition.values.push(C.x,C.y,C.z),P.prevPosition.values.push(C.x,C.y,C.z),P.nextPosition.values.push(A.x,A.y,A.z,A.x,A.y,A.z),P.nextPosition.values.push(l[3*t],l[3*t+1],l[3*t+2]),P.nextPosition.values.push(l[3*t+3],l[3*t+4],l[3*t+5]);const I=n.Cartesian2.fromArray(p,2*e,Oe),O=Math.abs(I.y);T.expandAndWidth.values.push(-1,O,1,O),T.expandAndWidth.values.push(-1,-O,1,-O),P.expandAndWidth.values.push(-1,O,1,O),P.expandAndWidth.values.push(-1,-O,1,-O);let E=i.Cartesian3.magnitudeSquared(i.Cartesian3.subtract(S,s,Me));if(E/=i.Cartesian3.magnitudeSquared(i.Cartesian3.subtract(A,s,Me)),r.defined(y)){const n=o.Cartesian4.fromArray(y,4*e,Ve),i=o.Cartesian4.fromArray(y,4*t,Ve),r=a.CesiumMath.lerp(n.x,i.x,E),s=a.CesiumMath.lerp(n.y,i.y,E),u=a.CesiumMath.lerp(n.z,i.z,E),c=a.CesiumMath.lerp(n.w,i.w,E);for(v=4*e;v<4*e+8;++v)T.color.values.push(y[v]);for(T.color.values.push(r,s,u,c),T.color.values.push(r,s,u,c),P.color.values.push(r,s,u,c),P.color.values.push(r,s,u,c),v=4*t;v<4*t+8;++v)P.color.values.push(y[v])}if(r.defined(d)){const i=n.Cartesian2.fromArray(d,2*e,Oe),r=n.Cartesian2.fromArray(d,2*(h+3),Ee),s=a.CesiumMath.lerp(i.x,r.x,E);for(v=2*e;v<2*e+4;++v)T.st.values.push(d[v]);for(T.st.values.push(s,i.y),T.st.values.push(s,r.y),P.st.values.push(s,i.y),P.st.values.push(s,r.y),v=2*t;v<2*t+4;++v)P.st.values.push(d[v])}b=T.position.values.length/3-4,x.push(b,b+2,b+1),x.push(b+1,b+2,b+3),b=P.position.values.length/3-4,w.push(b,b+2,b+1),w.push(b+1,b+2,b+3)}else{let e,t;for(s.y<0?(e=m.attributes,t=m.indices):(e=f.attributes,t=f.indices),e.position.values.push(s.x,s.y,s.z),e.position.values.push(s.x,s.y,s.z),e.position.values.push(A.x,A.y,A.z),e.position.values.push(A.x,A.y,A.z),v=3*h;v<3*h+12;++v)e.prevPosition.values.push(c[v]),e.nextPosition.values.push(l[v]);for(v=2*h;v<2*h+8;++v)e.expandAndWidth.values.push(p[v]),r.defined(d)&&e.st.values.push(d[v]);if(r.defined(y))for(v=4*h;v<4*h+16;++v)e.color.values.push(y[v]);b=e.position.values.length/3-4,t.push(b,b+2,b+1),t.push(b+1,b+2,b+3)}}g&&(Re(m),Re(f)),ue(e,m,f)}(e);break;case y.GeometryType.TRIANGLES:Te(e);break;case y.GeometryType.LINES:Ie(e)}else J(t),t.primitiveType===y.PrimitiveType.TRIANGLES?Te(e):t.primitiveType===y.PrimitiveType.LINES&&Ie(e);return e};var ke=P;e.GeometryPipeline=ke}));
